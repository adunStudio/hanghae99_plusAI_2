[
    {
        "term": "유니티",
        "description": "유니티(Unity)는 주로 게임 개발에 사용되는 크로스 플랫폼 엔진으로, 2D 및 3D 게임을 쉽게 제작할 수 있도록 돕는 다양한 도구와 기능을 제공합니다. 유니티는 특히 직관적인 인터페이스와 강력한 커뮤니티 지원으로 널리 사용되고 있습니다."
    },
    {
        "term": "뱀서라이크",
        "description": "뱀서라이크(Survivor-like) 게임 장르는 주로 플레이어가 생존을 목표로 하며, 적들과의 전투, 자원 수집 등의 요소를 포함하는 게임입니다. 이 장르는 다양한 아이디어와 시스템을 활용하여 플레이어에게 도전과 재미를 제공합니다."
    },
    {
        "term": "2D URP",
        "description": "2D URP(Universal Render Pipeline)는 유니티에서 제공하는 렌더링 파이프라인 중 하나로, 2D 게임을 위한 최적화된 그래픽을 제공합니다. URP는 효율적인 렌더링과 높은 성능, 현실적인 그림자와 조명 효과를 지원하여 더 나은 시각적 품질을 목표로 합니다."
    },
    {
        "term": "에셋",
        "description": "게임 개발에서 에셋(asset)은 게임의 구성 요소를 의미하며, 이미지, 사운드, 애니메이션, 스크립트 등 다양한 파일을 포함합니다. 유니티는 에셋을 쉽게 가져오고 관리할 수 있는 기능을 제공하여 개발자가 프로젝트의 시각적 및 기능적 요소를 효과적으로 통합할 수 있도록 합니다."
    },
    {
        "term": "스프라이트",
        "description": "스프라이트(sprite)는 2D 비디오 게임에서 사용되는 2D 이미지를 의미합니다. 이는 게임 캐릭터, 아이템, 배경 등의 시각적 요소를 구성하며, 유니티에서는 스프라이트 렌더러를 통해 화면에 표시됩니다. 스프라이트의 픽셀 크기와 필터 모드는 이미지의 해상도와 품질을 결정하는 중요한 요소입니다."
    },
    {
        "term": "컴포넌트",
        "description": "유니티에서 컴포넌트(component)는 게임 오브젝트에 추가되어 해당 오브젝트의 기능을 정의하는 모듈입니다. 예를 들어, 리지드 바디 2D(Rigidbody2D)는 물리적 특성을 부여하고, 콜라이더(Collider)는 충돌 처리를 담당합니다. 이러한 컴포넌트는 게임 오브젝트의 행동을 프로그래밍하기 위한 기초적인 요소로 사용됩니다."
    },
    {
        "term": "픽셀 퍼 유닛",
        "description": "픽셀 퍼 유닛(Pixels Per Unit)은 유니티에서 스프라이트의 크기를 조정하는 설정으로, 스프라이트의 이미지 픽셀 수를 유니티 공간에서의 단위 크기와 연결합니다. 이 설정은 스프라이트의 현실적인 크기와 해상도를 맞추기 위해 중요합니다."
    },
    {
        "term": "리지드 바디 2D",
        "description": "리지드 바디 2D(Rigidbody2D)는 유니티에서 2D 물리 엔진을 사용하여 게임 오브젝트의 물리적인 행동을 정의하는 컴포넌트입니다. 이를 통해 중력, 충돌, 이동과 같은 물리적 상호작용을 적용할 수 있습니다."
    },
    {
        "term": "캡슐 콜라이더 2D",
        "description": "캡슐 콜라이더 2D(Capsule Collider 2D)는 유니티에서 사용되는 2D 콜라이더의 한 종류로, 캡슐 형태를 가진 충돌체로서 주로 캐릭터와 같은 비인간형 오브젝트에 적합합니다. 이 콜라이더는 물리적인 충돌 감지에 사용됩니다."
    },
    {
        "term": "C# 스크립트",
        "description": "Unity 게임 개발에 사용되는 프로그래밍 언어인 C#을 활용하여 게임의 로직을 작성하는 코드. 스크립트는 게임 오브젝트의 동작을 정의하며, 이벤트에 반응하여 다양한 기능을 수행할 수 있다."
    },
    {
        "term": "입력 처리(Input Handling)",
        "description": "사용자 입력(키보드, 마우스 등)을 받는 과정. Unity에서는 Input 클래스를 사용하여 사용자의 입력을 감지하고 처리하는 방법을 제공한다."
    },
    {
        "term": "물리 이동(Physics-Based Movement)",
        "description": "Unity의 물리 엔진을 활용하여 오브젝트의 이동을 구현하는 방식. 리지드바디(Rigidbody) 컴포넌트를 사용하여 물리적인 힘이나 속도를 적용하여 움직일 수 있다."
    },
    {
        "term": "리지드바디 2D(Rigidbody2D)",
        "description": "Unity에서 2D 게임 오브젝트에 물리 법칙을 적용하기 위해 사용하는 컴포넌트. 중력, 충돌 및 물리적 상호작용을 시뮬레이션할 수 있도록 설정할 수 있다."
    },
    {
        "term": "AddForce",
        "description": "C# 스크립트에서 리지드바디에 힘을 추가하여 오브젝트를 이동시키는 함수. 주로 물리 기반의 동작에서 사용되며, 힘의 방향과 크기로 오브젝트의 속도가 결정된다."
    },
    {
        "term": "Velocity",
        "description": "리지드바디의 현재 속도를 직접 설정하는 방법. 기존의 물리 기반 동작을 무시하고 특정 속도로 오브젝트를 즉시 이동시키는 데 사용된다."
    },
    {
        "term": "MovePosition",
        "description": "리지드바디 오브젝트의 위치를 직접 변경하는 함수로, 오브젝트가 주어진 목표 위치로 바로 이동하도록 지시한다. 물리 엔진의 영향을 받지 않는 이동 방식이다."
    },
    {
        "term": "FixedUpdate",
        "description": "Unity의 업데이트 함수 중 하나로, 물리 계산과 관련한 업데이트를 주기적으로 수행하는데 사용된다. 매 프레임이 아닌 일정한 시간 간격으로 호출된다."
    },
    {
        "term": "Normalize",
        "description": "벡터의 방향을 유지하면서 벡터의 크기를 1로 조정하는 과정. 이를 통해 이동 속도를 일관되게 조절할 수 있다."
    },
    {
        "term": "DeltaTime",
        "description": "마지막 프레임이 렌더링된 이후 경과한 시간을 나타내며, 이를 통해 시간이 경과하더라도 게임의 이동이 일관된 속도를 유지하도록 할 수 있다."
    },
    {
        "term": "Input System",
        "description": "유니티의 입력 시스템으로, 사용자 입력을 보다 직관적으로 관리하고 처리할 수 있도록 설계된 프레임워크이다. 새롭게 도입된 '뉴 인풋 시스템'은 멀티 플랫폼을 지원하고, 다양한 입력 장치(키보드, 게임 패드, 터치 등)를 통합하여 사용할 수 있는 기능을 제공한다."
    },
    {
        "term": "Action Mapping",
        "description": "인풋 시스템에서 특정한 액션(예: 이동, 점프 등)을 입력의 특정 그래픽이나 키와 연결하는 설정을 의미한다. 뱀서라이크 강좌에서는 'Move' 액션을 생성하여 이를 키보드와 게임 패드 입력에 매핑하는 방법을 다룬다."
    },
    {
        "term": "Input Action Profile",
        "description": "유니티의 인풋 시스템에서 정의된 일련의 입력 액션을 포함하는 설정 파일이다. 개발자는 이 프로필을 통해 다양한 입력 시나리오를 쉽게 구성하고 재사용할 수 있다."
    },
    {
        "term": "Using Directive",
        "description": "C#에서 특정 네임스페이스를 사용하는 선언문이다. 'using UnityEngine.InputSystem;'과 같은 형식으로 작성하여 해당 네임스페이스의 클래스와 메소드를 쉽게 사용할 수 있게 해준다."
    },
    {
        "term": "Normalized Value",
        "description": "입력값을 정규화하여 일정한 범위(일반적으로 -1.0에서 1.0)로 압축하는 과정을 말한다. 유니티의 인풋 시스템에서 이 정규화된 값은 플레이어의 더욱 유동적인 움직임을 가능하게 한다."
    },
    {
        "term": "Player Movement",
        "description": "게임에서 플레이어 캐릭터의 이동을 제어하는 시스템을 의미한다. 이번 강좌에서는 새로운 인풋 시스템을 통해 플레이어의 이동 로직을 구현하고 테스트하는 과정을 다룬다."
    },
    {
        "term": "2D 셀 애니메이션",
        "description": "2D 셀 애니메이션은 각각의 프레임이 개별적으로 그려진 스프라이트로 구성된 애니메이션 기법이다. 주로 게임과 영화에서 캐릭터의 움직임을 표현하며, 여러 개의 이미지 프레임을 순차적으로 재생하여 자연스러운 동작을 만들어낸다. 이 기술은 디지털 아트의 발전으로 더욱 다양한 표현을 가능하게 한다."
    },
    {
        "term": "애니메이터 컴포넌트",
        "description": "유니티의 애니메이터 컴포넌트는 캐릭터의 애니메이션 상태를 관리하는 데 사용되는 시스템으로, 애니메이션 파일 간의 전환을 조정할 수 있도록 돕는다. 이 컴포넌트를 통해 애니메이션 트리거 및 상태 머신을 구성하여 복잡한 애니메이션 논리를 구현할 수 있다."
    },
    {
        "term": "플립 X",
        "description": "플립 X는 스프라이트의 좌우 반전을 의미하며, 캐릭터가 방향을 바꿀 때 이미지의 시각적 표현을 조정하기 위해 사용된다. 이 기능은 이동 방향이 좌측(-1)일 때 활성화되어 캐릭터가 자연스럽게 보이는 효과를 만든다."
    },
    {
        "term": "애니메이션 상태 전환",
        "description": "애니메이션 상태 전환은 애니메이션 간의 변화를 관리하는 프로세스를 의미한다. 이 과정은 특정 조건이 충족될 때 애니메이션이 자연스럽게 바뀔 수 있도록 하며, 변수와 트리거를 사용하여 상황에 맞는 애니메이션을 지정한다."
    },
    {
        "term": "애니메이션 오버라이드 컨트롤러",
        "description": "애니메이션 오버라이드 컨트롤러는 기존 애니메이터의 설정을 변경하지 않고도 새로운 애니메이션을 적용할 수 있는 유용한 도구이다. 이를 통해 개발자는 동일한 애니메이션 구조를 가진 캐릭터에 대해 다양한 스프라이트를 적용하여 효율적으로 작업할 수 있다."
    },
    {
        "term": "코드 초기화",
        "description": "코드 초기화는 애니메이션이 시작되기 전에 필요한 변수와 상태를 설정하는 프로세스이다. 이는 애니메이터를 활성화하고 다양한 입력에 따라 애니메이션 상태가 변하는 데 필수적이다."
    },
    {
        "term": "무한 맵 이동",
        "description": "플레이어가 게임 공간에서 경계를 넘어갈 때, 지속적으로 새로운 지역이 생성되어 플레이어가 끝없이 탐험하는 느낌을 주는 기술. 이는 게임의 몰입도를 높여주고, 플레이어가 지루함을 느끼지 않도록 돕는다."
    },
    {
        "term": "타일맵",
        "description": "Unity에서 2D 게임 맵을 구성하기 위해 사용하는 시스템으로, 여러 개의 타일을 사용하여 지형이나 레벨을 정의한다. 이를 통해 개발자는 복잡한 지형을 효율적으로 디자인할 수 있고, 타일속성을 조정하여 다양한 맵을 생성할 수 있다."
    },
    {
        "term": "시네머신 패키지",
        "description": "Unity의 카메라 시스템을 확장시키는 툴로, 더 부드럽고 다이나믹한 카메라 움직임을 가능하게 한다. 가상 카메라를 설정함으로써 특정 오브젝트를 자연스럽게 따라가거나, 다양한 촬영 기법을 적용할 수 있게 한다."
    },
    {
        "term": "이벤트 시스템",
        "description": "Unity에서 특정 행동이나 상태 변화에 대한 반응을 작성하기 위한 시스템. 예를 들어, 플레이어가 특정 지역에 도달했을 때 새로운 타일맵을 생성하는 등의 로직을 구현할 때 활용된다."
    },
    {
        "term": "재배치 로직",
        "description": "플레이어가 경계를 넘어갈 때, 기존의 타일맵을 기반으로 새로운 타일맵을 생성하고 그 위치를 재조정하는 알고리즘. 이는 무한 맵 이동의 핵심 구성 요소로, 플레이어의 위치에 따라 타일의 배치 방향과 거리를 결정한다."
    },
    {
        "term": "물리 이동",
        "description": "Unity에서 오브젝트의 움직임을 자연스럽게 만들어주는 기술로, 물리 엔진을 활용하여 중력이나 저항을 적용할 수 있다. 이를 통해 캐릭터의 모션이 보다 현실감 있게 연출된다."
    },
    {
        "term": "Unity",
        "description": "Unity는 게임 개발 플랫폼으로, 2D 및 3D 게임을 제작하는 데 사용됩니다. 사용자 친화적인 인터페이스와 풍부한 기능 세트 및 커뮤니티 지원으로 인해 인기를 얻고 있습니다."
    },
    {
        "term": "몬스터 제작",
        "description": "게임에서 몬스터를 제작하는 것은 게임의 적 캐릭터를 만들고 이를 플레이어와 상호작용할 수 있는 형태로 구현하는 과정입니다. 이 과정은 오브젝트 형태, 애니메이션 설정, AI 로직 구현 등을 포함합니다."
    },
    {
        "term": "플레이어 추적 로직",
        "description": "게임 내에서 적 캐릭터가 플레이어를 인식하고 추적하는 알고리즘입니다. 벡터 계산을 통해 위치를 비교하고, 적 캐릭터가 플레이어의 위치로 이동하도록 설정할 수 있습니다."
    },
    {
        "term": "벡터 연산",
        "description": "벡터 연산은 방향과 크기를 가진 수학적 객체를 사용하는 계산을 의미합니다. 게임 개발에서는 물체의 위치, 방향 및 속도를 계산하는 데 필수적입니다."
    },
    {
        "term": "애니메이터",
        "description": "Unity의 애니메이션 시스템을 다루는 컴포넌트로, 캐릭터의 동작이나 상태 전환을 설정하고 관리하는 데 사용됩니다. 몬스터의 애니메이션은 세부적인 동작을 가능하게 합니다."
    },
    {
        "term": "콜라이더 2D",
        "description": "Unity에서 2D 물리학을 처리하는 데 사용되는 컴포넌트로, 오브젝트 간의 충돌을 감지하고 상호작용을 가능하게 합니다. 몬스터의 상태를 확인하는 데 중요한 역할을 합니다."
    },
    {
        "term": "리포지션 기능",
        "description": "몬스터가 특정 조건에 따라 무작위로 재배치되는 기능입니다. 이는 게임 내에서 적 캐릭터의 등장 방식을 다양화하여 플레이어에게 신선한 경험을 제공합니다."
    },
    {
        "term": "에너미 태그",
        "description": "Unity에서 특정 오브젝트를 식별하기 위해 설정하는 태그로, 적 캐릭터를 쉽게 관리할 수 있도록 도와줍니다. 이 태그를 통해 다른 게임 오브젝트와의 상호작용을 제어할 수 있습니다."
    },
    {
        "term": "물리적 상호작용",
        "description": "게임 내 오브젝트가 서로 영향을 주고받는 방식을 의미합니다. 물리 엔진의 적용을 통해 현실적인 충돌, 충격 및 운동 효과를 구현할 수 있습니다."
    },
    {
        "term": "속도 변수",
        "description": "몬스터의 이동 속도를 설정하기 위한 프로그래밍 변수입니다. 이를 통해 몬스터의 행동 양식을 조정할 수 있으며, 게임의 난이도를 조절할 수 있습니다."
    },
    {
        "term": "오브젝트 풀링 (Object Pooling)",
        "description": "오브젝트 풀링은 게임에서 생성과 소멸이 빈번히 발생하는 오브젝트를 재사용하기 위한 메모리 관리 기법입니다. 이를 통해 객체를 매번 생성하고 삭제하는 과정에서 생기는 메모리 할당과 해제를 줄이고, 성능을 최적화합니다. 특히 적 캐릭터와 같은 빈번히 소환되는 오브젝트에서 효과적입니다."
    },
    {
        "term": "프리팹 (Prefab)",
        "description": "프리팹은 유니티에서 자주 사용하는 템플릿으로, 특정 오브젝트의 형태, 컴포넌트, 설정 등을 사전 정의한 것입니다. 이를 통해 같은 유형의 오브젝트를 쉽게 복제하고 관리할 수 있어, 게임 개발 시 유용한 기능을 제공합니다."
    },
    {
        "term": "풀 매니저 (Pool Manager)",
        "description": "풀 매니저는 오브젝트 풀링 기법에서 오브젝트의 생명 주기를 관리하는 역할을 합니다. 생성된 오브젝트의 상태를 추적하고, 사용되지 않는 오브젝트를 다시 사용자에게 제공하는 시스템을 통해 메모리 자원을 효율적으로 사용합니다."
    },
    {
        "term": "인스턴스화 (Instantiation)",
        "description": "인스턴스화는 클래스를 기반으로 새로운 객체를 생성하는 과정을 의미합니다. 게임 개발에서는 새로운 오브젝트를 효율적으로 만들어내는 데 사용되며, 오브젝트 풀링에서는 기존 오브젝트를 재사용하기 위해 필요한 과정입니다."
    },
    {
        "term": "메모리 최적화 (Memory Optimization)",
        "description": "메모리 최적화는 프로그램이 실행되는 동안 메모리 사용을 최소화하여 성능을 개선하는 기술입니다. 오브젝트 풀링과 같은 기법을 통해 불필요한 메모리 할당을 줄이고, 성능 저하를 방지하는 것이 중요합니다."
    },
    {
        "term": "게임 성능 (Game Performance)",
        "description": "게임 성능은 게임 실행의 원활함을 나타내는 지표로, 프레임률, 로딩 시간, 반응 속도 등을 포함합니다. 오브젝트 풀링 같은 기술을 활용하여 적절한 메모리 관리를 통해 성능을 향상시키는 것이 중요합니다."
    },
    {
        "term": "오브젝트 풀링",
        "description": "오브젝트 풀링은 게임에서 객체를 반복적으로 생성하고 삭제하는 대신, 미리 생성한 객체를 재사용하여 성능을 최적화하는 기법입니다. 이는 메모리 할당을 줄이고 생성 시간 단축에 도움을 줍니다."
    },
    {
        "term": "소환 데이터 (SpawnData)",
        "description": "SpawnData 클래스는 몬스터의 속성을 정의하는 데이터 구조로, 타입, 소환 시간, 체력, 속도와 같은 다양한 속성을 포함하여 몬스터 생성에 필요한 정보를 저장합니다."
    },
    {
        "term": "직렬화 (Serialization)",
        "description": "직렬화는 데이터 구조를 저장하거나 전송하기 위해 변환하는 과정으로, 유니티에서는 인스펙터를 통해 쉽게 초기화할 수 있는 기능을 제공합니다. 이를 통해 게임 개발 시 객체의 상태를 쉽게 부여하고 관리할 수 있습니다."
    },
    {
        "term": "레벨 기반 난이도 조절",
        "description": "게임의 레벨이 증가함에 따라 플레이어에게 제공되는 난이도를 조절하는 방식으로, 이를 통해 플레이어의 경험치를 조절하고 도전 과제를 제공합니다. 이는 시간의 흐름과 함께 자동으로 조정되는 시스템으로 동작합니다."
    },
    {
        "term": "게임 매니저",
        "description": "게임 매니저는 게임의 전체 흐름을 관리하는 클래스 또는 스크립트로, 레벨, 점수, 게임 시간 등의 상태를 유지하며, 이러한 상태에 따라 게임의 다양한 요소를 통제하는 역할을 합니다."
    },
    {
        "term": "애니메이션 컨트롤러",
        "description": "애니메이션 컨트롤러는 유니티에서 캐릭터나 객체의 애니메이션을 관리하고 모니터링하는 도구로, 탄탄한 상태전환과 애니메이션 흐름을 유지하기 위한 필수 요소입니다."
    },
    {
        "term": "온이네이블 (OnEnable) 메서드",
        "description": "유니티에서 객체가 활성화될 때 자동으로 호출되는 메서드로, 객체의 초기화 작업이나 설정을 담당합니다. 해당 메서드를 사용하여 몬스터 속성 등의 초기화가 이루어집니다."
    },
    {
        "term": "생명력 (Health)",
        "description": "게임 캐릭터나 몬스터가 가질 수 있는 생명력 수치로, 이를 통해 해당 객체가 얼마만큼의 피해를 견딜 수 있는지를 결정하며, 측정 및 관리가 필요한 중요한 게임 요소입니다."
    },
    {
        "term": "프리펩 (Prefab)",
        "description": "유니티에서 프리펩은 게임 오브젝트의 재사용 가능한 인스턴스를 생성하는데 도움을 주는 기능입니다. 이를 통해 복잡한 게임 오브젝트를 손쉽게 관리하고, 에디터 및 스크립트에서 재사용하여 개발 효율성을 높일 수 있습니다."
    },
    {
        "term": "충돌 로직 (Collision Logic)",
        "description": "충돌 로직은 게임 오브젝트 간의 충돌 이벤트를 관리하는 스크립트입니다. 유니티에서는 OnCollisionEnter와 같은 메서드를 사용하여 특정 오브젝트와의 충돌을 탐지하고, 이에 대한 반응(예: 데미지를 주거나 사라지게 하는 등)을 정의할 수 있습니다."
    },
    {
        "term": "스무스한 애니메이션 (Smooth Animation)",
        "description": "스무스한 애니메이션은 캐릭터나 오브젝트가 움직일 때 부드럽게 보이도록 하는 기술입니다. 이를 위해 적절한 변수와 메서드를 활용하여 움직임의 속도나 각도를 조절하고, 애니메이션 간 전환을 매끄럽게 처리하는 것이 중요합니다."
    },
    {
        "term": "레벨 디자인 (Level Design)",
        "description": "레벨 디자인은 게임의 각 레벨이 어떻게 구성되고 진행되는지를 설계하는 과정입니다. 이는 플레이어의 경험을 극대화하고, 게임 내 도전 과제를 조정하는 중요한 요소로 작용합니다."
    },
    {
        "term": "게임 로직 (Game Logic)",
        "description": "게임 로직은 게임 내 상호작용이나 규칙을 정의하는 스크립트와 알고리즘을 의미합니다. 이는 플레이어의 행동에 따라 게임이 어떻게 반응하는지를 결정짓는 핵심 요소입니다."
    },
    {
        "term": "원거리 공격",
        "description": "게임에서 플레이어가 적에게 멀리서 공격할 수 있는 시스템을 의미하며, 기본적으로 총이나 사격물체를 사용하여 이루어진다. 유니티에서는 이를 스크립트를 통해 구현하고, 공격의 발사를 조작하기 위해 물리 기반의 레이캣과 총알 생성 기능을 활용한다."
    },
    {
        "term": "스캐너(Scanner)",
        "description": "게임 내에서 특정 오브젝트를 감지하기 위한 기능을 수행하는 스크립트로, 주로 적이나 플레이어를 탐지하는 데 사용된다. 레이캐스트를 통해 범위 내의 오브젝트를 탐색하고, 탐색 범위를 설정하기 위해 레이어와 마스크를 적용한다."
    },
    {
        "term": "레이어(Layer)",
        "description": "유니티에서 게임 오브젝트를 그룹화하여 물리적 상호작용을 제어할 수 있도록 하는 기능으로, 특정 오브젝트들이 서로 상호작용하지 않도록 독립적인 공간을 제공한다. 태그와는 별개로, 레이어는 물리 엔진의 충돌 감지와 관련된 설정에 주로 사용된다."
    },
    {
        "term": "프리펩(Prefab)",
        "description": "유니티에서 미리 설정된 게임 오브젝트의 템플릿으로, 게임을 실행하기 전에 재사용 가능하도록 저장된다. 이를 통해 같은 종류의 오브젝트를 여러 번 손쉽게 생성할 수 있으며, 수정 시 모든 인스턴스에 변화가 적용된다."
    },
    {
        "term": "서클 캐스트(Circle Cast)",
        "description": "주어진 반지름을 갖는 원형 범위 내에서 오브젝트를 감지하는 물리적인 테스트 메서드로, 주로 2D 게임에서 적이 플레이어에 접근하는 메커니즘을 구현할 때 사용된다."
    },
    {
        "term": "총탄(Bullet)",
        "description": "플레이어가 발사하는 공격의 형식으로, 각기 다른 속도와 크기를 가질 수 있으며, 이를 통해 적에게 피해를 줄 수 있다. 게임의 룰에 따라 다양한 종류의 총탄이 존재할 수 있다."
    },
    {
        "term": "Fixed Update",
        "description": "유니티의 업데이트 메서드 중 하나로, 물리 법칙과 관련된 계산이 일정한 간격으로 수행되도록 하기 위해 사용된다. 이 함수는 프레임 레이트와 관계 없이 일정 시간 간격으로 호출되며, 주로 물리적 상호작용 및 상태 업데이트에 적합하다."
    },
    {
        "term": "레이캐스트(Raycast)",
        "description": "지정된 방향으로 선을 쏘아 오브젝트의 충돌을 감지하는 유니티의 기능으로, 주로 시각적 감지, 공격 시스템 등에 활용된다. 2D와 3D 모두에서 사용할 수 있으며, 충돌을 통한 정보를 반환하여 게임 로직을 제어한다."
    },
    {
        "term": "피격 리액션",
        "description": "몬스터가 공격을 받을 때 반응하는 기능으로, 게임의 몰입도를 높이고 플레이어에게 공격의 효과를 명확하게 전달합니다. 피격 리액션은 시각적인 애니메이션 및 사운드 이펙트를 포함하여 몬스터의 상태를 변화시키는 중요한 요소입니다."
    },
    {
        "term": "사망 리액션",
        "description": "몬스터가 플레이어의 공격으로 사망했을 때 발생하는 리액션으로, 일반적으로 사망 애니메이션과 함께 몬스터의 충돌을 비활성화합니다. 이는 게임에서 몬스터의 생명 주기를 관리하는 중요한 메카닉 중 하나입니다."
    },
    {
        "term": "코루틴",
        "description": "Unity의 비동기 프로그래밍 개념으로, 여러 작업을 동시에 수행할 수 있게 해줍니다. 코루틴을 사용하면 특정한 타이밍에 코드 실행을 멈추고 다시 시작할 수 있어서, 시간 지연 효과나 애니메이션의 자연스러운 흐름을 유지하는 데 유용합니다."
    },
    {
        "term": "애니메이션 이벤트",
        "description": "Unity에서 애니메이션의 특정 프레임에 기능이 호출되도록 설정하는 기능입니다. 애니메이션의 동작과 게임 로직을 결합하여 보다 역동적이고 직관적인 게임 경험을 제공합니다."
    },
    {
        "term": "처치 데이터",
        "description": "몬스터가 처치될 때 발생하는 데이터를 기록하는 시스템으로, 플레이어의 진행 상황 분석 및 게임 밸런스를 조정하는 데 도움이 됩니다. 이를 통해 어떤 조건에서 몬스터가 처치되었는지가 기록되어 게임 디자인에 유용하게 활용될 수 있습니다."
    },
    {
        "term": "OnEnable 메서드",
        "description": "Unity의 라이프사이클 메서드 중 하나로, 게임 오브젝트가 활성화될 때 호출됩니다. 이 메서드를 통해 몬스터 상태를 초기화하거나 다시 설정하는데 사용됩니다."
    },
    {
        "term": "UI 캔버스",
        "description": "게임에서 UI 요소를 배치하기 위한 공간으로, 유니티에서는 'UI' 메뉴를 통해 추가할 수 있습니다. 캔버스는 스크린 스페이스 오버레이와 설정되어 메인 카메라와 연동하여 화면에 표시됩니다."
    },
    {
        "term": "스크립트",
        "description": "C#을 사용하여 UI 요소를 제어하는 스크립트를 생성합니다. 이 스크립트는 게임의 데이터(경험치, 레벨, 킬수 등)에 접근해 UI를 동적으로 업데이트하는 역할을 합니다."
    },
    {
        "term": "헤드업 디스플레이 (HUD)",
        "description": "플레이어에게 현재 정보(예: 경험치, 체력 등)를 제공하는 UI 요소로, 게임 내에서 중요한 데이터를 시각적으로 보여주는 역할을 합니다."
    },
    {
        "term": "슬라이더",
        "description": "경험치와 같은 값을 시각적으로 표현하기 위한 UI 요소로, 유니티에서 추가하여 변동 및 업데이트된 값을 사용자에게 전달하는 데 사용됩니다."
    },
    {
        "term": "LateUpdate 함수",
        "description": "유니티의 특정 업데이트 방법 중 하나로, 객체의 조작이 완료된 후 호출되어 UI 업데이트가 가능하게 합니다. 이를 사용하여 데이터가 변경될 때 유기적으로 UI를 갱신할 수 있습니다."
    },
    {
        "term": "텍스트 요소",
        "description": "게임 내에서 정보를 전달하기 위한 UI 구성 요소로, 유니티에서는 레거시 텍스트를 사용하여 추가할 수 있으며, 텍스트의 속성을 조정하여 가독성을 높입니다."
    },
    {
        "term": "Enum",
        "description": "게임에서 사용되는 특정 값들의 집합을 정의하는 데이터 타입으로, 스크립트에서 다양한 상태(경험치, 레벨 등)를 관리하는 데 유용합니다."
    },
    {
        "term": "인터랙티브 비활성화",
        "description": "슬라이더와 같은 UI 요소에서 사용자 상호작용을 차단하여 원하는 방식으로 정보만 표시되도록 설정하는 과정입니다. 경험치 게이지의 경우, 사용자가 직접 조작할 필요 없는 경우 비활성화합니다."
    },
    {
        "term": "능력 업그레이드",
        "description": "게임 내에서 플레이어의 능력치를 증가시키는 시스템으로, 플레이어가 스킬이나 아이템을 통해 성취감을 느끼게 하는 중요한 요소."
    },
    {
        "term": "스크립터블 오브젝트",
        "description": "유니티에서 데이터 관리를 용이하게 하기 위해 데이터만 담고 있는 오브젝트. 이를 통해 게임의 아이템, 캐릭터 능력 등을 쉽게 설정 및 수정할 수 있다."
    },
    {
        "term": "게임 오브젝트 생성",
        "description": "유니티에서 프로그램적으로 게임의 요소들(플레이어, 아이템, 적 등)을 동적으로 생성하는 기능으로, 게임의 다양성과 상호작용성을 증가시킨다."
    },
    {
        "term": "함수 브로드캐스팅",
        "description": "다수의 객체에서 특정 함수를 호출할 수 있도록 하는 방법으로, 이벤트 시스템에 매우 유용하며, 여러 게임 오브젝트 간의 상호작용에 사용된다."
    },
    {
        "term": "UI 구성",
        "description": "사용자 인터페이스를 설계하고 만드는 과정으로, 버튼, 텍스트, 이미지 등의 요소를 조합하여 플레이어의 게임 경험을 개선하는 데 필수적이다."
    },
    {
        "term": "무기 업그레이드 시스템",
        "description": "플레이어가 전투 도중 무기를 강화할 수 있는 시스템으로, 플레이어의 전투 스타일에 맞게 무기의 성능을 조정하고 커스터마이징할 수 있게 한다."
    },
    {
        "term": "장비 업그레이드",
        "description": "플레이어의 장비를 개선하여 능력치를 향상시키는 시스템으로, 무기와 방어구를 포함하여 플레이어의 전반적인 전투력을 증가시키는 역할을 한다."
    },
    {
        "term": "아이템 데이터 구조",
        "description": "게임 내의 각 아이템의 특징과 속성을 정의하는 데이터 형식. 아이템의 종류, 능력치, 사용 조건 등을 포함하여 플레이어가 아이템을 이해하고 활용하는 데 주요한 역할."
    },
    {
        "term": "데이터 연동",
        "description": "데이터 연동은 게임의 데이터와 인터페이스를 연결하는 과정을 의미하며, 이를 통해 사용자에게 동적인 피드백을 제공하고 게임플레이를 개선할 수 있습니다."
    },
    {
        "term": "반전 컨트롤",
        "description": "반전 컨트롤은 플레이어 캐릭터가 방향이 바뀔 때 손과 같은 다른 요소가 그에 맞게 반응하도록 설정하는 기술로, 캐릭터의 일관된 행동과 느낌을 통해 몰입감을 높입니다."
    },
    {
        "term": "Z축 조정",
        "description": "Z축 조정은 3D 공간에서 객체의 깊이 위치를 조정하는 것으로, 스프라이트가 서로 겹치지 않도록 층순서를 결정하여 시각적인 배치를 최적화하는 데 사용됩니다."
    },
    {
        "term": "상태 변화",
        "description": "상태 변화란 게임 내 캐릭터나 오브젝트가 특정 조건에 따라 속성이나 행동이 변경되는 것으로, 사용자 경험을 더욱 풍부하게 만들기 위한 주요 요소입니다."
    },
    {
        "term": "게임 개발",
        "description": "게임 개발은 게임을 설계, 개발 및 배포하는 과정으로, 프로그래밍, 그래픽 디자인, 프로젝트 관리 등 다양한 분야의 지식과 기술이 통합되어 이루어집니다."
    },
    {
        "term": "무기 장착",
        "description": "무기 장착은 플레이어 캐릭터가 특정 무기를 선택하여 장착하는 과정으로, 게임의 전투 시스템 및 캐릭터의 능력에 중요한 영향을 미칩니다."
    },
    {
        "term": "레벨업 시스템",
        "description": "레벨업 시스템은 게임의 진행 상태에 따라 플레이어 캐릭터의 능력치를 상승시키는 기능으로, 경험치 또는 특정 조건을 충족했을 때 활성화됩니다. 포괄적으로 RPG 및 액션 게임에서 자주 사용되며, 플레이어에게 새로운 능력이나 아이템 선택지를 제공하여 게임의 다양성과 재미를 증대시키는 역할을 합니다."
    },
    {
        "term": "UI (User Interface)",
        "description": "UI는 사용자가 소프트웨어와 상호작용하는 방식을 정의하는 시각적 요소들입니다. 게임에서 UI는 메뉴, 버튼, 텍스트 표시기 등을 포함하여 플레이어가 게임을 조작하고 정보를 얻는 수단을 제공합니다. 성공적인 UI 디자인은 사용자 경험을 향상시키며, 게임의 접근성과 몰입도를 높입니다."
    },
    {
        "term": "랜덤 아이템",
        "description": "랜덤 아이템은 특정 이벤트가 발생할 때마다 무작위로 생성되거나 선택되는 아이템을 의미합니다. 이는 플레이어에게 다양한 선택의 기회를 제공하고, 반복 플레이 시 지루함을 덜어주는 효과를 줍니다. 일반적으로 게임에서 임의의 요소를 추가하는 기법으로 활용되며 성취감과 재미를 향상시킵니다."
    },
    {
        "term": "타임 스케일",
        "description": "타임 스케일은 Unity에서 게임의 시간 흐름을 조절하는 데 사용되는 변수로, `Time.timeScale`을 통해 값이 조정됩니다. 이 값을 0으로 설정하면 게임이 일시 정지되고, 1로 설정하면 정상적인 속도로 진행됩니다. 이를 활용하여 게임 내 특정 순간에 플레이어의 선택을 더욱 강하게 느낄 수 있도록 합니다."
    },
    {
        "term": "Legacy Text",
        "description": "Legacy Text는 Unity의 사용자 인터페이스 시스템에서 오래된 텍스트 렌더링 방법을 나타냅니다. 현재 Unity UI 시스템에서는 TextMesh Pro와 같은 더 발전된 렌더링 기법이 사용되고 있으며, Legacy Text는 호환성 유지나 특정 기능을 위해 여전히 활용될 수 있습니다."
    },
    {
        "term": "아이템 배열",
        "description": "아이템 배열은 여러 개의 아이템을 저장하고 관리하는 데이터 구조입니다. 이 배열을 사용하면 아이템의 추가, 삭제 및 랜덤 선택이 용이합니다. 게임에서 아이템을 효율적으로 관리하기 위해 자주 사용되는 방식으로, 성능 최적화 및 코드의 가독성을 높이는 데 기여합니다."
    },
    {
        "term": "게임 시작 화면",
        "description": "게임 시작 화면은 플레이어가 게임을 시작하기 전에 보게 되는 초기 인터페이스로, 게임의 제목과 함께 시작 버튼을 포함합니다. 유니티의 캔버스를 활용하여 UI 요소를 배치하고 디자인하는 것이 중요합니다."
    },
    {
        "term": "UI 요소",
        "description": "UI(User Interface) 요소는 게임 내에서 사용자와 상호작용하는 모든 시각적 요소들을 포함합니다. 버튼, 이미지, 텍스트 등으로 구성되어 있으며, 게임의 흐름과 사용자의 경험을 증진시키는 역할을 합니다."
    },
    {
        "term": "게임 오버",
        "description": "게임 오버는 플레이어의 체력이 0 이하로 떨어지거나 게임에서 패배했을 때 나타나는 화면입니다. 이 화면은 플레이어에게 결과를 보여주고, 리트라이를 선택할 수 있는 옵션을 제공합니다."
    },
    {
        "term": "승리 화면",
        "description": "승리 화면은 플레이어가 게임의 목표를 달성했을 때 나타나는 인터페이스로, 승리 메시지와 함께 다음 행동을 선택할 수 있는 옵션을 제공합니다. 우승 조건을 정의하고, 승리 상황에 맞는 UI를 설정하는 것이 중요합니다."
    },
    {
        "term": "온 콜라이전 사건",
        "description": "온 콜라이전은 두 객체가 서로 충돌할 때 발생하는 이벤트입니다. 이 이벤트를 통해 게임 내에서 플레이어와 적 캐릭터와의 상호작용을 구현하고, 체력을 감소시키는 등의 게임 로직을 처리할 수 있습니다."
    },
    {
        "term": "버튼 클릭 이벤트",
        "description": "버튼 클릭 이벤트는 사용자가 버튼을 클릭했을 때 발생하는 행동을 정의하는 이벤트입니다. 이 기능을 통해 게임 시작, 리트라이 등 여러 동작을 수행할 수 있게 됩니다."
    },
    {
        "term": "캐릭터 선택 UI",
        "description": "게임에서 플레이어가 여러 캐릭터 중 하나를 선택할 수 있도록 하는 사용자 인터페이스 요소로, 플레이어의 경험을 풍부하게 만들어 줍니다. Unity에서는 Canvas와 RectTransform을 사용하여 버튼 및 이미지 스프라이트를 배치하고 조정하여 구현됩니다."
    },
    {
        "term": "객체지향 프로그래밍",
        "description": "프로그래밍 패러다임 중 하나로, 데이터(객체)와 그 데이터를 조작하는 방법(메서드)을 함께 묶어 관리하는 방식을 의미합니다. 클래스와 속성이 이 개념의 핵심이며, 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다."
    },
    {
        "term": "클래스 속성",
        "description": "객체지향 프로그래밍에서 클래스를 정의할 때 포함할 수 있는 상태(State)와 행동(Behavior)을 명세하는 역할을 하는 변수 및 메서드입니다. 속성은 객체의 특성을 정의하며, 서로 다른 객체 간의 차별점을 제공하는 중요한 요소입니다."
    },
    {
        "term": "Grid Layout",
        "description": "Unity의 UI 요소 중 하나로, 여러 UI 요소(예: 버튼)를 체계적으로 배치하기 위한 레이아웃 시스템입니다. 각 UI 요소는 정의된 셀 사이즈에 따라 자동으로 정렬되며, 간편한 배치 및 변화 관리가 가능합니다."
    },
    {
        "term": "온 클릭 이벤트",
        "description": "사용자가 UI 요소를 클릭했을 때 발생하는 이벤트로, 유저 인터페이스에서 상호작용 가능성을 제공합니다. Unity에서는 OnClick() 메서드를 통해 구현되며, 특정 로직(예: 캐릭터 ID 전달 등)을 트리거하는 데 사용됩니다."
    },
    {
        "term": "캐릭터 특성",
        "description": "게임 내 각 캐릭터가 가지는 고유한 능력이나 속성을 의미합니다. 이러한 특성은 게임 플레이의 다양성을 제공하며, 캐릭터 간의 전략적인 선택을 가능하게 합니다. 특성의 예로는 이동 속도, 공격력, 방어력 등이 있습니다."
    },
    {
        "term": "무기 지급 기능",
        "description": "선택된 캐릭터에 따라 자동으로 무기를 할당하는 시스템으로, 게임의 난이도와 전략성을 결정짓는 중요한 요소 중 하나입니다. 캐릭터 특성과 조화를 이루어 플레이어의 게임 경험을 극대화합니다."
    },
    {
        "term": "PlayerInfo 스크립트",
        "description": "Unity 스크립팅에서 플레이어의 정보를 관리하는 역할을 하는 스크립트입니다. 플레이어의 ID와 특성 등을 저장하고, 게임 도중 해당 정보를 갱신하고 사용하는 데 활용됩니다."
    },
    {
        "term": "캐릭터 해금 시스템",
        "description": "게임에서 특정 조건을 만족했을 때 새로운 캐릭터를 사용할 수 있도록 해주는 기능. 플레이어는 이 시스템을 통해 다양한 캐릭터를 해금하고, 게임의 지속성을 높이게 된다."
    },
    {
        "term": "업적 시스템",
        "description": "게임 내에서 특정 목표를 달성했을 때 보상을 주는 메커니즘. 플레이어는 이러한 업적을 통해 더 많은 경험을 얻고, 게임에 대한 흥미를 유지할 수 있다."
    },
    {
        "term": "스크립트 관리",
        "description": "유니티에서 캐릭터 해금 및 업적 달성 로직을 자바스크립트 또는 C#으로 작성하여 관리하는 과정. 스크립트를 통해 게임 내 이벤트와 상태를 제어할 수 있다."
    },
    {
        "term": "UI 상태 변화",
        "description": "플레이어가 특정 조건을 만족했을 때 UI 요소가 어떻게 변화할지를 설정하는 과정. 이는 사용자 경험을 향상시키고, 피드백을 통해 플레이어에게 더 나은 환경을 제공한다."
    },
    {
        "term": "버튼 추가 및 색상 설정",
        "description": "유니티의 UI 시스템을 활용하여 새로운 버튼을 추가하고, 각 버튼의 색상과 아이콘을 설정하는 과정. 버튼은 플레이어의 상호작용을 유도하는 주요 요소이다."
    },
    {
        "term": "데이터 저장",
        "description": "게임 진행 상황 및 플레이어의 해금 상태를 저장하여, 게임 종료 후에도 유지되는 시스템. 이를 통해 플레이어는 이전의 게임 상태를 이어서 계속할 수 있다."
    },
    {
        "term": "잠금 상태",
        "description": "특정 캐릭터가 사용 가능하기 위해 만족해야 하는 조건이 충족되지 않은 상태. 잠금 상태에 있는 캐릭터는 플레이어가 조건을 충족할 때까지 사용할 수 없다."
    },
    {
        "term": "유니티 오디오 시스템",
        "description": "유니티에서 제공하는 강력한 사운드 재생 및 관리를 위한 도구로, 게임 개발 시 사운드를 효과적으로 사용할 수 있도록 돕는 내용을 포함합니다. 오디오 소스, 오디오 클립, 믹서와 같은 다양한 요소를 통해 다양한 사운드 효과와 배경음을 쉽고 편리하게 관리할 수 있습니다."
    },
    {
        "term": "오디오 매니저",
        "description": "게임 내에서 배경음악과 효과음을 통합적으로 관리하는 객체로, 오디오 소스를 생성하고 필요한 설정을 통해 사운드의 품질과 재생 방식을 제어할 수 있습니다. 오디오 매니저는 여러 오디오 소스를 동시에 실행하고 관리하기 위한 필수적인 요소입니다."
    },
    {
        "term": "효과음",
        "description": "게임의 상황이나 동작에 맞춰 적절히 표현되는 소리로, 몰입감을 증가시켜 주는 중요한 요소입니다. 효과음의 품질과 재생 타이밍은 게임의 전반적인 플레이 경험에 큰 영향을 미칩니다."
    },
    {
        "term": "배경음악",
        "description": "게임 플레이 중 지속적으로 재생되는 음악으로, 게임의 분위기를 조성하고 특정 감정을 유도하는 데 도움을 줍니다. 배경음악의 반복 재생 설정 및 초기화 방법은 게임에서 일관된 사운드 경험을 보장하는 데 중요합니다."
    },
    {
        "term": "오디오 소스 설정",
        "description": "오디오 소스는 게임 오브젝트에 부착되어 사운드를 재생하는 기능을 담당하며, 다양한 프로퍼티를 통해 오디오의 볼륨, 피치, 스테레오 패닝 등을 조정할 수 있습니다. 효율적인 설정으로 여러 효과음을 동시에 재생할 수 있도록 할 수 있습니다."
    },
    {
        "term": "사운드 품질",
        "description": "사운드의 명료도와 현실감을 결정짓는 여러 요소로, 적절한 샘플링 레이트와 비트 깊이, 오디오 포맷의 선택 등이 포함됩니다. 게임 내에서 최적의 사운드 품질을 구현하기 위해서는 이러한 요소들을 세밀하게 조정해야 합니다."
    },
    {
        "term": "음향 문제 해결",
        "description": "게임 환경에서 발생할 수 있는 다양한 음향적인 문제를 사전에 예방하거나 해결하기 위한 기술과 절차들을 포함합니다. 효과음과 배경음악의 재생 오류, 볼륨 차이, 지연 등을 조정하여 사용자 경험을 개선하는 것을 목표로 합니다."
    },
    {
        "term": "오디오 클립",
        "description": "음악 파일 또는 효과음을 호출할 수 있는 최소 단위로, 오디오 소스에 연결하여 사용할 수 있도록 준비된 파일입니다. 게임 내에서 각기 다른 소리 효과를 만들기 위해 여러 클립들을 효과적으로 관리하는 것이 중요합니다."
    },
    {
        "term": "무한맵 재배치",
        "description": "무한맵은 플레이어가 움직일 때마다 맵이 플레이어의 앞쪽으로 자동으로 재배치되는 로직을 의미합니다. 이 로직의 개선은 플레이어의 인풋 벡터 대신 거리 계산을 사용하여 더 정확하게 구현됩니다."
    },
    {
        "term": "몬스터 재배치",
        "description": "몬스터의 행동 패턴을 변경하여 플레이어의 위치를 기준으로 움직이도록 개선합니다. 이를 통해 더욱 자연스럽고 도전적인 게임 플레이를 제공합니다."
    },
    {
        "term": "투사체",
        "description": "게임의 총알이나 발사체를 의미하며, 거리 및 데미지 계산에서 발생한 문제를 수정하여 게임의 밸런스를 향상시키는 데 중요한 역할을 합니다."
    },
    {
        "term": "관통력 설정",
        "description": "관통력은 무기가 적의 방어력을 뚫고 공격할 수 있는 능력을 말하며, 이 값의 조정은 공격의 치명도를 결정짓는 중요한 요소입니다."
    },
    {
        "term": "스폰 로직",
        "description": "게임 내 개체가 생성되는 방식을 규정하는 로직으로, 스폰 로직 개선을 통해 게임의 레벨 디자인과 난이도를 유연하게 조정할 수 있습니다."
    },
    {
        "term": "레벨 디자인",
        "description": "게임의 각 레벨을 어떻게 구성할지를 결정하는 프로세스로, 플레이어의 경험을 극대화하기 위해 체계적으로 설계되어야 합니다."
    },
    {
        "term": "입력 벡터",
        "description": "플레이어의 움직임을 계산하기 위한 수치로, 게임 내 행동을 커스터마이즈하고 제어하는 데 사용됩니다."
    },
    {
        "term": "랜덤 값 도입",
        "description": "몬스터의 이동 경로에 랜덤성을 추가해 더욱 현실감 있는 행동을 유도하며, 게임의 예측 가능성을 줄이는 요소로 작용합니다."
    },
    {
        "term": "모바일 빌드",
        "description": "모바일 빌드는 게임 개발 과정에서 PC 또는 콘솔 게임을 모바일 기기에서 실행할 수 있도록 변환하는 과정입니다. 유니티에서는 플랫폼에 맞는 설정을 통해 최적화를 수행하며, 모바일 환경에 적합한 UI 및 성능을 고려해야 합니다."
    },
    {
        "term": "조이스틱",
        "description": "조이스틱은 모바일 게임의 사용자 인터페이스에서 사용자의 입력을 받아들이기 위한 컨트롤 방법 중 하나입니다. 유니티에서는 인풋 시스템과 UI 요소를 활용하여 온스크린 조이스틱을 구현할 수 있습니다."
    },
    {
        "term": "게임 종료 버튼",
        "description": "게임 종료 버튼은 사용자가 게임을 종료할 수 있도록 하는 UI 요소입니다. 유니티에서는 UI 버튼을 통해 종료 기능을 설정하고, 클릭 이벤트를 통해 게임의 상태를 제어할 수 있습니다."
    },
    {
        "term": "렌더링 품질",
        "description": "렌더링 품질은 게임 그래픽의 성능을 결정짓는 요소로, 모바일 플랫폼에 적합한 수준으로 조정해야 합니다. 유니티는 프로젝트 설정을 통해 렌더링 품질을 최적화할 수 있는 기능을 제공하며, 이를 통해 게임의 부드러움과 시각적 효과를 동시에 향상시킬 수 있습니다."
    },
    {
        "term": "모바일 시뮬레이터",
        "description": "모바일 시뮬레이터는 유니티에서 제공하는 도구로, 개발자가 실제 모바일 기기에서 게임이 어떻게 보여지고 동작하는지를 미리 테스트할 수 있게 해 줍니다. 이 기능을 사용하면 화면 해상도와 UI 배치를 검토하여 최적화를 진행할 수 있습니다."
    },
    {
        "term": "포스트 프로세싱",
        "description": "포스트 프로세싱은 렌더링된 이미지에 후처리를 적용하여 시각적 품질을 향상시키는 기술입니다. 유니티에서는 포스트 프로세싱 스택을 통해 다양한 효과(예: 블룸, 색상 조정)를 추가할 수 있으며, 게임의 몰입감을 높이는 데 기여합니다."
    },
    {
        "term": "USB 설치",
        "description": "USB 설치는 빌드된 어플리케이션을 실제 모바일 기기로 전송하여 설치하는 과정을 의미합니다. 이를 통해 개발자는 자신의 앱을 피드백 받기 위해 직접 테스트할 수 있으며, 모바일 개발에서 중요한 단계입니다."
    },
    {
        "term": "온스크린 컨트롤",
        "description": "온스크린 컨트롤은 모바일 기기에서 화면 기반 입력을 지원하는 기능입니다. 이는 물리적인 컨트롤러 없이 사용자가 터치 스크린을 통해 게임을 조작할 수 있게 해주어, 터치 기반 인터페이스에서 사용자 경험을 향상시킵니다."
    },
    {
        "term": "타겟 프레임 수",
        "description": "타겟 프레임 수는 게임이 매초 몇 프레임으로 렌더링되어야 하는지를 나타냅니다. 이 설정은 게임의 부드러움과 성능을 직접적으로 영향을 미치며, 최적의 게임 경험을 보장하기 위해 적절히 조정해야 합니다."
    },
    {
        "term": "패키지 매니저",
        "description": "패키지 매니저는 유니티에서 다양한 라이브러리와 도구를 관리하고 설치하는 데 사용하는 시스템입니다. 이를 통해 개발자는 필요한 패키지를 쉽게 추가하고 관리할 수 있으며, 프로젝트의 기능을 확장하는 데 기여합니다."
    },
    {
        "term": "2D 종스크롤 슈팅 게임",
        "description": "2D 종스크롤 슈팅 게임은 화면을 수평으로 스크롤하며 플레이어가 적을 물리치는 목표로 하는 게임 장르를 의미합니다. 플레이어는 화면의 하단에서 상단으로 이동할 수 있으며, 다양한 장애물과 적들이 등장하여 도전합니다."
    },
    {
        "term": "플레이어 이동 구현",
        "description": "플레이어 이동 구현은 게임 내에서 사용자가 입력한 키보드 조작을 통해 캐릭터의 위치를 업데이트하는程序를 작성하는 과정입니다. C# 스크립트를 사용하여 입력을 감지하고 캐릭터의 위치를 조정하는 방법이 포함됩니다."
    },
    {
        "term": "경계 설정",
        "description": "경계 설정은 플레이어가 특정 영역 내에서만 이동할 수 있도록 제한하는 과정입니다. 이를 통해 플레이어가 화면 외부로 나가는 것을 방지하며, 박스 콜라이더와 같은 충돌 감지 기법이 사용됩니다."
    },
    {
        "term": "충돌 로직",
        "description": "충돌 로직은 충돌이 발생했을 때 어떻게 반응할지를 정의하는 프로그램입니다. 플레이어가 경계에 충돌했을 경우 이동을 멈추도록 하는 로직을 구현하는 것이 포함됩니다."
    },
    {
        "term": "박스 콜라이더",
        "description": "박스 콜라이더(Box Collider)는 3D 오브젝트의 충돌을 감지할 때 사용하는 물리 엔진의 구성 요소입니다. 사각형 영역을 설정하여 다른 오브젝트와의 충돌을 감지하고 반응하도록 돕습니다."
    },
    {
        "term": "총알 발사 로직",
        "description": "슈팅 게임에서 플레이어가 무기를 사용하여 적을 공격할 때 총알이 발사되는 과정을 제어하는 코드 로직으로, 게임의 핵심 요소 중 하나이다."
    },
    {
        "term": "프리팹",
        "description": "유니티에서 오브젝트를 재사용할 수 있도록 만들어진 템플릿으로, 총알 등의 오브젝트를 반복적으로 쉽게 생성할 수 있는 장점을 제공한다."
    },
    {
        "term": "콜라이더",
        "description": "게임 오브젝트 간의 충돌을 감지하기 위한 컴포넌트로, 총알이 다른 오브젝트와 충돌할 때의 반응을 설정할 수 있다."
    },
    {
        "term": "리기드바디",
        "description": "물리 엔진에서 오브젝트의 물리적 동작을 규정하는 컴포넌트로, 총알에 중력 및 힘을 적용하여 자연스러운 움직임을 구현할 수 있게 한다."
    },
    {
        "term": "AddForce 메소드",
        "description": "리기드바디에 힘을 추가하여 오브젝트를 움직이게 하는 유니티의 물리적 함수로, 총알 발사 시 속도와 방향을 설정하는 데 사용된다."
    },
    {
        "term": "onTriggerEnter 함수",
        "description": "총알이 콜라이더에 부딪혔을 때 특정 행동을 정의하는 유니티의 이벤트 함수로, 이를 통해 총알이 사라지거나 다른 오브젝트와 상호작용할 수 있다."
    },
    {
        "term": "인스턴스화",
        "description": "클래스를 기반으로 새로운 객체를 생성하는 과정으로, 유니티에서 프리팹을 사용하여 게임 오브젝트를 실시간으로 만들어내는 방법에 해당한다."
    },
    {
        "term": "입력 이벤트",
        "description": "사용자의 키 입력, 마우스 클릭 등과 같은 행동을 감지하여 게임 내에서 특정 행동을 수행하게 하는 시스템으로, 총알 발사를 제어하는 데 필수적이다."
    },
    {
        "term": "유니티(Unity)",
        "description": "유니티는 게임 개발을 위한 강력한 엔진으로, 2D 및 3D 게임을 제작할 수 있는 크로스 플랫폼 개발 툴입니다. 사용자가 다양한 플랫폼에 배포할 수 있도록 지원하며, 다양한 자원과 커뮤니티 자료가 풍부하여 초보자부터 전문가까지 폭넓게 사용됩니다."
    },
    {
        "term": "프리펩(Pre-Fab)",
        "description": "프리펩은 유니티에서 자주 사용하는 기능으로, 게임 오브젝트를 미리 설정해 놓은 템플릿입니다. 이는 같은 유형의 여러 게임 오브젝트를 간편하게 생성할 수 있도록 도와주며, 게임의 재사용성과 효율성을 높이는 데 중요한 역할을 합니다."
    },
    {
        "term": "스프라이트(Sprite)",
        "description": "스프라이트는 2D 비주얼 요소로, 애니메이션이나 게임의 비주얼링을 이루는 기본 구성요소입니다. 유니티에서는 스프라이트를 통해 캐릭터, 배경, 효과 등을 구현하고, 다양한 스프라이트를 관리할 수 있는 스프라이트 시트를 활용하여 공간과 자원을 효율적으로 사용할 수 있습니다."
    },
    {
        "term": "콜라이더(Collider)",
        "description": "콜라이더는 2D 또는 3D 물리 엔진에서 오브젝트 간의 충돌을 감지하는 데 사용되는 구성 요소입니다. 유니티에서는 박스 콜라이더, 원형 콜라이더 등 다양한 형태의 콜라이더를 제공하여, 물리적 상호작용을 자연스럽게 구현할 수 있도록 합니다."
    },
    {
        "term": "게임 매니저(Game Manager)",
        "description": "게임 매니저는 게임의 상태 및 흐름을 관리하는 스크립트나 오브젝트로, 게임 로직을 구현하는 데 필수적입니다. 이를 통해 게임의 초기화, 스코어 관리, 게임 오버 상태 관리 등과 같은 기능을 수행하여 게임 전반의 일관성을 유지합니다."
    },
    {
        "term": "픽셀 퍼 유닛(Pixels Per Unit)",
        "description": "픽셀 퍼 유닛은 유니티에서 스프라이트의 크기를 설정하는 데 사용되는 값으로, 스프라이트의 픽셀 수를 유니티의 월드 유닛에 맞게 변환합니다. 이 값에 따라 게임 내에서 스프라이트가 얼마만큼의 실제 공간을 차지하게 될지를 결정합니다."
    },
    {
        "term": "랜덤 소환(Random Spawn)",
        "description": "랜덤 소환은 게임 내 오브젝트를 무작위로 생성하는 기법으로, 게임의 다양성과 변화를 위한 중요한 요소입니다. 적 비행기의 출현 위치나 시점을 랜덤하게 설정하면 플레이어는 매번 새로운 경험을 느낄 수 있습니다."
    },
    {
        "term": "스프라이트 에디터(Sprite Editor)",
        "description": "스프라이트 에디터는 유니티에서 스프라이트를 생성하고 조정하는 도구로, 스프라이트 시트에서 개별 스프라이트를 추출하거나 크기 및 경계를 조정할 수 있는 편리한 기능을 제공합니다."
    },
    {
        "term": "인스턴스",
        "description": "인스턴스(Instance)란 프리팹의 복제본으로, 메모리 내에서 생성하여 사용하는 독립적인 객체를 의미한다. 각 인스턴스는 소스 프리팹으로부터 상속된 속성과 기능을 가지며, 별도의 속성 값을 가질 수 있다."
    },
    {
        "term": "스폰 포인트",
        "description": "스폰 포인트(Spawn Point)는 적이나 아이템이 게임 내에 생성(스폰)되는 특정한 좌표를 명시하는 지점이다. 이를 통해 적의 등장 위치를 제어하고 게임의 난이도를 조정할 수 있다."
    },
    {
        "term": "공격 로직",
        "description": "적의 공격 로직은 적이 플레이어를 향해 총알을 발사하는 동작을 정의하는 코드 구조이다. 적이 연속적으로 또는 조건에 따라 공격하도록 조정하여 게임의 동적인 요소를 강화한다."
    },
    {
        "term": "피격 이벤트",
        "description": "피격 이벤트(Hit Event)는 플레이어가 적의 공격을 맞았을 때 발생하는 함수를 의미한다. 이를 통해 플레이어의 상태 변경 및 효과(예: 사망, 애니메이션 재생)를 관리하여 상호작용을 표현한다."
    },
    {
        "term": "UI(사용자 인터페이스)",
        "description": "UI(User Interface)는 게임에서 사용자가 상호작용하는 모든 요소를 포함하는 디자인과 레이아웃을 의미한다. 효과적이고 직관적인 UI는 플레이어에게 중요한 정보를 제공하는 데 필수적이다."
    },
    {
        "term": "Canvas",
        "description": "유니티에서 UI를 배치하는 공간으로, 모든 UI 요소가 이 위에 위치합니다. 해상도에 따라 UI 요소를 조정하여 다양한 기기에서 일관된 표시를 제공할 수 있습니다."
    },
    {
        "term": "Anchor",
        "description": "UI 요소의 고정점을 설정하여 해상도나 화면 크기 변화에 비례하여 위치가 조정되도록 합니다. 이를 통해 다양한 화면 크기에서도 UI가 올바르게 배치됩니다."
    },
    {
        "term": "Public Variable",
        "description": "스크립트 내에서 다른 스크립트 접근을 위해 설정하는 변수로, 게임 내에서 상태나 정보를 공유하는 데 사용됩니다. 직관적인 이름을 설정하면 더욱 효과적입니다."
    },
    {
        "term": "Score Update Logic",
        "description": "게임 내에서 적을 처치했을 때 점수가 증가하도록 설정하는 로직입니다. 게임의 점수 시스템을 유지 관리하는 데 중요한 요소입니다."
    },
    {
        "term": "Game Over UI",
        "description": "플레이어의 라이프가 0이 되었을 때 표시되는 화면으로, 재시작 버튼 및 마지막 점수와 같은 정보를 포함합니다. 사용자에게 게임의 종료 상태를 알립니다."
    },
    {
        "term": "UI Manager",
        "description": "UI 요소들을 제어하고 업데이트하는 역할을 하는 스크립트로, 점수나 라이프 상태를 화면에 효과적으로 표시하는 데 필요한 기능을 집약합니다."
    },
    {
        "term": "Exception Handling",
        "description": "예상치 못한 상황에 발생하는 오류를 관리하는 코드로, 게임 플레이 중 안정성을 확보하기 위해 매우 중요합니다. 플레이어 경험을 향상시키는 방법이기도 합니다."
    },
    {
        "term": "아이템",
        "description": "게임 내에서 플레이어가 사용할 수 있는 추가적인 자원을 의미하며, 일반적으로 무기, 방어구, 회복 아이템 등 다양한 형태로 존재한다. 아이템은 게임의 전략성을 높이고 플레이어의 경험을 풍부하게 만드는 중요한 요소이다."
    },
    {
        "term": "필살기",
        "description": "플레이어가 특정 조건을 만족했을 때 사용할 수 있는 강력한 기술로, 대량의 피해를 입히거나 특정 상태를 일으키는 효과를 가진다. 필살기는 사용 시 자원 관리 및 쿨타임 시스템의 적용이 필요하다."
    },
    {
        "term": "아이템 드랍",
        "description": "적이 defeated 되었을 때 아이템을 생성하여 플레이어가 획득할 수 있도록 하는 로직으로, 드랍 확률 및 아이템 종류에 따라 다양한 전략적 요소를 제공한다. 이 시스템은 랜덤성을 활용하여 매 게임마다 새로운 경험을 선사한다."
    },
    {
        "term": "예외 처리",
        "description": "게임 설계의 안정성을 높이기 위한 기법으로, 예상치 못한 오류나 비정상적인 상황 발생 시 이를 적절히 처리하여 게임의 안전성과 사용자 경험을 향상시키는 데 필수적이다."
    },
    {
        "term": "쿨타임 시스템",
        "description": "필살기나 특정 아이템의 재사용 주기를 관리하는 시스템으로, 사용 이후 일정 시간 동안 다시 사용하지 못하도록 제한하여 게임의 밸런스를 유지하는 역할을 한다."
    },
    {
        "term": "랜덤화",
        "description": "게임 내 변수나 이벤트를 무작위로 발생시키는 기법으로, 플레이어의 경험을 다채롭게 하고 반복 플레이에 대한 흥미를 유지하기 위해 널리 사용된다."
    },
    {
        "term": "스크롤링",
        "description": "스크롤링은 영상이나 게임 화면이 일정 방향으로 지속해서 이동하는 효과로, 2D 게임에서 자주 사용됩니다. 주로 배경을 움직여 플레이어가 길게 이어지는 공간을 탐험하는 듯한 인상을 주기 위해 사용됩니다."
    },
    {
        "term": "패럴랙스",
        "description": "패럴랙스는 시각적 깊이감을 구현하기 위해 가까운 배경이 멀리 있는 배경보다 빠르게 움직이는 기법입니다. 이 기술은 사용자가 화면을 스크롤할 때 서로 다른 속도로 배경을 움직여 사실적인 3D 효과를 제공합니다."
    },
    {
        "term": "무한 배경",
        "description": "무한 배경은 사용자가 화면을 이동할 때 배경 이미지가 끊임없이 반복되어 나타나는 방식입니다. 이는 배경이 끝나는 것이라는 인상을 주지 않고 연속적인 탐험을 가능하게 하는 기법입니다."
    },
    {
        "term": "오더 인 레이어",
        "description": "Unity에서 '오더 인 레이어'는 스프라이트나 오브젝트의 렌더링 순서를 결정하는 요소입니다. 값이 낮을수록 배경에, 값이 높을수록 전경에 위치하도록 설정할 수 있습니다."
    },
    {
        "term": "Y축 스크롤링",
        "description": "Y축 스크롤링은 2D 공간에서 수직 방향으로 배경이나 오브젝트를 이동시키는 기술을 말합니다. 이를 통해 배경이 플레이어에게 더 자연스럽게 나타나도록 합니다."
    },
    {
        "term": "카메라 영역",
        "description": "카메라 영역은 2D 게임에서 플레이어가 볼 수 있는 공간을 정의하며, 이 영역을 벗어나는 오브젝트나 배경은 메모리에서 관리할 필요가 있어 주의가 요구됩니다."
    },
    {
        "term": "속도 조절",
        "description": "속도 조절은 배경이나 오브젝트의 이동 속도를 조정하는 과정으로, 패럴랙스 효과를 극대화하기 위해 각 배경의 속도를 다르게 설정하는 것이 중요합니다."
    },
    {
        "term": "가비지 컬렉션",
        "description": "가비지 컬렉션(Garbage Collection)은 프로그래밍 언어에서 동적으로 할당된 메모리에서 더 이상 참조되지 않는 객체를 자동으로 회수하여 메모리 사용을 최적화하는 과정이다. 오브젝트 풀링은 가비지 컬렉터의 호출 빈도를 줄여 성능 저하를 방지하는 데 도움을 준다."
    },
    {
        "term": "오브젝트 매니저",
        "description": "오브젝트 매니저(Object Manager)는 게임에서 오브젝트 풀링을 수행할 때 사용되는 클래스 구조로, 풀에 저장된 오브젝트의 생성, 활성화 및 비활성화를 관리한다. 이를 통해 개발자는 오브젝트의 상태를 효율적으로 관리하고 성능 최적화를 도모할 수 있다."
    },
    {
        "term": "매모리 관리",
        "description": "매모리 관리(Memory Management)는 프로그램이 사용하는 메모리를 효율적으로 사용하고 관리하는 방법을 의미한다. 오브젝트 풀링은 이러한 메모리 관리 기술 중 하나로, 필요할 때 이미 생성된 오브젝트를 재활용함으로써 메모리 소모를 줄이고 성능을 향상시킨다."
    },
    {
        "term": "구조체",
        "description": "구조체(Structure)는 C#에서 여러 관련 변수들을 하나의 단위로 묶어 관리할 수 있는 데이터 타입입니다. 본 강좌에서는 적 비행기를 소환하기 위한 정보를 담기 위해 구조체를 사용하여 소환 시간, 비행기 타입, 소환 위치와 같은 요소들을 효율적으로 관리합니다."
    },
    {
        "term": "텍스트 파일",
        "description": "텍스트 파일은 사람이 읽을 수 있는 형태로 데이터를 저장할 수 있는 파일 포맷입니다. 이 강좌에서는 적 비행기 소환 정보를 텍스트 파일 형식으로 작성하고, 이를 프로그램에서 읽어오는 방법을 다룹니다. 텍스트 파일의 정확한 형식이 읽기와 처리에 매우 중요합니다."
    },
    {
        "term": "System.IO",
        "description": "System.IO는 C#의 네임스페이스 중 하나로, 파일과 데이터 스트림을 처리하기 위한 다양한 클래스와 메서드를 제공합니다. 본 강좌에서는 적 비행기 소환 정보를 담고 있는 텍스트 파일을 읽기 위해 System.IO 네임스페이스의 기능을 활용합니다."
    },
    {
        "term": "리소스 폴더",
        "description": "Unity 프로젝트에서 리소스 폴더는 런타임 동안 접근할 수 있는 특정 파일들을 저장하는 폴더입니다. 텍스트 파일과 같은 데이터를 적절히 관리하기 위해 리소스 폴더에 파일을 추가하고, 이를 통해 비행기 소환 정보를 파일에서 읽어올 수 있습니다."
    },
    {
        "term": "스폰 딜레이",
        "description": "스폰 딜레이(Spawn Delay)는 적 비행기가 일정 시간 간격으로 소환되도록 설정하는 기능입니다. 본 강좌에서는 이 개념을 통해 적 비행기를 효율적으로 배치하고 플레이어에게 더 도전적인 게임 환경을 제공하는 방식을 소개합니다."
    },
    {
        "term": "인덱스",
        "description": "인덱스(Index)는 배열이나 리스트에서 특정 요소의 위치를 관리하기 위해 사용하는 값입니다. 본 강좌에서 적 비행기를 소환하는 과정에서 인덱스를 관리하여 적절한 비행기 타입과 소환 위치를 결정하는데 중요한 역할을 합니다."
    },
    {
        "term": "코드 테스트 및 디버깅",
        "description": "코드 테스트 및 디버깅은 프로그래밍 과정에서 발생할 수 있는 오류를 찾아 수정하는 과정입니다. 본 강좌에서는 코드 구현 후 발생할 수 있는 예기치 않은 오류를 점검하고, 이를 수정하기 위한 팁을 제공하여 초보자가 문제를 해결하는 방법을 학습할 수 있게 돕습니다."
    },
    {
        "term": "2D 종스크롤 슈팅게임",
        "description": "2D 종스크롤 슈팅게임은 화면의 스크롤링이 수평 방향으로 이루어지는 비디오 게임 장르로, 플레이어가 적을 공격하고 장애물을 피하며 진행하는 방식의 게임이다."
    },
    {
        "term": "보조무기",
        "description": "플레이어 캐릭터를 지원하는 형태의 무기로, 일반적으로 자동으로 적을 공격하며 플레이어의 전투력을 증가시키는 역할을 한다."
    },
    {
        "term": "팔로우 로직",
        "description": "게임에서 특정 개체가 다른 개체를 따라가는 행동을 구현하는 알고리즘을 의미하며, 위치 업데이트 및 거리 조정을 통해 자연스러운 이동을 구현한다."
    },
    {
        "term": "스프라이트 시트",
        "description": "여러 개의 2D 이미지를 하나의 큰 이미지 파일로 결합하여 사용하는 기법으로, 게임 개발 시 메모리 효율성을 높이고 로딩 시간을 줄이기 위해 사용된다."
    },
    {
        "term": "발사 간격",
        "description": "총알이나 공격이 발사될 때의 시간 간격을 설정하는 값으로, 게임의 난이도와 플레이어의 전투 스타일에 영향을 미치는 중요한 요소이다."
    },
    {
        "term": "파워 증가",
        "description": "플레이어 캐릭터의 능력이 강화될 때 보조무기의 수나 성능도 함께 증가하도록 설정하는 기능으로, 게임의 진행성과 플레이어의 성취감을 높인다."
    },
    {
        "term": "보스 구현",
        "description": "보스 구현은 게임 내에서 특별한 적 캐릭터인 보스를 제작하는 과정으로, 일반적으로 중대한 도전 과제를 제공하며, 다양한 공격 패턴과 행동을 통해 플레이어에게 도전을 줍니다."
    },
    {
        "term": "주요 로직",
        "description": "게임 로직은 게임의 행동과 작동을 정의하는 모든 규칙과 조건을 포함하는 개념으로, 보스의 행동, 발사 패턴, 대미지 처리 등을 제어하는 중요한 요소입니다."
    },
    {
        "term": "패턴 구현",
        "description": "패턴 구현은 보스나 적의 공격 방식과 행동을 미리 정의된 규칙에 따라 설정하는 기술로, 특정 조건 하에 다양한 행동을 보이게 하는 과정입니다. 이를 통해 플레이어에게 예측 가능한 공격을 제공하면서 동시에 흥미로운 상황을 만들어 냅니다."
    },
    {
        "term": "스프라이트 애니메이션",
        "description": "스프라이트 애니메이션은 2D 그래픽에서 캐릭터나 오브젝트의 움직임을 표현하는 기법으로, 여러 스프라이트 이미지를 연속적으로 표시하여 생동감 있는 동작을 만들어냅니다."
    },
    {
        "term": "프리펩",
        "description": "프리펩(Prefab)은 Unity에서 자주 사용하는 객체의 템플릿 개념으로, 복잡한 오브젝트를 한 번 만들어 두고 여러 군데에서 재사용할 수 있도록 저장하는 방법입니다."
    },
    {
        "term": "종스크롤 슈팅게임",
        "description": "종스크롤 슈팅게임은 플레이어가 화면을 스크롤하면서 적을 파괴하고 목표를 달성하는 방식의 2D 게임 장르로, 주로 상단에서 하단으로 스크롤되는 형태를 가집니다. 이 장르는 진행 중에도 지속적으로 적과 장애물의 패턴 및 공격이 등장하여 플레이어의 반응 속도와 집중력을 요구합니다."
    },
    {
        "term": "무적 타임",
        "description": "무적 타임은 게임에서 플레이어가 적의 공격을 받을 때 일시적으로 피해를 입지 않는 시간을 의미합니다. 이 기능은 주로 플레이어가 다시 태어났거나 특별한 상황에서 안전하게 플레이를 지속할 수 있도록 도와줍니다."
    },
    {
        "term": "폭발 효과",
        "description": "폭발 효과는 게임에서 적이나 오브젝트가 파괴될 때 나타나는 시각적 효과로, 플레이어의 몰입도를 높이기 위해 사용됩니다. 이 효과는 스프라이트 이미지와 애니메이션을 활용해 구현하며, 상황에 맞는 사운드 효과와 함께 사용되기도 합니다."
    },
    {
        "term": "모바일 UI",
        "description": "모바일 UI는 스마트폰이나 태블릿 등 모바일 기기에서 사용되는 사용자 인터페이스로, 터치 스크린을 고려한 버튼 배치와 손쉬운 네비게이션이 중요합니다. 효과적인 모바일 UI 설계를 위해서는 화면 크기와 사용자 경험을 고려한 시각적 요소가 필수적입니다."
    },
    {
        "term": "스테이지 관리 시스템",
        "description": "스테이지 관리 시스템은 다양한 게임 레벨이나 스테이지 간의 전환과 적 출현 패턴을 조절하는 스크립트를 포함합니다. 이를 통해 게임의 난이도를 조절하고, 플레이어의 게임 경험을 매끄럽게 유지할 수 있습니다."
    },
    {
        "term": "안드로이드 빌드",
        "description": "안드로이드 빌드는 Unity와 같은 게임 엔진에서  모바일 게임을 Android 운영 체제에서 실행할 수 있도록 설정하고 패키징하는 과정을 뜻합니다. 이 과정에는 Android SDK와 JDK와 같은 개발 도구의 설치와 Unity 내의 플랫폼 설정 변경이 포함됩니다."
    },
    {
        "term": "탑다운 RPG",
        "description": "탑다운 RPG는 게임의 시점이 위에서 아래로 설정되어 플레이어가 캐릭터를 조작하는 스타일의 롤플레잉 게임이다. 이 유니티 강좌에서는 이러한 게임을 제작하는 과정에 중점을 두고 있다."
    },
    {
        "term": "롤 타일",
        "description": "롤 타일은 타일 기반 게임에서 사용되는 스프라이트의 종류로, 규칙 기반의 타일 제작을 가능하게 하여 다양한 환경을 쉽게 구현할 수 있게 해준다."
    },
    {
        "term": "애니메이션 타일",
        "description": "애니메이션 타일은 여러 프레임으로 구성된 타일로, 이들을 통해 타일맵 내에서 움직임이나 동적인 요소를 구현할 수 있다."
    },
    {
        "term": "픽셀 퍼펙트",
        "description": "픽셀 퍼펙트는 픽셀 아트 스타일의 게임에서 영상 품질을 향상시키기 위한 설정으로, 스프라이트가 화면에서 정확히 한 픽셀 단위로 표시되도록 관리하여 아트워크의 선명도를 높인다."
    },
    {
        "term": "2D-Extra",
        "description": "2D-Extra는 유니티 프로젝트에서 사용할 수 있는 추가 기능과 자산을 제공하는 플러그인으로, 주로 2D 게임 개발에 필요한 도구를 포함하고 있다."
    },
    {
        "term": "쯔꾸르식 이동",
        "description": "쯔꾸르식 이동은 일본의 RPG 제작 도구인 'RPG Tsukūru'에서 유래된 용어로, 십자 모양의 방향키 입력을 통해 상하좌우로 이동하는 방식입니다. 이 방식은 플레이어가 오로지 8 방향으로만 이동할 수 있도록 제한하며, 특히 복고풍 RPG 게임에서 많이 사용됩니다."
    },
    {
        "term": "애니메이션 설정",
        "description": "게임 개발에서 애니메이션 설정은 캐릭터의 이동과 행동에 생명을 불어넣는 중요한 과정입니다. 이를 통해 플레이어의 움직임에 맞춰 걷기, 뛰기, 정지하기와 같은 다양한 상태에 대한 애니메이션을 구현하여 플레이어의 몰입감을 높입니다."
    },
    {
        "term": "조사 액션",
        "description": "조사 액션은 플레이어가 게임 세계 내의 오브젝트와 상호 작용하는 기능을 말합니다. 이 기능은 특정 오브젝트에 접근하여 정보를 얻거나, 숨겨진 요소를 발견하는 등의 행동을 가능하게 합니다. 일반적으로 UI 피드백을 통해 플레이어에게 조사 결과를 시각적으로 확인시켜줍니다."
    },
    {
        "term": "UI 피드백",
        "description": "UI 피드백은 사용자의 행동에 따른 시각적, 청각적, 촉각적 반응을 제공하는 방식입니다. 게임에서는 플레이어의 행동에 대해 적절한 반응을 통해 게임의 몰입도를 높이고, 사용자가 게임 내 액션에 대한 결과를 이해할 수 있도록 돕습니다."
    },
    {
        "term": "프레임 애니메이션",
        "description": "프레임 애니메이션은 여러 개의 정적 이미지를 연속으로 재생하여 움직임을 표현하는 기법입니다. 이 방식은 주로 2D 게임에서 사용되며, 프레임 수에 따라 부드러움과 자연스러움이 달라집니다."
    },
    {
        "term": "대화창 UI",
        "description": "RPG 게임에서 캐릭터 간의 대화를 시각적으로 표현해주는 요소로, 대사를 표시하고 사용자와 상호작용할 수 있는 중요한 인터페이스입니다."
    },
    {
        "term": "슬라이스드 이미지",
        "description": "UI 패널 등의 이미지를 크기 조정 시 비율이 깨지지 않도록 설정하는 방법으로, 이미지의 모서리를 정의하여 유연한 크기 조정이 가능하게 합니다."
    },
    {
        "term": "상태 전환",
        "description": "게임 내에서 캐릭터나 UI의 상태를 변경하는 기능으로, 대화창의 활성화와 비활성화를 포함한 다양한 사용자 경험을 제공합니다."
    },
    {
        "term": "UI 애니메이션",
        "description": "사용자 인터페이스의 요소들이 동적으로 변화하는 것을 구현하기 위해 사용되는 기법으로, 대화창의 부드러운 전환 효과를 제공하여 사용자 상호작용을 향상시킵니다."
    },
    {
        "term": "여백 조정",
        "description": "UI 요소의 배치와 시각적 일관성을 위해 사용되는 기법으로, UI 패널과 주변 요소 간의 공간을 조절하여 가독성을 높입니다."
    },
    {
        "term": "대화 시스템",
        "description": "2D RPG 게임 내에서 NPC와 플레이어 간의 상호작용을 관리하는 시스템으로, 대화 내용을 체계적으로 관리하기 위해 스크립트와 데이터 구조를 활용한다. 객체의 종류(NPC, 일반 사물)에 따라 다르게 처리하며, 대화 내용은 매니저 스크립트를 통해 관리된다."
    },
    {
        "term": "NPC (Non-Player Character)",
        "description": "플레이어가 조종하지 않는 캐릭터로, 게임 내에서 대화 및 상호작용의 주요 대상이다. 각 NPC는 고유한 아이디가 부여되며, 게임의 스토리와 진행에 중요한 역할을 한다."
    },
    {
        "term": "딕셔너리",
        "description": "키-값 쌍으로 데이터 저장하는 데이터 구조로, 대화 시스템에서 NPC와 대화 내용을 효과적으로 관리하기 위해 사용된다. 이를 통해 대화 항목을 쉽게 조회하고 수정할 수 있다."
    },
    {
        "term": "오브젝트 관리",
        "description": "게임 내 존재하는 모든 오브젝트를 효과적으로 다루기 위한 기법으로, 각 오브젝트에 대해 고유 아이디를 부여하고, 종류에 따라 적절한 처리를 수행하는 방식이다."
    },
    {
        "term": "초상화",
        "description": "대화 중 NPC의 감정이나 반응을 시각적으로 표현하기 위한 이미지로, 각 NPC의 상태에 따라 다른 스프라이트가 활용된다. 이는 몰입감을 높이고, 게임 플레이어에게 시각적 정보를 제공하는 중요한 요소이다."
    },
    {
        "term": "스프라이트 시스템",
        "description": "게임 내에서 2D 이미지를 표현하기 위한 시스템으로, NPC의 감정 표현과 같은 다양한 그래픽 요소를 활용하는 데 사용된다. 각 상태에 따라 변화하는 스프라이트를 통해 NPC의 감정 상태를 플레이어에게 전달한다."
    },
    {
        "term": "퀘스트 시스템",
        "description": "게임 내에서 플레이어가 특정 목표를 수행하기 위해 수집하는 정보와 채팅 상호작용을 결합한 시스템. NPC와의 대화와 오브젝트 상호작용을 통해 사용자에게 다양한 퀘스트를 제공하며, 게임의 흐름과 목표 달성을 위한 중심적인 요소."
    },
    {
        "term": "NPC (Non-Playable Character)",
        "description": "게임 내에서 플레이어가 직접 조종할 수 없는 캐릭터. 주로 퀘스트를 제공하거나 정보를 전달하는 역할을 하며, 스토리 전개에 중요한 영향을 미친다."
    },
    {
        "term": "ID 넘버링",
        "description": "퀘스트 및 NPC를 구분하는 고유 식별자. 게임의 규모에 따라 다양한 범위로 설정할 수 있으며, 이는 데이터 관리를 효율적으로 하기 위한 중요한 요소이다."
    },
    {
        "term": "퀘스트 매니저",
        "description": "퀘스트의 생성, 저장, 관리 및 진행 상태를 추적하는 스크립트. 퀘스트 데이터를 체계적으로 관리하여 게임 내에서 퀘스트가 원활하게 작동하도록 돕는다."
    },
    {
        "term": "모노 비헤이비어",
        "description": "Unity에서 스크립트를 컴포넌트 형태로 구성하는 클래스의 기본 형태. 게임 오브젝트에 기능을 추가하기 위해 사용되며, 스크립트에서 상태를 관리하는 데 유용하다."
    },
    {
        "term": "Awake 메서드",
        "description": "Unity에서 게임 오브젝트가 처음 생성될 때 호출되는 특별한 메서드로, 초기화 작업이나 데이터 세팅에 주로 사용된다."
    },
    {
        "term": "GenerateData 함수",
        "description": "퀘스트 데이터를 생성하는 사용자 정의 함수로, 이 함수를 통해 퀘스트의 ID 및 관련 정보를 초기화한다."
    },
    {
        "term": "퀘스트 진행 관리",
        "description": "플레이어가 퀘스트를 진행할 때 이전 대화의 순서와 다음 대화를 조정하여 퀘스트의 흐름을 원활하게 유지하는 프로세스."
    },
    {
        "term": "예외처리",
        "description": "프로그램이 예상치 못한 상황에 맞닥뜨렸을 때의 처리 로직으로, 사용자 경험을 높이고 오류 발생 시 시스템이 안정적으로 동작할 수 있도록 도와준다."
    },
    {
        "term": "애니메이션 이펙트",
        "description": "게임 요소의 시각적 표현을 향상시키기 위해 사용되는 다양한 애니메이션 효과입니다. 이러한 이펙트를 통해 사용자 경험을 더욱 몰입감 있게 제공할 수 있습니다."
    },
    {
        "term": "대화창 이펙트",
        "description": "플레이어가 대화를 볼 수 있는 UI 요소로서, 애니메이션 효과를 추가하여 사용자가 대화 상태를 직관적으로 이해할 수 있도록 돕습니다. 다양한 애니메이션은 대화의 분위기를 강조하거나 강조하고자 하는 내용을 시각적으로 표현할 수 있습니다."
    },
    {
        "term": "초상화 이펙트",
        "description": "대화 중 등장하는 캐릭터의 얼굴 이미지에 생명력을 불어넣기 위해 적용되는 애니메이션입니다. 초상화의 표정 변화와 위치 이동이 포함되어 사용자는 캐릭터의 감정 변화를 더 잘 이해할 수 있습니다."
    },
    {
        "term": "타이핑 이펙트",
        "description": "대화 내용이 자동으로 출력되는 방식으로, 실제로 누군가가 입력하는 듯한 느낌을 제공하는 애니메이션 효과입니다. 이러한 효과는 사용자에게 긴장감을 주거나 정보를 점진적으로 전달하는 데 유용합니다."
    },
    {
        "term": "Invoke 메서드",
        "description": "Unity의 C# 프로그래밍에서 메서드를 일정 시간 후에 호출하기 위해 사용되는 기능입니다. 타이핑 이펙트 구현 시, 각 글자를 시간 간격을 두고 화면에 출력하기 위해 활용됩니다."
    },
    {
        "term": "서브메뉴",
        "description": "게임에서 사용자 인터페이스(UI)에서 추가적인 옵션 또는 기능을 제공하는 메뉴. 주로 게임 진행 중 일시 정지 상태에서 접근할 수 있으며, 플레이어는 이 메뉴를 통해 설정 조정, 저장 및 종료 등의 기능을 이용할 수 있다."
    },
    {
        "term": "PlayerPrefs",
        "description": "Unity에서 게임 데이터를 간편하게 저장하고 불러오는 기능. 주로 사용자 설정, 게임 진행 상황 등을 저장하는 데 사용된다. 로컬 저장소에 데이터를 저장하며, 간단한 키-값 쌍의 형태로 정보를 처리할 수 있다."
    },
    {
        "term": "UI (사용자 인터페이스)",
        "description": "사용자와 게임 간의 상호작용을 가능하게 하는 시각적 요소들로 구성된 환경. 버튼, 패널, 텍스트 등 다양한 구성 요소를 포함하며, 플레이어가 쉽게 게임을 이해하고 조작할 수 있도록 돕는다."
    },
    {
        "term": "UX (사용자 경험)",
        "description": "사용자가 게임을 이용하는 과정에서 느끼는 전체적인 경험. 마케팅뿐 아니라 설계와 기술적 요소를 포함하여 사용자가 게임과 상호작용하는 방식을 최적화하는 중요한 요소이다."
    },
    {
        "term": "게임 종료 로직",
        "description": "게임 플레이 중 사용자가 종료 버튼을 클릭했을 때 게임을 안전하게 종료하는 절차. 보통 사용자가 의도치 않게 종료하지 않도록 확인 메시지를 표시하는 방법이 포함된다."
    },
    {
        "term": "버튼 기능 설정",
        "description": "UI에서 버튼을 클릭했을 때 발생하는 동작을 정의하는 과정으로, 이벤트 리스너를 통해 특정 스크립트를 실행하여 원하는 기능을 활성화한다."
    },
    {
        "term": "레지스트리 편집기",
        "description": "Windows 운영체제에서 시스템 설정 및 애플리케이션 관련 정보를 저장하는 위치인 레지스트리를 수정하기 위한 도구. regedit 명령을 통해 실행된다."
    },
    {
        "term": "투명도 조정",
        "description": "UI 요소의 시각적 효과를 조절하여 시각적 차별을 두는 기술. 일반적으로 배경을 어둡게 하여 게임의 주의를 집중시키기 위해 사용된다."
    },
    {
        "term": "앵커 설정",
        "description": "UI 요소의 위치 및 크기를 화면의 특정 부분에 고정시키기 위한 설정. 해상도가 변경되더라도 UI 요소가 적절한 위치에 있도록 조정할 수 있게 한다."
    },
    {
        "term": "터치 이벤트",
        "description": "터치 이벤트는 사용자 터치에 반응하여 발생하는 행동을 의미합니다. Unity에서는 터치 이벤트를 처리하기 위해 Event Trigger 컴포넌트를 사용할 수 있으며, 버튼을 눌리거나 떼었을 때 발생하는 동작을 설정하는 데 사용됩니다."
    },
    {
        "term": "스크립팅",
        "description": "스크립팅은 Unity에서 게임 오브젝트의 동작 및 상태를 제어하기 위한 코드 작성 과정을 의미합니다. C# 언어를 주로 사용하여 이벤트 대응 및 게임 로직을 구현합니다."
    },
    {
        "term": "해상도 조정",
        "description": "게임의 UI 요소들이 다양한 화면 크기와 비율에서 적절히 작동하도록 설정하는 과정을 말합니다. 여기서는 9:19 비율을 기준으로 UI의 해상도를 조정하고 테스트하는 방법을 설명합니다."
    },
    {
        "term": "게임 카메라",
        "description": "게임 카메라는 게임의 뷰 포트를 정의하며, 플레이어가 볼 수 있는 화면을 결정합니다. 카메라 위치를 조정함으로써 UI와의 상호작용 및 콘텐츠의 표시를 최적화합니다."
    },
    {
        "term": "UI 디자인",
        "description": "UI 디자인은 사용자 경험을 고려한 인터페이스의 시각적 설계를 의미합니다. 이 강좌에서는 UI 요소들의 배치, 색상, 크기 등을 정리하고 최종 디자인을 검토합니다."
    },
    {
        "term": "2D 플랫포머",
        "description": "2D 플랫포머는 주로 2차원 평면에서 캐릭터가 점프하거나 이동하며 장애물을 피하고 적과 싸우는 게임 장르입니다. 주로 경량이며, 픽셀 아트 스타일로 구현되는 경우가 많아 시각적으로 매력적입니다."
    },
    {
        "term": "렌더 순서 (Order in Layer)",
        "description": "렌더 순서는 2D 게임에서 스프라이트가 화면에 표시되는 순서를 결정하는 속성입니다. 숫자가 클수록 화면 앞쪽에 나타나며, 이를 통해 시각적 깊이를 조정합니다."
    },
    {
        "term": "픽셀아트",
        "description": "픽셀아트는 저해상도 그래픽 스타일로, 작은 정사각형 픽셀을 조합하여 이미지를 형성하는 방식입니다. 독특한 미적 감각을 가지고 있으며, 일반적으로 레트로 게임 개발에 사용됩니다."
    },
    {
        "term": "물리 엔진",
        "description": "물리 엔진은 게임 내 객체들이 현실적인 물리적 상호작용을 수행하도록 돕는 시스템입니다. 주로 Rigidbody2D, Collider2D와 같은 구성 요소를 사용하여 객체의 움직임 및 충돌을 정의합니다."
    },
    {
        "term": "Rigidbody2D",
        "description": "Rigidbody2D는 유니티에서 2D 물리적 특성을 적용하기 위해 사용되는 컴포넌트로, 객체가 물리 법칙에 따라 움직이게 됩니다. 중력, 질량 및 힘을 적용할 수 있습니다."
    },
    {
        "term": "Collider2D",
        "description": "Collider2D는 유니티에서 2D 물리 충돌을 처리하는 컴포넌트로, 스프라이트의 형태를 정의하여 다른 Collider2D와의 충돌을 감지하도록 돕습니다."
    },
    {
        "term": "유니티 허브",
        "description": "유니티 허브는 여러 프로젝트 및 유니티 버전을 관리하는 데 사용되는 도구입니다. 프로젝트 생성, 유니티 버전 관리 및 에셋 관리 기능을 제공합니다."
    },
    {
        "term": "카메라 사이즈",
        "description": "카메라 사이즈는 2D 게임에서 카메라의 시야 범위를 정의하며, 스프라이트의 보이는 크기를 조정할 수 있습니다. 적절한 카메라 사이즈를 설정하면 게임의 비주얼 경험을 향상시킬 수 있습니다."
    },
    {
        "term": "2D 아틀라스",
        "description": "여러 개의 2D 스프라이트 이미지 파일을 하나의 텍스처로 결합하여 성능을 향상시키고 메모리를 절약하는 기법입니다. 아틀라스는 스프라이트 렌더링에 필요한 이미지를 효율적으로 관리하여 게임의 성능을 최적화합니다."
    },
    {
        "term": "스프라이트 에디터",
        "description": "유니티에서 스프라이트 아틀라스를 관리하고 각 스프라이트를 정의하는 툴입니다. 사용자는 이미지 파일을 불러와 이를 잘라내고 조정하여 원하는 형태의 스프라이트를 만들 수 있습니다."
    },
    {
        "term": "애니메이션",
        "description": "시간이 지남에 따라 변경되는 비주얼 표현의 집합으로, 게임 내 캐릭터의 움직임이나 효과를 자연스럽게 표현할 수 있습니다. 유니티에서는 스프라이트를 애니메이션으로 변환하여 캐릭터의 다양한 행동을 설정할 수 있습니다."
    },
    {
        "term": "키프레임",
        "description": "애니메이션에서 특정한 시점의 상태를 정의하는 프레임으로, 키프레임 간의 변화에 따라 애니메이션이 재생됩니다. 각 키프레임의 속성을 조정하여 애니메이션의 속도, 길이 등을 설정합니다."
    },
    {
        "term": "리지드 바디",
        "description": "유니티에서 물리적 상호작용을 가능하게 하는 컴포넌트로, 물체에 중력, 충돌, 운동 등을 적용합니다. 게임 오브젝트에 리지드 바디를 추가하면 물리 엔진이 이를 바탕으로 물리적 행동을 시뮬레이션합니다."
    },
    {
        "term": "플랫폼 이동",
        "description": "플랫폼 이동은 게임에서 캐릭터가 특정 지점에서 다른 지점으로 이동하는 기능으로, 2D 플랫포머 게임에서 플레이어의 주요 상호작용 방식 중 하나이다. 리지드 바디 시스템을 통해 자연스러운 물리 기반 이동을 구현하는 것이 중요하다."
    },
    {
        "term": "저항 수치 설정",
        "description": "저항 수치는 물체의 이동에 영향을 미치는 요소로, 물체가 속도를 감속하거나 느려지는 정도를 설정한다. 이 값은 주로 물리적 상호작용에서 움직임의 현실성을 높이는 데 필수적이다."
    },
    {
        "term": "카메라 조정",
        "description": "플랫폼의 길이를 조정한 후 카메라의 위치와 높이를 조정하는 과정은 게임 내 요소들이 적절하게 보이도록 하는 데 중요한 역할을 한다. 카메라의 시점은 플레이어의 경험에 상당한 영향을 미치며, 적절한 배치가 필요하다."
    },
    {
        "term": "애니메이션 순환",
        "description": "애니메이션 순환은 캐릭터의 동작이 자연스럽게 이어질 수 있도록 설정하는 과정으로, 애니메이션의 시작과 끝을 일치시킴으로써 시청자가 불편함을 느끼지 않도록 한다. 적절한 연결로 플레이어의 경험을 증대시킬 수 있다."
    },
    {
        "term": "점프 구현",
        "description": "플레이어의 점프를 구현하기 위해 'GetButtonDown' 함수와 힘을 주는 메커니즘을 사용할 수 있습니다. 이는 물리 엔진을 통해 플레이어가 점프할 수 있도록 힘을 가하는 방식으로, 창의적인 캐릭터 조작을 구현하는 데 필수적입니다."
    },
    {
        "term": "점프 파워",
        "description": "'점프 파워'는 점프 시 플레이어에게 가해지는 힘의 세기를 조절하는 변수로, 이 값을 변화시킴으로써 점프의 높이나 속도를 제어할 수 있습니다. 이는 게임의 플레이어 피드백과 경험을 조정하는 중요한 요소입니다."
    },
    {
        "term": "AFS 점프 애니메이션",
        "description": "AFS 점프 애니메이션은 점프 동작을 효과적으로 표현하기 위해 만들어진 애니메이션입니다. 애니메이션의 루프 타임 설정을 통해 점프 동작이 자연스럽게 표현되도록 관리할 수 있으며, 플레이어의 몰입감을 높이는 데 기여합니다."
    },
    {
        "term": "레이캐스트",
        "description": "레이캐스트는 특정 지점에서부터 주어진 방향으로 가상의 선을 쏘아 특정 오브젝트와의 충돌 여부를 확인하는 기법입니다. 2D 플랫포머에서 바닥에 접촉하는지를 판단하기 위해 사용되며, 이를 통해 물리적 상호작용을 세밀하게 조정할 수 있습니다."
    },
    {
        "term": "중복 점프 방지",
        "description": "중복 점프 방지는 플레이어가 공중에서 여러 번 점프하는 것을 방지하는 게임 규칙으로, 일반적으로 한 번의 점프만 가능하도록 설정됩니다. 이를 통해 게임 산업에서의 공통적인 게임 디자인 원칙을 준수하여 게임의 밸런스를 맞출 수 있습니다."
    },
    {
        "term": "Unity 애니메이션 컨트롤러",
        "description": "Unity 애니메이션 컨트롤러는 다양한 애니메이션 상태를 정의하고 이들 간의 전환을 관리하는 도구입니다. 이를 통해 게임 캐릭터의 다양한 동작을 부드럽고 자연스럽게 표현할 수 있으며, 플레이어의 경험에 큰 영향을 미칩니다."
    },
    {
        "term": "타일 팔레트",
        "description": "타일 팔레트는 2D 게임 개발에서 필요한 다양한 타일들을 그룹화하여 쉽게 관리할 수 있는 도구입니다. 유니티에서는 타일 팔레트를 사용하여 게임 레벨에서 사용할 타일들을 시각적으로 선택하고 조정할 수 있습니다."
    },
    {
        "term": "타일 맵",
        "description": "타일 맵은 2D 환경에서 게임 지형을 구성하는 격자 기반의 구조로, 개별 타일들을 배치하여 맵을 형성합니다. 유니티에서는 타일 맵을 생성하여 플랫폼이나 배경 등의 요소를 시각적으로 구축할 수 있습니다."
    },
    {
        "term": "물리 적용",
        "description": "물리 적용은 게임 내 오브젝트들이 물리법칙에 따라 상호작용하도록 설정하는 과정입니다. 유니티에서는 Rigidbody와 Collider 컴포넌트를 사용하여 오브젝트의 물리적 특성을 정의하고 충돌이나 상호작용을 구현할 수 있습니다."
    },
    {
        "term": "물리 모양 설정",
        "description": "물리 모양 설정은 게임 오브젝트의 Collider 모양 및 형태를 정의하는 과정입니다. 유니티에서는 Sprite Editor를 통해 각 스프라이트의 형태에 맞는 커스텀 콜라이더를 정의하여 보다 정확한 물리적 반응을 처리할 수 있습니다."
    },
    {
        "term": "Pixel Perfect Camera",
        "description": "Pixel Perfect Camera는 2D 게임 개발 시 픽셀 아트와 같은 그래픽 스타일을 유지하기 위해 사용하는 카메라입니다. 이 카메라는 픽셀의 비율을 제대로 맞추어 화면에 표시함으로써, 왜곡이나 흐림 없이 선명한 이미지를 제공합니다."
    },
    {
        "term": "에디트 모드",
        "description": "에디트 모드는 유니티의 편집기에서 게임 오브젝트를 배치하거나 수정할 수 있는 모드입니다. 이 모드에서 사용자는 타일을 그리거나 조정하여 게임 레벨을 설계할 수 있습니다."
    },
    {
        "term": "타일 브러시",
        "description": "타일 브러시는 타일 맵에 다양한 타일을 배치하는 데 사용하는 도구로, 마치 페인트 브러시와 같은 기능을 합니다. 사용자는 원하는 타일을 쉽게 그릴 수 있도록 돕는 기능입니다."
    },
    {
        "term": "경사로",
        "description": "경사로는 플랫폼 사용자가 점프하거나 이동할 수 있는 기울어진 형태의 표면입니다. 2D 플랫포머 게임에서 경사로는 자연스러운 이동과 점프를 가능하게 하여 게임의 재미를 더하는 중요한 요소입니다."
    },
    {
        "term": "AI (인공지능)",
        "description": "인공지능은 기계가 인간처럼 사고하고 결정 내릴 수 있도록 프로그래밍된 알고리즘이나 모델이다. 게임에서는 NPC(Non-Player Character)의 행동을 제어하는 데 주로 사용된다."
    },
    {
        "term": "재귀 함수",
        "description": "재귀 함수는 자기 자신을 호출하는 함수로, 문제를 더 작은 부분 문제로 나눠 해결할 수 있게 한다. 주로 반복적 작업을 효율적으로 수행하는 데 사용된다."
    },
    {
        "term": "랜덤",
        "description": "랜덤은 불확실하거나 예측할 수 없는 결과를 생성하는 과정으로, 게임 AI에서 행동 변화를 주기 위해 자주 활용된다."
    },
    {
        "term": "인보크",
        "description": "인보크는 주기적으로 특정 함수나 메서드를 호출하는 것을 의미하며, 게임의 업데이트 메커니즘에서 주로 사용된다. 'Invoke' 메소드를 통해 타이머 기능을 구현할 수 있다."
    },
    {
        "term": "조건문",
        "description": "조건문은 특정 조건이 참일 때만 실행되는 코드 블록으로, 게임 AI의 행동 결정 로직에 필수적이다. 'if', 'else' 문을 통해 다양한 행동을 구현할 수 있다."
    },
    {
        "term": "움직임 패턴",
        "description": "움직임 패턴은 캐릭터 또는 몬스터가 게임 내에서 어떻게 이동하는지를 정의하는 규칙이나 로직이다. 이를 통해 게임의 난이도 조절 및 플레이어의 경험을 조정할 수 있다."
    },
    {
        "term": "트랜지션",
        "description": "트랜지션은 애니메이션 간의 전환을 정의하는 과정으로, 애니메이터에서 상태 변화 시 어떤 애니메이션으로 이동할지를 설정하는 데 사용된다."
    },
    {
        "term": "플랫폼 게임",
        "description": "플랫폼 게임은 주로 2D 또는 3D 환경에서 캐릭터가 장애물이나 적을 피하면서 플랫폼을 이동하는 구조를 가진 비디오 게임이고, 정해진 목표를 달성하기 위해 레벨을 클리어하는 형태로 개발된다."
    },
    {
        "term": "무적 시간",
        "description": "무적 시간은 캐릭터가 공격이나 피격을 받았을 때 상처를 입지 않는 시간을 의미하며, 이를 통해 플레이어가 연속적으로 피해를 입지 않도록 보호하는 메커니즘이다. 이 기능은 게임의 난이도를 조절하는데 중요한 요소가 된다."
    },
    {
        "term": "온 콜라이전 엔터 (OnCollisionEnter)",
        "description": "온 콜라이전 엔터는 유니티에서 게임 오브젝트가 다른 오브젝트와 충돌할 때 호출되는 이벤트 함수로, 충돌 감지 및 그에 따른 동작 처리를 위해 자주 사용된다."
    },
    {
        "term": "애니메이션 트리거",
        "description": "애니메이션 트리거는 특정 조건이나 이벤트에 따라 애니메이션 상태를 전환하기 위한 메커니즘으로, 주로 Animator 컴포넌트와 함께 사용된다. 피격 애니메이션과 같은 특정 반응을 유도하는데 필요하다."
    },
    {
        "term": "충돌 처리",
        "description": "충돌 처리는 두 개 이상의 오브젝트가 접촉했을 때의 반응을 처리하는 과정으로, 게임의 물리적 상호작용을 설정하는 중요한 요소이다. 충돌 처리 함수는 게임의 실감나는 모션과 반응을 위해 필수적이다."
    },
    {
        "term": "플렛포머 게임 구조",
        "description": "플랫포머 게임은 주로 수평으로 진행되는 게임 형식으로, 플레이어가 다양한 장애물과 적을 피하며 목표 지점에 도달하는 것을 목적으로 한다. 게임의 레벨 디자인과 난이도 조절이 중요하다."
    },
    {
        "term": "onCollisionEnter2D",
        "description": "Unity의 물리 엔진에서 물체 간의 충돌을 감지하는 함수로, 충돌 시 발생하는 게임 로직을 작성할 수 있게 해준다. 주로 2D 게임 개발 시 사용된다."
    },
    {
        "term": "온트리거엔터2D",
        "description": "Unity의 충돌 감지 시스템 중 하나로, 특정 조건이 충족될 때 실행되는 스크립트 로직을 생성할 수 있다. 주로 아이템 수집과 같은 이벤트에 활용된다."
    },
    {
        "term": "유저 인터페이스 (UI)",
        "description": "게임의 시각적 요소로서 사용자가 정보를 보고 게임과 상호작용하는데 도움을 주는 그래픽 디자인을 포함한다. 점수, 스테이지 정보 등 플레이어 경험에 중요한 역할을 한다."
    },
    {
        "term": "사운드 효과",
        "description": "게임에서의 일어나는 이벤트와 플레이어 동작에 대한 청각적 피드백을 제공하여 몰입감을 높이는 요소. 적과의 충돌, 점수 획득 등의 사운드가 포함된다."
    },
    {
        "term": "무노크 현상",
        "description": "플레이어가 이동할 때 입력이 반응하지 않거나 정지하는 현상을 의미한다. 주로 입력 로직이나 물리엔진 설정에서 오류가 발생했을 때 나타난다."
    },
    {
        "term": "몬스터 밟기",
        "description": "플랫포머 게임에서 플레이어가 적의 머리 위에 올라가서 처치하거나 점수를 획득하는 메커니즘으로, 일반적으로 배경 스프라이트와 충돌을 통해 구현된다."
    },
    {
        "term": "결승점 설정",
        "description": "플랫포머 게임에서 스테이지 클리어를 위한 목적지로, 일정 위치에 도달했을 때 다음 레벨로 넘어갈 수 있도록 하는 시스템을 의미한다."
    },
    {
        "term": "Cinemachine",
        "description": "유니티의 강력한 카메라 워킹 패키지로, 다양한 카메라 동작과 효과를 구현할 수 있도록 지원하는 도구. 시네머신은 특히 게임 및 인터랙티브 콘텐츠의 카메라 연출에서 유용하게 사용된다."
    },
    {
        "term": "Cinemachine 3",
        "description": "Unity 6에서 새롭게 출시된 Cinemachine의 세 번째 버전. 기존 버전보다 사용자 친화적인 인터페이스와 다양한 모듈화된 기능을 제공하여, 카메라 제작 및 제어가 간편해졌다."
    },
    {
        "term": "Virtual Camera",
        "description": "Cinemachine에서 카메라의 위치와 방향을 제어하는 핵심 컴포넌트. 시네머신 3에서는 Virtual Camera가 Cinemachine Camera로 변경되어 보다 명확한 용도를 제공한다."
    },
    {
        "term": "Position Control",
        "description": "Cinemachine에서 카메라의 위치를 제어하는 기능으로, 다양한 모드(예: Orbital Follow)를 통해 움직임을 설정할 수 있다."
    },
    {
        "term": "Rotation Control",
        "description": "Cinemachine에서 카메라의 회전을 제어하는 기능으로, Hard Look At 기능을 통해 특정 대상(타겟)을 바라보도록 할 수 있다."
    },
    {
        "term": "Spline Dolly",
        "description": "Cinemachine 3에서 곡선을 따라 이동하는 트랙 카메라를 생성할 수 있도록 돕는 기능. Spline 패키지와 연동하여 자연스러운 움직임을 구현할 수 있다."
    },
    {
        "term": "Input Axis Controller",
        "description": "Cinemachine의 기능을 확장하기 위해 사용되는 컴포넌트로, 사용자의 입력(예: 마우스, 게임패드)을 받아들이고 이를 기반으로 카메라의 움직임을 제어할 수 있다."
    },
    {
        "term": "Sequencer Camera",
        "description": "여러 개의 Cinemachine 카메라를 관리하고 전환하는 데 사용되는 컴포넌트. 카메라 전환의 블렌드 타입과 시간을 조정하여 매끄러운 장면 전환을 가능케 한다."
    },
    {
        "term": "Upgrade Now",
        "description": "기존 시네머신 2 사용자들이 시네머신 3로 쉽게 업그레이드할 수 있도록 제공되는 기능으로, 기존 설정을 유지하면서 새로운 버전의 기능을 활용할 수 있게 한다."
    },
    {
        "term": "Composite Collider 2D",
        "description": "Composite Collider 2D는 여러 접근점의 Collider2D를 병합하여 하나의 Collider로 만들어주는 기능입니다. Unity 6에서는 모든 유형의 Collider2D를 합칠 수 있으며, 4가지 합성 연산(OR, AND, NOT, XOR)을 지원하여 복잡한 물리적 상호작용을 구현할 수 있습니다."
    },
    {
        "term": "Slide 함수",
        "description": "Slide 함수는 지면의 경사에 무관하게 Collider2D 면을 따라 자연스럽게 물체를 이동하도록 돕는 기능입니다. Kinematic 타입의 Rigidbody2D에서 최적의 성능을 발휘하며, 캐릭터의 이동을 부드럽게 구현할 수 있는 유용한 API입니다."
    },
    {
        "term": "Hinge Joint 2D",
        "description": "Hinge Joint 2D는 물체가 중심축을 기준으로 회전하는 물리적 연결을 생성합니다. Unity 6에서는 'Use Connected Anchor' 속성이 추가되어, 연결된 앵커를 쉽게 조작할 수 있어 물체의 분리 및 파괴 효과를 구현하는 데 유용합니다."
    },
    {
        "term": "totalForce and totalTorque",
        "description": "totalForce와 totalTorque는 현재 Rigidbody2D에 적용되는 전체적인 힘과 토크를 나타내는 새로운 속성입니다. 이를 통해 물리적 제어를 더욱 정밀하고 다양하게 활용할 수 있습니다."
    },
    {
        "term": "linearVelocity",
        "description": "linearVelocity는 Rigidbody2D의 속도를 나타내는 새로운 속성으로, 기존의 velocity에서 이름이 변경되었습니다. 이는 AngularVelocity와의 혼동을 방지하며, 더 나은 코드 가독성을 제공합니다."
    },
    {
        "term": "MovePositionAndRotation",
        "description": "MovePositionAndRotation은 Rigidbody2D의 Transform 제어 함수로, 내부적으로 사용하는 Vector 구조체를 한 번에 할당하여 최적화된 물리적 움직임을 제공합니다."
    },
    {
        "term": "STP (Spatial Temporal Post Processing)",
        "description": "STP는 Unity에서 개발한 업스케일러 기능으로, 낮은 해상도의 텍스처를 디스플레이 해상도로 확대하는 과정에서 시각적 품질을 유지합니다. 이 기능은 픽셀 처리 과정에서 성능을 향상시키며, 렌더 스케일 감소와 함께 사용될 수 있어, 더 높은 품질의 렌더링을 가능하게 합니다."
    },
    {
        "term": "GPU Occlusion Culling",
        "description": "GPU 기반의 Occlusion Culling은 사용자 시점에서 보이지 않는 오브젝트를 렌더링하지 않음으로써 그래픽스 성능을 최적화합니다. 이는 기존 CPU 기반 방식을 대체하여 GPU에서 처리함으로써 복잡한 씬에서도 가려진 오브젝트를 효과적으로 관리하고, 자원 절약 및 렌더링 성능 향상을 도모합니다."
    },
    {
        "term": "GPU Resident Drawer",
        "description": "이 기능은 드로우 콜을 자동으로 최적화하여 CPU 오버헤드를 줄이고 성능을 향상시킵니다. 최신 그래픽 API에서 작동하며 모바일 기기에 최적화되어 있어, 복잡도가 높은 씬에서도 CPU 성능을 효율적으로 유지할 수 있습니다."
    },
    {
        "term": "Batch Render Group",
        "description": "Batch Render Group API는 드로우 콜 수를 줄이고 CPU 속도를 높혀 성능을 최적화하는 기능입니다. 이 기능은 퍼시스턴트 GPU 버퍼를 활용하여 각 프레임의 데이터 전송 오버헤드를 줄이면서, 복잡한 씬에서도 효율적인 인스턴싱을 유지할 수 있도록 도와줍니다."
    },
    {
        "term": "Unity 6",
        "description": "Unity 6는 게임 및 3D 콘텐츠 개발을 위한 강력한 엔진으로, 향상된 그래픽 성능과 다양한 최적화 기능을 제공합니다. 이 버전은 특히 그래픽 성능을 개선하기 위한 여러 신기능을 도입하여, 개발자들이 더욱 향상된 비주얼 퀄리티를 구현할 수 있게 합니다."
    },
    {
        "term": "드로우 콜(Draw Call)",
        "description": "드로우 콜은 CPU가 GPU에 렌더링 명령을 전달할 때 발생하는 호출을 의미합니다. 드로우 콜의 수가 많을수록 CPU 부하가 증가하고 성능이 저하될 수 있으므로, 최적화 과정에서 드로우 콜 수를 줄이는 것이 중요합니다."
    },
    {
        "term": "렌더 스케일(Render Scale)",
        "description": "렌더 스케일은 게임의 렌더링 해상도를 설정하는 값을 말합니다. 렌더 스케일을 낮추면 성능을 향상시킬 수 있지만 시각적 품질이 저하될 수 있으므로, 효율적인 성능 조절이 필요합니다."
    },
    {
        "term": "2D 게임 개발",
        "description": "2D 게임 개발은 평면에서의 게임 디자인을 활용하여 플레이어가 조작하는 캐릭터와 환경을 구성하는 작업입니다. 뱀서라이크와 같은 2D 게임은 종종 그래픽을 간단하게 유지하면서도 매력적인 게임플레이를 제공하는 데 중점을 둡니다."
    },
    {
        "term": "스크립트 작성법",
        "description": "스크립트 작성법은 게임의 동작을 정의하는 코드 작성을 의미합니다. 유니티에서는 C# 언어를 사용하여 게임 오브젝트의 행동, 상호작용 및 게임 로직을 프로그래밍하게 됩니다. 이는 게임의 핵심 기능을 구현하는 데 필수적입니다."
    },
    {
        "term": "트리픽 시스템",
        "description": "트리픽 시스템은 게임 내에서 배치된 적의 행동 패턴 및 경로를 설정하는 시스템으로, 적들이 플레이어에게 효과적으로 반응하도록 설계됩니다. 이는 게임의 난이도 조정과 몰입감을 높이는 데 중요한 역할을 합니다."
    },
    {
        "term": "조이스틱 컨트롤",
        "description": "조이스틱 컨트롤은 게임 내에서 캐릭터의 움직임을 조작하는 입력 방법으로, 터치스크린 기기에서 매우 많이 사용됩니다. 유니티에서는 터치 입력을 관리하기 위한 다양한 툴과 패키지를 제공하여 개발자들이 쉽게 구현할 수 있도록 돕습니다."
    },
    {
        "term": "변수 (Variable)",
        "description": "프로그래밍에서 특정 데이터를 저장하기 위해 메모리 공간에 이름을 붙여 접근 가능하도록 한 것이다. 게임에서는 플레이어의 이름, 점수 등의 정보를 변수에 저장하여 사용할 수 있다."
    },
    {
        "term": "변수 타입 (Variable Type)",
        "description": "변수가 저장할 수 있는 데이터의 형식으로, C#에서는 int, float, string, bool 등 다양한 타입이 제공된다. 각 타입은 메모리 사용 및 연산 방식에 영향을 미친다."
    },
    {
        "term": "변수 선언 (Variable Declaration)",
        "description": "변수를 사용하기 전에 메모리 공간을 예약하고 데이터 타입과 변수 이름을 정의하는 과정이다. 예를 들어, 'int currentHP'와 같이 선언할 수 있다."
    },
    {
        "term": "지역 변수 (Local Variable)",
        "description": "함수 내부에서만 유효하며, 해당 함수가 실행되는 동안에만 존재하는 변수이다. 함수가 종료되면 소멸된다."
    },
    {
        "term": "클래스 멤버 변수 (Class Member Variable)",
        "description": "클래스의 인스턴스에 속하는 변수로, 클래스 외부에서도 접근할 수 있는 변수이다. 일반적으로 객체의 상태를 저장하는 데 사용된다."
    },
    {
        "term": "메모리 영역 (Memory Area)",
        "description": "변수가 저장되는 메모리의 장소로, 지역 변수는 스택 메모리에, 클래스 및 객체는 힙 메모리에 위치한다. 이 구조는 데이터의 생명주기 및 접근성을 결정짓는다."
    },
    {
        "term": "이름 규칙 (Naming Convention)",
        "description": "변수 이름은 대소문자를 구분하며 의미가 명확해야 한다. 일반적으로 소문자로 시작하며, 단어는 CamelCase 또는 snake_case 형태로 작성하는 것이 좋다."
    },
    {
        "term": "기본 데이터 형식",
        "description": "프로그래밍에서 사용되는 변수의 타입 분류로, 데이터의 크기와 형식에 따라 여러 가지로 나뉘며, 유니티 C#에서는 주로 정수형, 실수형, 문자열형, 논리형, 오브젝트형을 사용한다."
    },
    {
        "term": "정수형 (Integer)",
        "description": "정수형은 양의 정수 및 음의 정수를 표현할 수 있는 데이터 형식으로, 크기에 따라 다양한 바이트 크기를 가지며 (예: 1, 2, 4, 8 바이트) 데이터의 표현 범위를 관리하여야 한다."
    },
    {
        "term": "부동 소수점 (Floating Point)",
        "description": "부동소수점 형태의 수를 표현하기 위해 사용되는 데이터 형식으로, 실수형 변수의 한 종류이다. 플룻은 4바이트, 더블은 8바이트, 데시멀은 16바이트를 차지하며, 각각의 표현 범위가 다르다."
    },
    {
        "term": "문자형 (Character)",
        "description": "단일 문자를 표현하기 위한 데이터 형식으로, 일반적으로 작은 따옴표로 감싸서 표현되며 ASCII 또는 Unicode 인코딩을 사용할 수 있다."
    },
    {
        "term": "문자열형 (String)",
        "description": "여러 개의 문자를 큰 따옴표로 묶어 표현하는 데이터 형식으로, 보통 텍스트 데이터를 다룰 때 사용되며, 메모리에서 UTF-16 형식으로 저장된다."
    },
    {
        "term": "논리형 (Boolean)",
        "description": "참(true)과 거짓(false) 두 가지 값만을 가지는 데이터 형식으로, 주로 조건문이나 불리언 연산에 사용되며, 변수 이름에 'is'를 포함하여 논리적 상태를 표현할 수 있다."
    },
    {
        "term": "오브젝트형 (Object)",
        "description": "다양한 데이터 형식을 저장할 수 있는 고급 데이터 형식이며, 박싱과 언박싱 과정을 통해 사용된다. 오브젝트형은 메모리 관리 측면에서 스택 메모리와 힙 메모리를 이해하는 것이 중요하다."
    },
    {
        "term": "박싱 (Boxing)",
        "description": "값 형식을 객체 형식으로 변환하는 프로세스이며, 객체 유형으로 접근할 수 있게 해준다."
    },
    {
        "term": "언박싱 (Unboxing)",
        "description": "객체 형식을 값 형식으로 변환하는 과정으로, 데이터 형식이 원래의 구성으로 되돌아가게 한다."
    },
    {
        "term": "메모리 관리",
        "description": "효율적이고 안전한 코드를 작성하기 위해 메모리의 할당과 해제를 적절히 관리하는 과정으로, 특히 C#과 같은 언어에서 중요하다."
    },
    {
        "term": "형 변환 (Type Conversion)",
        "description": "형 변환은 한 데이터 타입을 다른 데이터 타입으로 전환하는 과정으로, 프로그래밍에서 중요한 개념이다. C#에서는 여러 형태의 형 변환이 지원되며, 이 과정에서 데이터의 손실 또는 변형이 발생할 수 있다."
    },
    {
        "term": "오버플로우 (Overflow)",
        "description": "오버플로우는 변수에 저장할 수 있는 데이터의 범위를 초과할 때 발생하는 문제로, 크기가 작은 데이터 타입에 큰 값을 저장하는 경우 주의가 필요하다. 예를 들어, int형에서 byte형으로 변환할 때 큰 값이 유효한 byte 범위를 초과하면 데이터 손실이 발생한다."
    },
    {
        "term": "부호 있는 정수 vs. 부호 없는 정수 (Signed vs. Unsigned Integers)",
        "description": "부호 있는 정수는 양수와 음수를 모두 표현할 수 있지만, 부호 없는 정수는 오직 양수만 표현할 수 있다. 이 둘 간의 변환 시 음수를 가진 부호 있는 정수의 경우 부정확한 결과를 초래할 수 있다."
    },
    {
        "term": "부동 소수점 형 변환 (Floating Point Conversion)",
        "description": "부동 소수점 형 변환에서 오버플로우는 발생하지 않지만, 정밀도가 손실될 수 있다. 이는 소수점 이하 숫자의 정보가 손실될 가능성이 있어, 수치적 변환에서 어느 정도의 정밀도가 요구되는지 고려해야 한다."
    },
    {
        "term": "try-parse 메소드 (Try-Parse Method)",
        "description": "try-parse 메소드는 문자열을 숫자로 변환할 때 사용되는 안전한 방법으로, 변환이 성공했는지 확인할 수 있는 기능을 제공한다. 직접 문자열을 숫자로 변환할 경우 발생할 수 있는 예외를 방지하기 위한 장치로 활용된다."
    },
    {
        "term": "데이터 손실 (Data Loss)",
        "description": "데이터 손실은 형 변환 과정에서 원래의 데이터 정보가 사라지는 현상으로, 대개 변환할 수 있는 타입 간의 크기나 표현 범위가 다를 때 발생한다. 이러한 문제를 예방하기 위해 적절한 타입을 선택하는 것이 중요하다."
    },
    {
        "term": "const",
        "description": "const는 상수를 정의하는 키워드로, 선언된 이후에는 절대 값이 변경될 수 없는 변수를 생성합니다. 게임 개발에서는 예를 들어, 최대 생명치와 같이 변경되지 않아야 할 상수를 사용하는 데 유용합니다."
    },
    {
        "term": "readonly",
        "description": "readonly는 객체의 초기값 설정 이후 값을 변경할 수 없는 변수 타입입니다. 이는 컴파일러가 코드에서 변수의 변경을 차단하여 발생할 수 있는 오류를 방지하는 데 도움을 줍니다."
    },
    {
        "term": "열거형 (Enumeration Type)",
        "description": "열거형은 관련된 상수 집합을 하나의 타입으로 묶는 방법입니다. 이를 통해 게임에서 캐릭터의 상태, 동작 등을 보다 명확하고 조직적으로 관리할 수 있습니다. 기본적으로 int를 기반으로 하며, 각 상수는 자동으로 0부터 시작하여 자동으로 값을 증가시킵니다."
    },
    {
        "term": "Nullable",
        "description": "Nullable은 변수에 null 값을 허용할 수 있도록 하는 데이터 타입입니다. 기본적인 int, float와 같은 값 타입은 null을 허용하지 않지만, nullable 변수를 통해 빈 값을 명시적으로 처리할 수 있습니다. 'int?'와 같이 물음표를 붙여 선언합니다."
    },
    {
        "term": "var",
        "description": "var는 변수를 선언할 때 타입을 컴파일러가 자동으로 추론하게 해주는 키워드입니다. 이는 코드의 가독성을 높이는 데 기여하지만, 지역 변수에서만 사용할 수 있으며 명시적인 타입을 요구하지 않는 특성이 있습니다."
    },
    {
        "term": "문자열 서식",
        "description": "C#에서 문자열을 특정 형식으로 변환하는 과정으로, 'string.Format' 메소드를 사용하여 서식 항목에 따라 원하는 형식을 지정하고 매개변수를 적용하여 출력 결과를 생성한다."
    },
    {
        "term": "문자열 보간",
        "description": "C# 6.0 이상에서 지원되는 기능으로, 문자열 앞에 달러 기호($)를 붙여 중괄호({}) 내부에 변수를 직접 넣어 문자열을 생성할 수 있도록 하는 방법이다. 이는 가독성이 높고 코드의 간결성을 제공한다."
    },
    {
        "term": "문자열 탐색",
        "description": "문자열 내에서 특정 문자나 단어의 위치를 찾는 기능으로, 'indexOf', 'lastIndexOf', 'startsWith', 'endsWith', 'contains' 메소드를 통해 문자열의 특정 패턴 존재 여부를 확인하고 해당 인덱스를 제공한다."
    },
    {
        "term": "문자열 변형",
        "description": "기존 문자열의 내용을 수정하거나 변환하는 기능으로, 'toLower', 'toUpper', 'insert', 'remove', 'trim', 'replace' 등의 메소드를 사용해 문자열의 형태를 다양하게 조작할 수 있다."
    },
    {
        "term": "문자열 분할",
        "description": "문자열을 특정 기준에 따라 나누는 기능으로, 'split' 메소드는 구분 문자를 기준으로 배열로 분할하며, 'substring' 메소드는 지정한 인덱스부터 문자들을 잘라내어 새로운 문자열을 생성하는 메소드이다."
    },
    {
        "term": "연산자",
        "description": "프로그래밍에서 변수와 값을 처리하기 위해 사용하는 기호로, 다양한 연산을 수행하는 데 필요한 기초 요소. 예를 들어, 대입 연산자, 산술 연산자 등이 포함된다."
    },
    {
        "term": "산술 연산자",
        "description": "숫자 데이터에 대해 기본적인 산술 연산을 수행하는 연산자. 대표적으로 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/), 나머지(%) 연산자가 있다."
    },
    {
        "term": "대입 연산자",
        "description": "작업의 결과값을 특정 변수에 저장하기 위해 사용하는 연산자로, '=' 기호로 표시된다. 다양한 축약형 대입 연산자도 제공된다."
    },
    {
        "term": "증감 연산자",
        "description": "변수의 값을 각각 1씩 증가 또는 감소시키는 연산자. '++'는 증가, '--'는 감소를 표현하며, 전위(++)와 후위(++) 방식에 따라 동작이 달라질 수 있다."
    },
    {
        "term": "비교 연산자",
        "description": "두 값을 비교하여 결과적으로 true 또는 false를 반환하는 연산자. 등호(==), 부등호(<, >), 같지 않음(!=) 등이 있다."
    },
    {
        "term": "논리 연산자",
        "description": "복수의 조건을 동시에 평가하고 결합하기 위해 사용하는 연산자. AND(&&), OR(||), NOT(!) 연산자가 포함된다."
    },
    {
        "term": "조건(삼항) 연산자",
        "description": "조건에 따라 두 값을 선택하는 데 사용되는 연산자로, '(조건식) ? (참일 때의 값) : (거짓일 때의 값)' 형태로 표현된다."
    },
    {
        "term": "비트 연산자",
        "description": "이진수의 비트를 직접 조작하는 연산자. 비트 단위의 AND(&), OR(|), NOT(~) 연산자와 비트 쉬프트 연산자가 있다."
    },
    {
        "term": "우선순위",
        "description": "연산자의 평가 순서를 결정하는 규칙. 우선순위를 잘 이해하고 사용할 수 있어야 코드를 효율적으로 작성할 수 있으며, 괄호를 통해 우선순위를 조절할 수 있다."
    },
    {
        "term": "if 문",
        "description": "if 문은 주어진 조건식이 true일 경우에만 중괄호 내부의 코드를 실행합니다. 조건이 false라면 해당 코드 블록은 무시됩니다."
    },
    {
        "term": "else 문",
        "description": "else 문은 if와 함께 사용되어야 하며, if 조건이 false일 때 실행되는 코드 블록을 정의합니다."
    },
    {
        "term": "else if 문",
        "description": "else if 문은 조건을 순차적으로 체크할 수 있게 해줍니다. 여러 개의 조건이 있을 때, 첫 번째 true인 조건에 대응하는 코드를 실행합니다."
    },
    {
        "term": "switch-case",
        "description": "switch-case 문은 하나의 변수에 대해 다양한 조건을 검사할 수 있도록 해주는 제어 구조입니다. 각 조건에 대해 대응되는 케이스를 설정하고, 조건에 맞지 않는 경우 default 값을 실행합니다."
    },
    {
        "term": "반복문",
        "description": "특정 조건이 충족될 때까지 코드 블록을 반복하여 실행하는 프로그래밍 구조로, 코드의 중복을 피하고 효율적으로 작업을 처리할 수 있다."
    },
    {
        "term": "for 반복문",
        "description": "반복하고자 하는 횟수가 정해져 있을 때 사용되는 반복문으로, 초기화, 조건 검사, 증감 연산자를 하나의 괄호 안에 명시해 반복을 제어한다."
    },
    {
        "term": "while 반복문",
        "description": "지정된 조건이 참인 동안 코드 블록을 반복 실행하는 구조로, 조건만을 괄호 안에 입력하고 반복을 위한 초기화 및 증감 연산은 별도로 수행한다."
    },
    {
        "term": "do-while 반복문",
        "description": "먼저 코드 블록을 실행한 후 조건을 검사하는 반복문으로, 최소한 한 번은 코드 블록이 실행됨을 보장한다."
    },
    {
        "term": "무한 루프",
        "description": "종료 조건이 설정되지 않거나 항상 참인 조건을 가진 반복문으로, 일반적으로 프로그램이 종료되지 않음을 유발할 수 있으므로 주의가 필요하다."
    },
    {
        "term": "점프문",
        "description": "프로그램의 흐름을 제어하는 명령어로, break와 continue가 있다. break는 현재 반복문을 종료하고, continue는 현재 반복의 나머지를 건너뛰어 다음 반복을 시작한다."
    },
    {
        "term": "중첩 반복문",
        "description": "반복문 안에 또 다른 반복문을 포함하는 구조로, 다양한 조합의 결과를 생성할 수 있어 복잡한 반복 로직을 구현하는 데 유용하다."
    },
    {
        "term": "배열",
        "description": "배열은 같은 데이터 형식을 가진 변수들을 그룹화하여 하나의 변수 이름 아래 관리할 수 있도록 하는 자료 구조입니다. 이를 통해 다수의 데이터를 보다 효율적으로 저장하고 처리할 수 있습니다."
    },
    {
        "term": "1차원 배열",
        "description": "1차원 배열은 단일 차원으로 이루어진 배열로, 순차적으로 데이터가 저장됩니다. 예를 들어, int[] enemies = new int[5];는 5개의 정수형 데이터를 저장할 수 있는 1차원 배열입니다."
    },
    {
        "term": "2차원 배열",
        "description": "2차원 배열은 행과 열로 구성된 배열로, 보통 매트릭스 형태로 데이터를 표현합니다. int[,] enemies = new int[2, 3];와 같이 선언하여 2개의 행과 3개의 열을 가진 배열을 생성할 수 있습니다."
    },
    {
        "term": "가변 배열 (Jagged Array)",
        "description": "가변 배열 또는 Jagged Array는 각 배열 요소가 서로 다른 크기를 가질 수 있는 배열입니다. 예를 들어, int[][] enemies = new int[3][];는 3개의 1차원 배열을 생성하지만 각 배열의 크기는 다르게 설정할 수 있습니다."
    },
    {
        "term": "초기화",
        "description": "배열의 선언 시 초기화는 여러 방법으로 진행할 수 있습니다. 원소의 개수를 명시하고 블록으로 데이터를 정의하거나, capacity를 생략하고 중괄호로 값을 직접 지정하는 방법 등이 있습니다."
    },
    {
        "term": "자료형",
        "description": "배열은 특정 자료형(int, float, string 등)으로 선언되며, 해당 자료형에 맞는 값을 저장합니다. 데이터의 특성과 요구에 따라 적절한 자료형 선택이 중요합니다."
    },
    {
        "term": "메소드(Method)",
        "description": "메소드는 일련의 코드 블록을 하나의 이름 아래 그룹화한 것이며, 객체지향 프로그래밍에서 함수나 서브루틴과 유사한 개념으로 사용됩니다. 메소드는 특정 작업을 수행하기 위해 재사용 가능한 코드를 작성하는 구조를 제공합니다."
    },
    {
        "term": "메소드의 장점",
        "description": "메소드는 코드를 재사용할 수 있도록 하여 개발 과정을 효율적으로 만들어줍니다. 동일한 기능을 수행하는 코드를 여러 번 작성할 필요가 없기 때문에 코드의 가독성과 유지보수성이 향상됩니다."
    },
    {
        "term": "Return 키워드",
        "description": "메소드가 특정 값을 반환할 때 사용되며, 반환되는 값은 메소드를 호출한 위치로 전달됩니다. 반환형식의 일치가 중요하여, 잘못된 형식의 반환 시 오류가 발생할 수 있습니다."
    },
    {
        "term": "매개 변수(Parameters)",
        "description": "메소드는 외부 데이터를 수신하기 위해 매개 변수를 선언합니다. 매개 변수는 메소드 내부에서 사용되며, 함수의 유연성을 높여 코드의 다양한 경우를 처리할 수 있도록 합니다."
    },
    {
        "term": "값에 의한 전달( pass by value )",
        "description": "메소드에 전달된 데이터의 복사본이 생성되어 사용되는 방식입니다. 원본 데이터는 수정되지 않으며, 주로 기본 데이터 형식에서 사용됩니다."
    },
    {
        "term": "참조에 의한 전달( pass by reference )",
        "description": "원본 데이터에 대한 참조가 전달되어 메소드 내에서 직접 수정할 수 있는 방식입니다. 이는 메모리 효율성을 높이고 복잡한 데이터 구조의 수정이 용이하게 해 줍니다."
    },
    {
        "term": "out 매개 변수",
        "description": "out 키워드를 사용하여 메소드 외부에 값을 반환할 수 있는 방법입니다. 이 방법은 여러 값을 반환할 때 유용하며, 반환된 값은 호출한 위치에 반환됩니다."
    },
    {
        "term": "메소드 오버로딩(Method Overloading)",
        "description": "동일한 이름의 메소드를 매개변수의 수나 유형이 다르게 정의하는 기법입니다. 이를 통해 개발자는 기능의 재사용 및 코드를 깔끔하게 유지할 수 있습니다."
    },
    {
        "term": "가변 길이 매개 변수(Params)",
        "description": "params 키워드를 사용하여 임의의 개수의 인자를 받을 수 있도록 정의된 매개 변수입니다. 이는 패턴을 배열처럼 다룰 수 있게 해주며, 가변 인자를 처리할 수 있게 합니다."
    },
    {
        "term": "명명된 매개 변수(Named Parameters)",
        "description": "매개 변수의 이름으로 값을 설정할 수 있는 기능입니다. 이를 통해 매개 변수의 순서와 관계없이 직관적으로 작성할 수 있어 코드의 가독성을 높입니다."
    },
    {
        "term": "선택적 매개 변수(Optional Parameters)",
        "description": "기본값을 설정한 매개 변수로, 호출 시 값이 지정되지 않으면 기본값이 사용됩니다. 이는 메소드를 더욱 유연하게 만들며, 사용자가 필요할 때만 값을 지정할 수 있도록 합니다."
    },
    {
        "term": "객체 지향 프로그래밍 (OOP)",
        "description": "OOP는 소프트웨어 구조 시스템의 설계를 단순화하고 이해도를 높이기 위해 프로그램을 독립된 객체 단위로 나누는 프로그래밍 패러다임입니다. 객체는 데이터와 기능을 포함하고 있으며, 현실 세계의 요소를 모델링합니다."
    },
    {
        "term": "클래스",
        "description": "클래스는 객체를 정의하는 청사진 역할을 하며, 객체의 속성과 행동을 나타내는 멤버 변수와 멤버 함수를 포함합니다. 예를 들어, 자동차 클래스를 통해 자동차 객체를 생성하고, 그 특성과 기능을 정의합니다."
    },
    {
        "term": "멤버 변수와 멤버 함수",
        "description": "멤버 변수는 클래스의 상태를 나타내는 데이터 필드인 반면, 멤버 함수는 클래스가 수행할 수 있는 행동을 정의하는 메소드입니다. 이들은 클래스의 내부 동작을 구성하는 핵심 요소입니다."
    },
    {
        "term": "접근 지정자",
        "description": "접근 지정자는 클래스 멤버의 접근성을 제어하여, 데이터 캡슐화와 보안을 강화하는 데 중요한 역할을 합니다. 주로 public, private, protected 키워드가 사용되며, 이는 멤버의 외부 접근을 제한하거나 허용합니다."
    },
    {
        "term": "생성자",
        "description": "생성자는 클래스의 인스턴스가 생성될 때 자동으로 호출되는 메소드로, 클래스의 이름과 동일합니다. 이 메소드는 초기화를 위해 사용되며 반환 형식이 없고, 객체의 상태를 설정하는 데 중요한 역할을 합니다."
    },
    {
        "term": "소멸자",
        "description": "소멸자는 객체가 메모리에서 해제될 때 호출되는 메소드로, 이름 앞에 물결(~)을 붙입니다. C#에서는 메모리 관리가 자동화되어 있어 소멸자의 사용이 상대적으로 적습니다."
    },
    {
        "term": "얕은 복사와 깊은 복사",
        "description": "얕은 복사는 객체의 메모리 주소만 복사하여 동일한 메모리를 참조하게 되고, 깊은 복사는 객체의 데이터를 복사하여 새로운 메모리 공간을 생성합니다. 두 방식은 객체의 변경과 데이터 안전성에 중요한 영향을 미칩니다."
    },
    {
        "term": "this 키워드",
        "description": "this 키워드는 클래스 내부에서 자신의 변수나 메소드를 참조할 때 사용되는 키워드로, 지역 변수와 클래스 멤버의 이름이 충돌할 때 차이를 명확히 하기 위해 사용됩니다. 또한, 생성자 간의 호출에도 활용됩니다."
    },
    {
        "term": "정보 은닉 (Information Hiding)",
        "description": "정보 은닉은 클래스 외부에서 클래스의 멤버 변수에 직접 접근하지 못하도록 하는 기법으로, 변수의 가시성을 제한합니다. 일반적으로 private 접근 수식어를 사용하여 외부로부터 보호하며, 이를 통해 데이터의 무결성을 유지할 수 있습니다."
    },
    {
        "term": "캡슐화 (Encapsulation)",
        "description": "캡슐화는 정보 은닉을 통해 외부에서 데이터 변경을 멈추고, 변경 및 접근할 수 있는 메소드를 제공하는 과정입니다. 일반적으로 setter와 getter 메소드가 사용되어 내부 데이터의 안전한 접근과 조작을 보장합니다."
    },
    {
        "term": "상속 (Inheritance)",
        "description": "상속은 부모 클래스의 속성과 메소드를 자식 클래스가 물려받아 사용할 수 있도록 해주는 객체 지향 프로그래밍의 주요 개념입니다. 이를 통해 코드의 중복이 줄어들고, 계층 구조의 명확성을 높일 수 있습니다."
    },
    {
        "term": "다형성 (Polymorphism)",
        "description": "다형성은 서로 다른 클래스의 인스턴스가 동일한 인터페이스를 통해 처리될 수 있는 능력을 의미합니다. 이는 메소드 오버라이딩 및 업캐스팅을 통해 구현되며, 다양한 객체들을 통합적으로 다룰 수 있게 해줍니다."
    },
    {
        "term": "업캐스팅 (Upcasting)",
        "description": "업캐스팅은 자식 클래스의 객체를 부모 클래스 타입으로 변환하는 과정입니다. 이를 통해 부모 클래스의 변수로 자식 클래스의 메소드를 호출할 수 있으며, 다형성의 중요한 요소로 작용합니다."
    },
    {
        "term": "메소드 오버라이딩 (Method Overriding)",
        "description": "메소드 오버라이딩은 부모 클래스에서 정의된 메소드를 자식 클래스에서 재정의하는 과정으로, 자식 클래스의 고유한 행동을 구현할 수 있게 해줍니다. 이를 통해 상속받은 메소드를 커스터마이즈할 수 있습니다."
    },
    {
        "term": "형 변환 (Type Casting)",
        "description": "형 변환은 객체의 데이터 타입을 다른 타입으로 변환하는 과정입니다. is 및 as 연산자를 사용하여 런타임에 객체의 타입을 확인하고 안전하게 변환할 수 있습니다."
    },
    {
        "term": "추상화 (Abstraction)",
        "description": "추상화는 구체적인 구현을 숨기고 필요한 기능만을 드러내는 개념입니다. 추상 클래스 또는 인터페이스를 통해 공통 행동을 정의하고, 구체적인 클래스에서 이를 구현하도록 강제합니다."
    },
    {
        "term": "인터페이스 (Interface)",
        "description": "인터페이스는 서로 다른 클래스 사이의 관계를 정의하는 계약으로, 메소드의 시그니처만을 포함합니다. 이를 구현하는 클래스는 반드시 메소드를 정의해야 하며, 다중 상속을 통해 여러 인터페이스를 구현할 수 있어 유연성과 재사용성이 높습니다."
    },
    {
        "term": "다중 상속 (Multiple Inheritance)",
        "description": "다중 상속은 하나의 클래스가 여러 부모 클래스로부터 속성과 메소드를 상속받을 수 있는 기능입니다. 인터페이스를 통한 다중 상속은 객체 지향 프로그래밍의 강력한 특징으로, 다양한 기능을 조합하여 사용할 수 있습니다."
    },
    {
        "term": "메소드 숨기기 (Method Hiding)",
        "description": "부모 클래스에서 정의된 메소드를 자식 클래스에서 감추고 새로운 메소드를 정의하는 기능으로, 'new' 키워드를 사용하여 자식 클래스에서 부모 클래스의 동일한 이름의 메소드를 덮어쓰지 않고 새롭게 구현할 수 있다."
    },
    {
        "term": "오버라이딩 봉인 (Sealing Overrides)",
        "description": "virtual로 선언된 메소드를 자식 클래스에서 재정의할 수 없도록 막는 기능이다. 이는 메소드의 일관성을 유지하려는 목적으로 사용되며, 특히 상속 구조에서 기본 동작을 고정시키고자 할 때 유용하다."
    },
    {
        "term": "중첩 클래스 (Nested Class)",
        "description": "클래스 내부에 정의된 클래스로, 클래스들 간의 논리적 그룹을 형성하거나 외부에서 접근을 제한하는 데 사용된다. 중첩 클래스는 외부 클래스의 멤버에 접근할 수 있는 특성을 가진다."
    },
    {
        "term": "분할 클래스 (Partial Class)",
        "description": "하나의 클래스를 여러 파일에 나누어 구현할 수 있게 해주는 기능으로, 대형 클래스의 관리를 용이하게 하며, 소스 코드를 여러 파일에 나누어 배포할 수 있다. 'partial' 키워드를 통해 구현된다."
    },
    {
        "term": "구조체 (Struct)",
        "description": "클래스와 유사한 데이터 구조로, 변수와 메소드를 포함할 수 있으며, 값 형식으로 동작한다. 주로 데이터 집합을 정의하는 데 사용되며, 기본 생성자를 통해 초기화할 수 있다."
    },
    {
        "term": "튜플 (Tuple)",
        "description": "여러 데이터를 하나의 객체로 묶는 구조로, 일반적인 구조체와 달리 변수 이름이 없으며, item1, item2 등의 형식으로 데이터를 접근할 수 있다. 간단한 관계형 데이터의 임시 저장에 사용된다."
    },
    {
        "term": "static 키워드 (static Keyword)",
        "description": "클래스의 인스턴스에 속하지 않고 클래스 자체에 소속되는 메소드와 변수를 정의하는데 사용된다. static 메소드는 객체 생성 없이 호출할 수 있으며, 메모리에서 로딩 시 단 한 번만 생성된다."
    },
    {
        "term": "확장 메소드 (Extension Method)",
        "description": "기존 클래스의 기능을 확장하는 방법으로, 기존 코드에 직접적으로 수정 없이 새로운 기능을 추가할 수 있다. 이를 위해 정적 클래스를 정의하고 static 메소드를 this 키워드와 함께 사용하여 구현된다."
    },
    {
        "term": "이름 공간 (Namespace)",
        "description": "관련된 클래스와 구조체를 그룹화하여 관리하는 기능으로, 이름 충돌을 방지하며 서로 다른 클래스가 동일한 이름을 가질 수 있게 한다. 'using' 키워드를 통해 특정 이름 공간을 사용할 수 있다."
    },
    {
        "term": "프로퍼티 (Property)",
        "description": "C#에서 프로퍼티는 클래스의 멤버 변수에 대한 접근을 간편하게 관리할 수 있는 수단으로, get과 set 접근자를 통해 멤버 변수의 은닉성을 보장합니다."
    },
    {
        "term": "자동 구현 프로퍼티 (Auto-Implemented Properties)",
        "description": "자동 구현 프로퍼티는 별도의 백ing 필드 없이 프로퍼티를 정의할 수 있는 방식으로, 코드의 간결성을 높이고 불필요한 변수를 줄이는 데 유용합니다."
    },
    {
        "term": "읽기 전용 프로퍼티 (Read-Only Property)",
        "description": "read-only 프로퍼티는 get 접근자만 정의해야 하며, 외부에서 값을 수정할 수 없는 속성을 만드는 데 사용됩니다."
    },
    {
        "term": "쓰기 전용 프로퍼티 (Write-Only Property)",
        "description": "write-only 프로퍼티는 set 접근자만 정의되어 있으며, 외부에서 값을 읽을 수 없지만 설정은 가능합니다. 이는 특정 데이터 유출을 방지하는 데 유용합니다."
    },
    {
        "term": "생성자 (Constructor)",
        "description": "생성자는 객체 인스턴스가 생성될 때 초기화 작업을 수행하는 메소드로, 프로퍼티의 초기화 시점과 메모리 할당을 효율적으로 관리할 수 있습니다."
    },
    {
        "term": "추상 클래스 (Abstract Class)",
        "description": "추상 클래스는 인스턴스화할 수 없는 클래스이며, 일반 프로퍼티와 함께 abstract 키워드를 사용해 구현되지 않은 프로퍼티도 정의 가능합니다. 이는 다양한 하위 클래스에서 코드 재사용성을 높입니다."
    },
    {
        "term": "컬렉션 (Collection)",
        "description": "유니티 C# 프로그래밍에서 객체 타입의 데이터를 담는 자료구조의 집합을 의미하며, 다양한 유형의 컬렉션을 통해 데이터의 추가, 삭제, 검색 및 관리를 효율적으로 수행할 수 있다."
    },
    {
        "term": "ArrayList",
        "description": "ArrayList는 크기가 동적으로 변하는 배열처럼 작동하여 데이터를 쉽게 추가 및 삭제할 수 있게 해주는 자료구조로, 메소드를 통해 요소를 조작할 수 있다. 이 컬렉션은 데이터를 보관하는 동안 크기를 자동으로 조정한다."
    },
    {
        "term": "Queue",
        "description": "Queue는 FIFO(First In First Out) 원칙에 따라 작동하는 자료구조로, 가장 먼저 추가된 데이터가 가장 먼저 삭제되고 처리된다. 주로 대기행렬이나 처리 순서가 중요한 경우에 사용된다."
    },
    {
        "term": "Stack",
        "description": "Stack은 LIFO(Last In First Out) 원칙에 따라 작동하는 자료구조로, 마지막에 추가된 데이터가 가장 먼저 삭제되는 방식이다. 주로 임시 데이터 저장이나 함수 호출 관리에 활용된다."
    },
    {
        "term": "Hashtable",
        "description": "Hashtable은 키와 값의 쌍을 저장하는 자료구조로, 고유한 키를 사용하여 데이터를 빠르게 검색하는 방식이다. 이 컬렉션은 해시 함수에 기반하여 효율적인 데이터 접근이 가능하다."
    },
    {
        "term": "메소드 (Method)",
        "description": "컬렉션 자료구조에서 특정 기능을 수행하도록 정의된 함수로, ArrayList, Queue, Stack, Hashtable 각각에서 사용되는 다양한 메소드(add, insert, remove 등)를 통해 데이터를 조작하고 관리할 수 있다."
    },
    {
        "term": "FIFO",
        "description": "FIFO(First In First Out)는 데이터가 들어온 순서대로 처리되는 방식으로, Queue와 같은 컬렉션 자료구조에서 사용된다."
    },
    {
        "term": "LIFO",
        "description": "LIFO(Last In First Out)는 마지막에 들어온 데이터가 가장 먼저 처리되는 방식으로, Stack과 같은 컬렉션 자료구조에서 사용된다."
    },
    {
        "term": "foreach 반복문",
        "description": "컬렉션의 모든 요소를 순회하여 처리하는 반복문으로, 주로 데이터의 각 요소에 대한 작업을 수행할 때 사용된다."
    },
    {
        "term": "일반화 프로그래밍 (Generic Programming)",
        "description": "일반화 프로그래밍은 특정한 데이터 타입을 일반화하여 하나의 메소드 또는 클래스를 다양한 데이터 타입과 함께 사용할 수 있도록 하는 프로그래밍 패러다임입니다. 이를 통해 코드의 재사용성과 효율성을 높이고 타입 안전성을 유지할 수 있습니다."
    },
    {
        "term": "일반화 메소드 (Generic Method)",
        "description": "일반화 메소드는 하나 이상의 형식 매개변수를 받아 다양한 데이터 유형을 처리할 수 있는 메소드를 정의하는 것입니다. 형식 매개변수는 메소드 이름 뒤에 정의되며, 호출 시 실제 데이터 타입으로 대체됩니다."
    },
    {
        "term": "일반화 클래스 (Generic Class)",
        "description": "일반화 클래스는 클래스를 정의할 때 특정한 데이터 타입에 구애받지 않고 다양한 자료형을 사용할 수 있도록 형식 매개변수를 포함하는 클래스입니다. 이를 통해 코드에서 중복을 줄이고 타입 안전성을 보장할 수 있습니다."
    },
    {
        "term": "형식 매개변수 제약 (Type Parameter Constraints)",
        "description": "형식 매개변수 제약은 일반화 프로그래밍에서 형식 매개변수에 특정 조건을 부여하여 제한하는 기능입니다. 'where' 키워드를 사용하여 특정 형식에만 대응 가능한 형식 매개변수를 설정할 수 있습니다."
    },
    {
        "term": "일반화 컬렉션 (Generic Collection)",
        "description": "일반화 컬렉션은 다양한 데이터 타입을 지원하도록 설계된 자료구조로, 불필요한 박싱 및 언박싱을 피하고 성능을 최적화시킬 수 있습니다. C#의 System.Collections.Generic 네임스페이스에 포함된 여러 자료구조가 이에 해당합니다."
    },
    {
        "term": "List<T>",
        "description": "List<T>는 일반화 컬렉션의 일종으로, 같은 데이터 형식의 요소를 저장할 수 있는 동적 배열입니다. 요소의 추가, 삭제, 정렬과 같은 메소드가 제공되어 다양한 데이터 처리에 유용합니다."
    },
    {
        "term": "Queue<T>",
        "description": "Queue<T>는 FIFO(First In First Out) 방식으로 데이터를 처리하는 일반화 컬렉션입니다. 이 구조는 첫 번째로 추가된 데이터가 가장 먼저 제거되는 특성을 가지고 있으며, 특정 데이터 형식만을 허용합니다."
    },
    {
        "term": "Stack<T>",
        "description": "Stack<T>는 LIFO(Last In First Out) 방식으로 데이터를 처리하는 일반화 컬렉션입니다. 이 구조는 가장 최근에 추가된 데이터가 가장 먼저 제거되는 특성이 있으며, 각 요소는 정해진 데이터 타입에 맞춰야 합니다."
    },
    {
        "term": "Dictionary<TKey, TValue>",
        "description": "Dictionary<TKey, TValue>는 해시테이블 기반의 일반화 컬렉션으로, 키-값 쌍 형태의 데이터를 저장합니다. 각 키는 고유하며 값은 해당 키와 연관되어 데이터를 빠르게 검색할 수 있는 구조입니다."
    },
    {
        "term": "파일 입출력 (File IO)",
        "description": "파일 입출력(File IO)은 프로그램이 파일 시스템에 접근하여 데이터를 읽고 쓰는 과정을 포함합니다. Unity와 C#에서는 System.IO 네임스페이스를 통해 파일 및 디렉토리를 관리할 수 있습니다."
    },
    {
        "term": "Directory 클래스",
        "description": "Directory 클래스는 파일 시스템에서 디렉토리를 생성, 삭제, 이동, 조회하기 위한 정적 메소드를 제공합니다. 이 클래스를 통해 디렉토리의 경로를 지정하고, 해당 경로에서 수행할 수 있는 다양한 작업을 쉽게 처리할 수 있습니다."
    },
    {
        "term": "DirectoryInfo 클래스",
        "description": "DirectoryInfo 클래스는 디렉토리의 자세한 정보를 제공하며, 인스턴스를 생성하여 해당 디렉토리에 대한 메소드와 프로퍼티를 사용할 수 있습니다. 파일이나 디렉토리에 대한 좀 더 세부적인 조작을 가능하게 합니다."
    },
    {
        "term": "File 클래스",
        "description": "File 클래스는 파일을 생성, 삭제, 이동, 복사, 조회하는 정적 메소드를 제공합니다. 이 클래스는 메모리 상에 인스턴스를 생성하지 않고, 간편하게 파일 작업을 수행할 수 있게 해줍니다."
    },
    {
        "term": "FileInfo 클래스",
        "description": "FileInfo 클래스는 파일에 대한 세부 정보와 메소드를 제공하며, 인스턴스를 생성하여 파일 조작을 수행할 수 있습니다. 파일의 속성이나 메소드에 접근하여 작업하는 데 유용합니다."
    },
    {
        "term": "메소드와 프로퍼티",
        "description": "각 클래스는 다양한 메소드와 프로퍼티를 제공하여 파일 및 디렉토리에 대한 조작을 용이하게 합니다. 예를 들어, Create 메소드는 새로운 파일을 생성하며, Delete 메소드는 파일이나 디렉토리를 삭제하는 데 사용됩니다."
    },
    {
        "term": "데이터 저장 및 읽기",
        "description": "C#에서 파일에 데이터를 저장하고 읽어오는 것은 중요한 기능입니다. 이 과정은 파일을 먼저 열고, 데이터를 기록한 후에 파일을 닫는 순서로 진행되며, 각 메소드의 적절한 사용이 요구됩니다."
    },
    {
        "term": "Copy, Move, Delete 메소드",
        "description": "File과 Directory 클래스는 각각 Copy, Move, Delete 메소드를 제공하여 파일이나 디렉토리를 다른 위치로 복사하거나 이동, 삭제할 수 있습니다. 파일 작업 전에는 반드시 파일이 열려 있지 않아야 하며, 작업 진행 시 예외 처리에 유의해야 합니다."
    },
    {
        "term": "네임스페이스 (Namespace)",
        "description": "C#의 네임스페이스는 클래스들을 그룹화하여 코드의 구조를 조직화하는 데 사용됩니다. System.IO 네임스페이스는 파일과 디렉토리 관리를 위한 클래스를 포함하여 파일 입출력과 관련된 모든 기능을 제공합니다."
    },
    {
        "term": "스트림(Stream)",
        "description": "스트림은 데이터가 컴퓨터와 파일 사이에서 흐르는 통로를 의미하며, 파일의 내용을 읽고 쓰는 데 사용된다. 스트림을 통해 데이터의 순차적 또는 임의적 접근이 가능하며, 이로 인해 다양한 파일 유형을 처리할 수 있다."
    },
    {
        "term": "FileStream Class",
        "description": "FileStream 클래스는 파일에 대한 읽기 및 쓰기 작업을 수행하는 데 사용되는 C# 클래스입니다. 파일 경로와 열기 모드를 설정하여 인스턴스를 생성할 수 있으며, 다양한 방식으로 데이터에 접근할 수 있는 기능을 제공합니다."
    },
    {
        "term": "BinaryWriter, BinaryReader",
        "description": "BinaryWriter는 이진 데이터를 파일 스트림에 기록하기 위한 클래스이며, BinaryReader는 이진 데이터를 파일 스트림에서 읽어오는 클래스입니다. 두 클래스를 사용하여 이진 형식의 데이터를 보다 효율적으로 처리할 수 있습니다."
    },
    {
        "term": "StreamWriter, StreamReader",
        "description": "StreamWriter는 텍스트 데이터를 파일에 기록할 때 사용되는 클래스이며, StreamReader는 파일에서 텍스트 데이터를 읽어오는 클래스입니다. 이들 클래스를 통해 텍스트 파일과의 상호작용이 용이해지며, 일반적으로 잘 알려진 파일 작업에 널리 사용됩니다."
    },
    {
        "term": "직렬화(Serialization)",
        "description": "직렬화는 객체의 상태와 데이터를 일련의 바이트(0과 1)로 변환하는 과정이다. C#에서는 Serializable 어노테이션을 사용하여 직렬화할 객체를 정의하며, 이를 통해 객체의 상태를 파일 등에 저장하고 다시 복원할 수 있게 된다."
    },
    {
        "term": "BinaryFormatter",
        "description": "BinaryFormatter는 C#에서 객체의 직렬화 및 역직렬화를 수행하는 데 사용되는 클래스입니다. 이 클래스를 사용하면 객체를 이진 형식으로 변환하여 파일로 저장하거나, 저장된 이진 파일을 통해 객체를 복원할 수 있습니다."
    },
    {
        "term": "Serializable 어트리뷰트",
        "description": "Serializable 어트리뷰트는 특정 클래스가 직렬화 가능하다는 것을 지정하기 위해 클래스 정의 앞에 추가하는 어트리뷰트입니다. 이 어트리뷰트를 지정한 클래스는 BinaryFormatter를 통해 직렬화 및 역직렬화 작업을 수행할 수 있다."
    },
    {
        "term": "데이터 접근 방식",
        "description": "순차 접근은 데이터를 처음부터 끝까지 순서대로 처리하는 방식이며, 임의 접근은 특정 위치에서 데이터를 읽거나 쓰는 방식입니다. 이를 이해하는 것은 스트림을 사용하는 데 매우 중요한 개념이다."
    },
    {
        "term": "C#",
        "description": "C#은 마이크로소프트에서 개발한 현대적인 객체 지향 프로그래밍 언어로, 유니티 스크립팅에서 주로 사용됩니다. C#은 간결하고 읽기 쉬운 문법을 가지고 있으며, 강력한 타입 안정성과 자동 메모리 관리 기능을 제공합니다."
    },
    {
        "term": "파일 브라우저",
        "description": "파일 브라우저는 사용자가 파일 시스템 내에서 파일 및 폴더를 탐색하고 관리할 수 있도록 돕는 인터페이스입니다. 유니티에서는 C# 스크립트를 통해 현재 디렉토리의 파일 목록을 출력하고, UI를 통해 이를 시각화하여 사용자 경험을 향상할 수 있습니다."
    },
    {
        "term": "디렉토리",
        "description": "디렉토리는 파일 시스템 내에서 파일을 조직하고 관리하기 위한 구조입니다. 각 디렉토리는 여러 개의 파일과 다른 서브 디렉토리를 포함할 수 있으며, 계층 구조를 통해 손쉽게 접근할 수 있도록 돕습니다."
    },
    {
        "term": "Debug.Log",
        "description": "Debug.Log는 유니티에서 디버깅 정보를 콘솔에 출력하는 데 사용되는 메서드입니다. 프로그램의 실행 흐름이나 변수 상태를 확인할 때 매우 유용하며, 개발 중에 발생하는 에러나 경고 메시지를 추적하는 데 사용됩니다."
    },
    {
        "term": "UI",
        "description": "UI(User Interface)는 사용자와 소프트웨어 간의 상호 작용을 위한 시각적인 요소입니다. 유니티에서는 Canvas, Button, Text 등의 UI 요소를 활용하여 사용자가 파일 브라우저와 상호작용할 수 있도록 디자인됩니다."
    },
    {
        "term": "스크롤 뷰",
        "description": "스크롤 뷰는 UI 요소의 콘텐츠가 화면에 모두 표시되지 않을 때, 사용자가 스크롤을 통해 추가 콘텐츠에 접근할 수 있도록 돕는 컴포넌트입니다. 대부분의 파일 브라우저에서는 파일 목록을 표시하기 위해 스크롤 뷰를 활용합니다."
    },
    {
        "term": "UI Scale Mode",
        "description": "UI Scale Mode는 유니티의 Canvas 컴포넌트에서 UI 요소의 비율 및 크기를 조정하는 방법입니다. 'Scale with Screen Size' 모드를 사용하면 다양한 해상도에서도 UI 요소의 크기를 자동으로 조절할 수 있어 다양한 디바이스에서 일관된 사용자 경험을 제공합니다."
    },
    {
        "term": "폴더(Directory) 이동",
        "description": "폴더 이동은 사용자가 현재 작업 중인 디렉토리에서 다른 하위 디렉토리로 또는 상위 디렉토리로 이동하는 기능입니다. 이는 파일 브라우저의 기본 기능 중 하나로, 탐색의 유연성을 제공합니다."
    },
    {
        "term": "디렉토리 컨트롤러",
        "description": "디렉토리 컨트롤러는 파일 브라우저의 핵심 요소로, 선택된 폴더의 정보를 관리하고 폴더 이동, 파일 선택 등의 작업을 처리하는 역할을 수행합니다."
    },
    {
        "term": "Escape 키",
        "description": "Escape 키는 일반적으로 프로그램 사용 중 사용자가 작업을 취소하거나 이전 상태로 되돌아갈 때 사용됩니다. 파일 브라우저에서는 사용자가 현재 폴더를 바탕 화면으로 되돌리는 데 활용됩니다."
    },
    {
        "term": "UpdateInput 메소드",
        "description": "UpdateInput 메소드는 파일 브라우저 내에서 상위 및 하위 폴더로의 이동과 선택된 파일 정보를 출력하는 기능을 담당합니다. 이 메소드는 사용자의 입력에 따라 반응하고 디렉토리 경로를 업데이트합니다."
    },
    {
        "term": "Event System",
        "description": "Unity의 Event System은 다양한 UI와 입력 이벤트를 처리하는 시스템입니다. 파일 브라우저에서는 마우스 이벤트 처리에 사용되며, 인터페이스 반응성을 높이는 데 기여합니다."
    },
    {
        "term": "IPointerEnterHandler",
        "description": "IPointerEnterHandler는 Unity의 인터페이스 중 하나로, 마우스 포인터가 오브젝트에 진입할 때 발생하는 이벤트를 처리합니다. 이를 통해 파일 브라우저에서 마우스 커서에 따라 UI 요소의 시각적인 반응을 구현할 수 있습니다."
    },
    {
        "term": "백스페이스 키",
        "description": "백스페이스 키는 일반적으로 이전 단계로 돌아가는 기능을 수행합니다. 파일 브라우저에서는 사용자가 현재 디렉토리에서 상위 디렉토리로 이동할 때 사용됩니다."
    },
    {
        "term": "파일 정보 출력",
        "description": "파일 정보 출력은 선택된 파일의 전체 경로, 파일 이름 및 확장자와 같은 정보를 사용자에게 제공하는 기능입니다. 유니티에서는 콘솔 로그를 통해 이러한 정보를 디버깅 및 확인할 수 있습니다."
    },
    {
        "term": "File Browser",
        "description": "파일 브라우저는 사용자가 파일 시스템에서 파일을 선택할 수 있도록 도와주는 UI 컴포넌트로, 일반적으로 파일 선택 및 정보를 출력하는 기능을 포함한다."
    },
    {
        "term": "TextMeshPro UGUI",
        "description": "TextMeshPro UGUI는 Unity 내에서 고급 텍스트 렌더링을 지원하는 패키지로, 더 나은 텍스트 품질과 다양한 스타일 옵션을 제공한다."
    },
    {
        "term": "Panel UI",
        "description": "Panel UI는 Unity UI 시스템에서 여러 UI 요소를 그룹화하여 시각적으로 정리하는 패널로, 해당 패널 내에 다른 UI 요소를 배치하여 구성할 수 있다."
    },
    {
        "term": "Vertical Layout Group",
        "description": "Vertical Layout Group는 Unity의 UI 레이아웃 컴포넌트 중 하나로, 자식 UI 요소를 수직으로 정렬하고 자동으로 배치하여 일관된 UI를 만들 수 있게 돕는다."
    },
    {
        "term": "Application.OpenURL",
        "description": "Application.OpenURL은 Unity에서 특정 URL이나 파일 경로를 열기 위해 사용하는 메소드로, 외부 애플리케이션과 연동하거나 파일을 쉽게 열 수 있도록 한다."
    },
    {
        "term": "File Loader",
        "description": "파일 로더는 파일의 정보를 읽어와 UI에 출력하는 역할을 하는 스크립트 또는 컴포넌트로, 파일의 종류에 따라 다른 처리를 수행할 수 있다."
    },
    {
        "term": "유니티 C#",
        "description": "유니티를 사용하여 게임 개발을 할 때의 프로그래밍 언어로, .NET Framework에 기반한 객체 지향 프로그래밍 언어입니다. 게임의 다양한 요소를 제어하고, 사용자와의 인터랙션을 관리하는 데 사용됩니다."
    },
    {
        "term": "Texture2D",
        "description": "유니티에서 2차원 텍스처를 나타내는 데이터 유형으로, 이미지 혹은 비트맵을 메모리에 로드하여 그래픽에서 사용됩니다. 주로 2D 게임 그래픽스와 UI 요소에서 사용되며, 다양한 포맷의 이미지를 지원합니다."
    },
    {
        "term": "상속 및 오버라이드",
        "description": "C#에서 상속은 한 클래스가 다른 클래스의 속성과 메소드를 물려받는 기법로, 오버라이드는 상속한 메소드의 기능을 재정의하여 사용할 수 있도록 합니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다."
    },
    {
        "term": "UI 컴포넌트",
        "description": "사용자 인터페이스의 구성 요소들로, 버튼, 텍스트, 이미지 등 제어 가능성과 사용자와의 상호작용을 제공하는 객체입니다. 유니티에서는 다양한 UI 컴포넌트를 제공하여 직관적인 인터페이스 설계를 지원합니다."
    },
    {
        "term": "Sprite",
        "description": "유니티에서 2D 그래픽을 표시하는 데 쓰이는 구조체로, 주로 Texture2D로부터 생성된 이미지 요소를 가리킵니다. 스프라이트는 위치와 회전, 크기 조정 등을 통해 화면에 표시될 수 있습니다."
    },
    {
        "term": "바이트 배열",
        "description": "기계어로 표현된 데이터를 순차적으로 저장하는 자료구조로, 여러 개의 바이트를 하나의 변수에 저장할 수 있는 형태입니다. 이미지 데이터와 같은 바이너리 정보를 전달하는 데 유용하게 사용됩니다."
    },
    {
        "term": "패널 UI",
        "description": "게임 화면 내에서 특정 목적을 위한 UI 요소를 배치하기 위해 사용되는 레이아웃 컨테이너입니다. 비주얼 요소들을 그룹화하여 사용자에게 필요한 정보를 한눈에 확인할 수 있도록 도와줍니다."
    },
    {
        "term": "정보 출력",
        "description": "선택한 이미지 파일의 메타데이터(예: 파일 이름, 해상도, 크기)를 사용자에게 시각적으로 보여주는 과정으로, 게임의 인터페이스에 정보를 통합해 사용자 경험을 개선하는 데 중요합니다."
    },
    {
        "term": "MP3 파일",
        "description": "MP3는 디지털 오디오 형식으로, 일반적으로 음악 파일에 사용됩니다. MP3는 손실 압축을 사용하는 오디오 파일 형식으로, 파일 크기를 줄이면서도 상대적으로 양호한 음질을 유지할 수 있어 매우 인기가 있습니다."
    },
    {
        "term": "UI 패널",
        "description": "UI 패널은 사용자 인터페이스에서 정보를 표시하고 사용자와 상호작용할 수 있는 공간을 제공합니다. Unity에서 UI 패널은 다양한 UI 요소(버튼, 슬라이더 등)를 포함할 수 있으며, 사용자 경험을 최적화하는 데 주요 역할을 합니다."
    },
    {
        "term": "오디오 소스",
        "description": "오디오 소스는 Unity에서 음향을 재생하기 위해 사용하는 컴포넌트입니다. 게임 오브젝트에 추가하여 특정 오디오 클립을 재생하고, 그 성질을 조절할 수 있습니다. 예를 들어, 소리의 볼륨과 피치를 변경하거나 반복재생 여부를 설정할 수 있습니다."
    },
    {
        "term": "버튼 이벤트",
        "description": "버튼 이벤트는 UI 요소인 버튼 클릭과 같은 사용자 입력을 감지하고 처리하는 메커니즘입니다. Unity에서는 버튼 컴포넌트의 OnClick() 메소드를 통해 특정 함수를 호출해 이벤트를 처리할 수 있습니다."
    },
    {
        "term": "플러그인",
        "description": "플러그인은 Unity 프로젝트에 추가하여 특정 기능이나 기술을 통합할 수 있는 외부 소프트웨어 모듈입니다. 플러그인은 일반적으로 타사 개발자에 의해 만들어지며, Unity의 기본 기능을 보완하거나 확장하는 데 사용됩니다."
    },
    {
        "term": "유니티(UNITY)",
        "description": "유니티는 실시간 3D 및 2D 콘텐츠 제작을 위한 크로스 플랫폼 게임 엔진으로, 다양한 운영체제에서 게임 및 시뮬레이션을 개발할 수 있도록 지원하는 소프트웨어이다. 유니티는 신속한 프로토타이핑과 독창적인 높은 품질의 작업을 가능하게 하며, C# 스크립팅을 사용하여 다양한 기능을 구현할 수 있다."
    },
    {
        "term": "파일 브라우저(File Browser)",
        "description": "파일 브라우저는 사용자가 파일 시스템 내에서 파일을 선택할 수 있도록 돕는 사용자 인터페이스(UI)를 말한다. 유니티에서는 사용자가 특정 파일을 선택하게 하는 기능을 구현할 때 필요한 컴포넌트를 설계해야 하며, 이를 통해 MP4 파일과 같은 특정 형식의 파일을 선택하고 사용할 수 있게 된다."
    },
    {
        "term": "MP4 파일",
        "description": "MP4는 MPEG-4 Part 14의 약어로, 비디오 및 오디오 데이터 저장을 위한 디지털 멀티미디어 컨테이너 포맷이다. 이 포맷은 다양한 기기와 플랫폼에서 호환성이 뛰어나며, 비디오 스트리밍 및 다운로드에 자주 사용된다."
    },
    {
        "term": "VideoPlayer",
        "description": "유니티의 VideoPlayer 컴포넌트는 비디오 파일을 재생하는 용도로 사용되며, 다양한 설정을 통해 재생, 일시 정지, 정지 기능을 제공한다. 이를 통해 게임이나 어플리케이션 내에서 비디오 콘텐츠를 쉽게 구현할 수 있다."
    },
    {
        "term": "RawImage",
        "description": "RawImage는 유니티 UI 시스템에서 이미지(Texture)를 표시하기 위한 컴포넌트이다. 비디오 출력이 필요한 공간에 사용되어 비디오 재생 시 화면에 비디오는 프레임을 그리는 데 활용된다."
    },
    {
        "term": "렌더 텍스처(Render Texture)",
        "description": "렌더 텍스처는 비디오 또는 기타 렌더링 작업의 결과를 저장할 수 있는 텍스처다. 주로 카메라의 뷰를 다른 텍스처에 렌더링하는 데 사용하며, 비디오 재생과 같은 상황에서 비디오 프레임을 화면에 출력하는 데 적합하다."
    },
    {
        "term": "코루틴(Coroutine)",
        "description": "유니티에서 코루틴은 특정 함수의 실행을 일시 중지하고 나중에 재개할 수 있는 기능을 제공하는 메커니즘이다. 이를 통해 시간이 소요되는 작업을 효율적으로 처리하며, 예를 들어 비디오 플레이어의 재생 시간을 업데이트하거나 UI 변화를 순차적으로 수행할 수 있다."
    },
    {
        "term": "Slider",
        "description": "슬라이더는 UI에서 특정 값의 범위를 시각적으로 표현하고 조작할 수 있는 컴포넌트로, 일반적으로 비디오 플레이어의 재생 위치를 표시하고 조정하는 데 사용된다."
    },
    {
        "term": "UI 갱신",
        "description": "UI 갱신은 사용자 인터페이스의 내용을 변경하여 최신 상태를 반영하는 과정이다. 비디오 플레이어의 UI는 재생 중인 영상의 정보(예: 이름, 재생 시간 등)를 실시간으로 갱신하여 사용자에게 정보를 제공한다."
    },
    {
        "term": "Minimap Camera",
        "description": "미니맵 카메라는 게임의 특정 영역을 탐지하여 그 정보를 캡처하는 카메라입니다. 일반적으로 위에서 내려다보는 탑뷰 시점으로 설정되며, 이 카메라는 미니맵 UI 생성에 필수적입니다."
    },
    {
        "term": "UI Panel",
        "description": "UI 패널은 Unity의 UI 시스템에서 사용자 인터페이스의 구성 요소로, 게임 내에서 정보나 기능을 시각적으로 제공하는데 사용됩니다. 미니맵 UI를 구성할 때 기본적으로 Canvas 내에 생성됩니다."
    },
    {
        "term": "Canvas Scaler",
        "description": "Canvas Scaler는 Unity UI에서 캔버스의 크기를 조절하는 컴포넌트입니다. 화면 해상도에 따라 UI 요소의 크기를 조정할 수 있어 다양한 디바이스에서 일관된 사용자 경험을 제공합니다."
    },
    {
        "term": "Culling Mask",
        "description": "Culling Mask는 Unity 카메라의 설정으로, 카메라가 렌더링할 레이어를 선택합니다. 이를 활용하여 특정 오브젝트만 보이도록 설정할 수 있으며, 미니맵에서는 메인 카메라의 레이어를 비활성화하여 필요 없는 요소를 숨기는 데 사용됩니다."
    },
    {
        "term": "Mask",
        "description": "Mask는 Unity의 UI 요소로, 특정 부분만 표시하거나 숨길 수 있는 기능을 제공합니다. 미니맵 UI에서 사용하여 미니맵의 외부 경계를 정의하거나 영역을 제한하는 데 중요합니다."
    },
    {
        "term": "HP (Hit Points)",
        "description": "HP는 캐릭터의 생명력을 나타내며, 피해를 받을 경우 감소합니다. HP가 0이 되면 캐릭터는 더 이상 생존할 수 없게 됩니다. 게임 디자인에서는 플레이어와 적 캐릭터의 전투 및 상호작용을 위해 필수적인 요소입니다."
    },
    {
        "term": "MP (Mana Points)",
        "description": "MP는 마법이나 특별 능력을 사용하기 위해 필요한 자원입니다. 캐릭터가 스킬을 사용할 때마다 소모되며, 회복하거나 특정 아이템을 통해 재충전할 수 있습니다. RPG 게임의 마법직업이나 특수능력 보유 캐릭터에게 중요한 요소입니다."
    },
    {
        "term": "Entity Class",
        "description": "게임 내 모든 캐릭터의 공통된 속성과 행동을 정의하기 위해 설계된 클래스입니다. 엔티티 클래스는 이름, 레벨, 공격력, 방어력 등의 기본 데이터를 포함하며, 이를 상속받아 플레이어와 적 클래스를 구현합니다."
    },
    {
        "term": "Slider UI",
        "description": "HP, MP와 같은 수치를 시각적으로 표현하는 UI 요소입니다. 사용자가 현재 상태를 직관적으로 파악할 수 있도록 도와주며, 게임에서 자주 사용되는 방식입니다."
    },
    {
        "term": "Text UI",
        "description": "단순히 텍스트 정보를 표시하는 UI 요소로, 슬라이더와 함께 사용되어 플레이어의 상태 데이터를 명확히 전달합니다. 예를 들어, 현재 HP 또는 MP의 절대 수치를 나타낼 수 있습니다."
    },
    {
        "term": "Unity Engine",
        "description": "Unity는 게임 개발에 사용되는 인기 있는 통합 개발 환경(IDE)으로, 2D 및 3D 게임 제작에 필요한 다양한 툴과 기능을 제공합니다. Unity는 상호작용적인 게임 UI 구현을 위한 강력한 기능을 갖춘 엔진입니다."
    },
    {
        "term": "Dialog System",
        "description": "대화 시스템(Dialog System)은 사용자와 NPC(Non-Playable Character) 간의 상호작용을 가능하게 하는 소프트웨어 컴포넌트로, 주로 게임 및 애플리케이션에서 스토리텔링이나 정보 전달을 위해 사용된다. 대화의 흐름, 선택지 제공, 대화의 역사적 이력 저장 등 다양한 기능을 구현할 수 있다."
    },
    {
        "term": "Unity UI",
        "description": "Unity UI는 Unity 엔진 내에서 사용자 인터페이스를 만들기 위한 도구로, 버튼, 슬라이더, 패널 등 다양한 UI 요소를 쉽게 생성 및 관리할 수 있다. 이를 통해 개발자는 게임의 UI/UX를 보다 직관적으로 디자인할 수 있다."
    },
    {
        "term": "Script",
        "description": "스크립트(Script)는 Unity에서 C# 언어로 작성되는 프로그램 코드로, 게임의 로직, 오브젝트의 동작 및 이벤트 처리를 정의하는 데 사용된다. 대화 시스템에서는 대화 흐름, 등장인물의 상태 관리 등을 구현하는 데 활용된다."
    },
    {
        "term": "Typing Effect",
        "description": "타이핑 효과는 사용자가 대사를 입력하는 것처럼 텍스트가 한 글자씩 나타나는 애니메이션으로, 대화의 몰입감을 높이며 사용자의 집중을 유도하는데 효과적이다. 이러한 효과는 `Coroutine` 기능이나 타이머를 활용하여 구현된다."
    },
    {
        "term": "Alpha Blinking",
        "description": "알파 블링킹은 UI 요소의 투명도를 주기적으로 변화시켜 깜빡이는 효과를 구현하는 기법으로, 주로 커서나 강조해야 할 메뉴 항목 등에 적용된다. Unity에서는 `CanvasGroup`이나 `Image` 컴포넌트를 통해 이 효과를 쉽게 생성할 수 있다."
    },
    {
        "term": "Excel Importer",
        "description": "Unity에서 엑셀 데이터를 불러오는 기능을 가진 툴로, 엑셀 파일에 저장된 데이터를 게임 내에서 쉽게 활용할 수 있도록 해줍니다."
    },
    {
        "term": "npoi",
        "description": "아파치 재단에서 개발한 C# 라이브러리로, Microsoft Office 파일 형식을 읽고 쓸 수 있도록 지원합니다. Excel 파일 등 여러 오피스 포맷의 데이터 처리를 용이하게 합니다."
    },
    {
        "term": "스크립트(Script)",
        "description": "게임에서 특정 기능이나 동작을 정의하는 코드 파일입니다. Unity에서는 C# 언어를 주로 사용하여 게임 로직을 구현합니다."
    },
    {
        "term": "Asset",
        "description": "Unity 프로젝트에서 사용되는 모든 자산을 의미하며, 모델, 이미지, 사운드 파일 등 다양한 형태의 데이터를 포함합니다. 엑셀 데이터도 특정 형태의 Asset으로 관리될 수 있습니다."
    },
    {
        "term": "DB(Entity Class)",
        "description": "Game 데이터베이스의 구성 요소로, 각 데이터 항목(예: 엑셀의 행에 해당)의 구조를 정의하며 그 데이터에 접근하기 위한 클래스입니다."
    },
    {
        "term": "재임포트(Reimport)",
        "description": "Unity에서 수정된 Asset을 다시 불러오는 과정으로, 엑셀 파일이 수정되면 그 변경 내용이 Unity 프로젝트에 반영되도록 합니다."
    },
    {
        "term": "Keep In Screen UI",
        "description": "Unity에서 UI 요소가 화면 경계를 넘어가지 않도록 유지하는 기능을 구현하는 것으로, UI 컴포넌트가 사용자 인터페이스에서 자연스럽고 편리하게 사용될 수 있도록 보장하는 기술."
    },
    {
        "term": "RectTransform",
        "description": "Unity의 UI 시스템에서 UI 요소의 위치 및 크기 조정을 위한 전용 클래스. RectTransform은 2D 공간에서 UI 요소의 사각형 경계와 관련된 속성을 제공합니다."
    },
    {
        "term": "TransformPoint",
        "description": "GameObject의 로컬 공간 좌표를 월드 좌표 시스템으로 변환하는 메소드. UI 컴포넌트가 화면 내에서 올바른 위치에 표시되도록 조정하는 데 사용됨."
    },
    {
        "term": "Mathf.Clamp",
        "description": "주어진 값을 최소 및 최대 값 사이로 제한하는 유틸리티 메소드. UI 요소가 지정된 경계를 넘어가지 않도록 값을 조정하는 데 유용합니다."
    },
    {
        "term": "UI 오프셋",
        "description": "UI 요소의 위치를 조정하기 위해 설정한 추가적인 변위. 이 오프셋을 활용하여 UI 요소가 원하는 위치에 정확하게 배치되도록 합니다."
    },
    {
        "term": "스크립트화",
        "description": "Unity의 스크립트를 작성하여 사용자 정의 기능을 추가하는 과정으로, 효과적인 UI 제어 및 상호작용을 구현할 수 있도록 돕습니다."
    },
    {
        "term": "게임 UI",
        "description": "비디오 게임 내에서 사용자 인터페이스를 구성하는 모든 요소. 이는 메뉴, 드래그&드롭 기능, 인벤토리 등의 형식을 포함합니다."
    },
    {
        "term": "월드 좌표 시스템",
        "description": "3D 공간에서 모든 오브젝트의 위치를 표현하는 시스템으로, 각 오브젝트는 이 시스템 내에서 고유한 좌표를 가집니다."
    },
    {
        "term": "UI 크기 조정",
        "description": "UI 요소가 화면 내에서 적절한 크기와 위치를 유지하도록 조정하는 과정. UI의 크기를 화면 크기와 적절히 비교하여 제어하는 것이 중요합니다."
    },
    {
        "term": "Unity 엔진",
        "description": "게임 개발 및 실시간 3D 콘텐츠 제작을 위한 강력한 크로스 플랫폼 엔진. Unity는 직관적인 UI 시스템과 다양한 개발 도구를 제공합니다."
    },
    {
        "term": "RTS (Real-Time Strategy)",
        "description": "RTS는 실시간 전략 게임의 약자로, 플레이어가 실시간으로 자원을 수집하고 군대를 구성하여 적과 대결하는 형태의 게임 장르입니다. 전략적 사고와 빠른 반응이 요구됩니다."
    },
    {
        "term": "유닛 제어 (Unit Control)",
        "description": "유닛 제어는 RTS 게임에서 특정 유닛을 선택하고 이동시키는 메커니즘을 의미합니다. 이는 클릭 및 드래그를 통해 이루어지며, 플레이어의 전략적 결정을 반영합니다."
    },
    {
        "term": "마우스 클릭 선택 (Mouse Click Selection)",
        "description": "마우스 클릭 선택은 특정 오브젝트를 클릭하여 선택하는 방법으로, RTS 게임에서 개별 유닛이나 구조물 등을 선택하기 위해 사용됩니다."
    },
    {
        "term": "마우스 드래그 선택 (Mouse Drag Selection)",
        "description": "마우스 드래그 선택은 화면의 특정 부분을 드래그하여 그 범위 내의 유닛들을 선택하는 방법입니다. 이는 여러 유닛을 동시에 선택할 수 있게 해 줍니다."
    },
    {
        "term": "이동 기능 (Movement Functionality)",
        "description": "이동 기능은 선택된 유닛이 플레이어의 마우스 클릭 위치로 이동하도록 구현하는 기능입니다. 이 과정에서 위치의 유효성 및 충돌 체크가 이루어집니다."
    },
    {
        "term": "3D 오브젝트 생성",
        "description": "게임 개발의 기초로, 게임 내에서 사용될 모델이나 캐릭터를 생성하는 과정입니다. Unity에서는 제공되는 프리팹이나 기본형 오브젝트를 활용하여 쉽게 생성할 수 있습니다."
    },
    {
        "term": "충돌 체크 (Collision Check)",
        "description": "게임에서 유닛이나 오브젝트가 다른 오브젝트와 충돌하는지를 판단하는 시스템입니다. 유효한 이동 경로를 설정하는 데 필수적입니다."
    },
    {
        "term": "유닛 선택 마커 (Unit Selection Marker)",
        "description": "선택된 유닛을 시각적으로 표시하기 위해 활성화되는 마커입니다. 사용자는 이를 통해 현재 선택된 유닛을 쉽게 인지할 수 있습니다."
    },
    {
        "term": "스크립트 (Script)",
        "description": "Unity에서 오브젝트의 동작을 정의하는 코드 파일입니다. C# 언어를 주로 사용하며, 각 오브젝트의 동작이나 속성을 프로그램할 수 있습니다."
    },
    {
        "term": "FSM (Finite State Machine)",
        "description": "FSM은 시스템의 상태를 유한한 개수의 상태로 나누어 각 상태 간의 전이를 정의하는 모델입니다. 게임에서는 캐릭터의 행동을 대기, 걷기, 공격 등으로 분류하여 상태를 쉽게 관리할 수 있게 합니다."
    },
    {
        "term": "상태 전환 도표",
        "description": "상태 전환 도표는 FSM의 각 상태와 전환 조건을 시각적으로 표현한 다이어그램입니다. 각 상태는 노드 형태로 나타내며, 전환 조건과 방향은 화살표로 표시되어 시스템의 흐름을 이해하기 쉽게 합니다."
    },
    {
        "term": "플레이어 컨트롤러",
        "description": "플레이어 컨트롤러는 사용자의 입력을 받아 캐릭터의 상태를 변경하는 스크립트입니다. FSM의 구현에 있어 중요한 역할을 하며, 게임의 반응성을 높이는 데 기여합니다."
    },
    {
        "term": "재사용 가능한 상태 클래스",
        "description": "재사용 가능한 상태 클래스는 여러 개의 에이전트가 동일한 상태를 공유하여 사용할 수 있도록 정의된 클래스입니다. 이는 코드의 중복을 줄이고, 유지보수를 용이하게 합니다."
    },
    {
        "term": "에이전트",
        "description": "에이전트는 특정 행동을 수행하는 캐릭터나 객체를 의미합니다. 게임 내에서는 플레이어 캐릭터, 적 NPC 등 여러 형태의 에이전트가 존재하며, FSM을 통해 각자의 행동을 관리합니다."
    },
    {
        "term": "검사 시스템",
        "description": "검사 시스템은 FSM의 각 상태에서 수행할 작업이나 조건을 평가하는 시스템입니다. 이를 통해 상태 전환의 조건을 효율적으로 관리할 수 있습니다."
    },
    {
        "term": "유한 상태 머신 (FSM; Finite State Machine)",
        "description": "유한 상태 머신은 개체의 상태를 관리하고 상태 간 전환을 정의하는 개념적인 모델입니다. FSM은 게임 및 소프트웨어 개발에서 에이전트의 동작을 직관적으로 구현할 수 있게 해줍니다. 각 상태는 특정 행동을 정의하며, 조건에 따라 다른 상태로 전환될 수 있습니다."
    },
    {
        "term": "상태 디자인 패턴 (State Pattern)",
        "description": "상태 디자인 패턴은 객체의 상태에 따라 행동을 다르게 처리하는 객체 지향 디자인 패턴입니다. 각 상태를 클래스로 구현하여 객체가 상태에 따라 행동을 변경할 수 있도록 하며, 상태 전환의 복잡성을 줄이는 데 도움을 줍니다. 이를 통해 코드 유지 관리와 확장성이 개선됩니다."
    },
    {
        "term": "UML 클래스 다이어그램",
        "description": "UML(통합 모델링 언어) 클래스 다이어그램은 시스템의 구조를 시각적으로 표현하는 도구입니다. FSM의 각 상태와 클래스 간의 관계를 명시적으로 나타내어, 전체적인 설계를 이해하고 문제를 해결하는 데 도움을 줍니다. 이를 통해 개발자는 복잡한 시스템을 보다 쉽게 관리할 수 있습니다."
    },
    {
        "term": "상태 (State)",
        "description": "상태는 FSM에서 에이전트가 현재 할 수 있는 행동이나 상태를 나타냅니다. 각 상태는 특정 작업을 수행하며, 필요에 따라 다른 상태로 전환될 수 있습니다. 예를 들어, 촬영된 영상에서는 'RestAndSleep', 'StudyHard', 'TakeExam', 'PlayAGame', 'HitTheBottle'와 같은 다양한 상태가 존재합니다."
    },
    {
        "term": "State Class",
        "description": "State Class는 개별 상태의 특성과 행동을 정의하는 클래스입니다. 상태를 객체 지향적으로 모델링하여, 다양한 에이전트가 사용할 수 있도록 재사용 가능한 코드 구조를 제공하곤 합니다."
    },
    {
        "term": "StateMachine Class",
        "description": "상태 머신을 관리하는 클래스입니다. 상태 전이, 현재 상태 관리, 새로운 상태를 설정하는 기능 등을 구현하여 상태 관리의 중앙 집중화를 도와줍니다."
    },
    {
        "term": "Unemployed Agent State",
        "description": "주어진 에이전트가 실업 상태일 때의 행동과 특성을 정의하는 상태입니다. 상태 열거형을 통해 다양한 행동을 Enum으로 표현하고 관리할 수 있습니다."
    },
    {
        "term": "Global State",
        "description": "시스템 전체에서 적용되는 공통적인 상태를 정의하는 개념입니다. 전역 상태를 통해 시스템의 다양한 상태 간의 의존성을 관리하고, 여러 컴포넌트 간의 상호작용을 용이하게 합니다."
    },
    {
        "term": "State Split",
        "description": "기존 상태에서 다른 상태로의 전이를 손쉽게 관리하기 위해 특정 상태를 세분화하는 기술입니다. 이를 통해 더 유연하고 확장 가능한 상태 관리가 가능합니다."
    },
    {
        "term": "Singleton Pattern",
        "description": "유일 객체 디자인 패턴으로, 특정 클래스의 인스턴스가 단 하나만 존재하도록 보장합니다. 이를 통해 전역 상태나 관리자를 안전하게 유지할 수 있습니다."
    },
    {
        "term": "T-type Generic Programming",
        "description": "C#에서 제네릭 타입을 사용하는 프로그래밍 기법으로, 특정한 타입에 종속되지 않고 다양한 타입의 데이터를 다룰 수 있도록 해줍니다. 이를 통해 코드의 재사용성과 유연성을 높일 수 있습니다."
    },
    {
        "term": "유한 상태 기계 (FSM)",
        "description": "유한 상태 기계는 특정 상태를 이동하며 동작하는 모델로, 주로 게임 개발과 인공지능에서 사용된다. FSM은 각 상태에서의 행동을 정의하여, 상태 간의 전이를 통해 시스템의 동작을 관리한다."
    },
    {
        "term": "메시지 처리",
        "description": "메시지 처리는 객체 간의 통신을 위한 기법으로, 이벤트 발생 시 해당 메시지를 수신한 객체가 적절한 방식으로 반응하도록 돕는다. 이를 통해 시스템의 상태나 행동을 조정할 수 있다."
    },
    {
        "term": "딕셔너리 자료 구조",
        "description": "딕셔너리 자료 구조는 키-값 쌍으로 데이터에 접근하는 자료 구조로, 효율적인 데이터 검색과 관리가 가능하다. FSM에서는 메시지 디스패치 시 지연 발송된 메시지를 수집하고 관리하는 데 사용된다."
    },
    {
        "term": "이벤트 대응 형태",
        "description": "이벤트 대응 형태는 객체가 특정 이벤트에 반응하여 행동하는 방식을 나타낸다. 객체가 메시지를 수신하기 전까지 다른 작업을 수행하다가, 메시지를 받으면 그에 맞는 행동을 하게 된다."
    },
    {
        "term": "텔레그램 스크립트",
        "description": "텔레그램 스크립트는 사용자 정의 구조체를 생성하여 객체 간의 정보 전송을 위한 데이터 구조를 설계하는 코드이다. 이 스크립트는 정보의 등록, 검색 및 삭제 메소드를 포함하여 메시지의 높은 유연성을 제공한다."
    },
    {
        "term": "게임 컨트롤러",
        "description": "게임 컨트롤러는 게임 내의 다양한 요소들이 상호작용하는 방식을 관리하는 중앙 처리 단위이다. 에이전트 정보 등록을 통해 게임의 상태를 최적화하고, 메시지 전송 시스템의 유기적인 통합을 지원한다."
    },
    {
        "term": "상태별 메시지 리시버 클래스",
        "description": "상태별 메시지 리시버 클래스는 각 에이전트의 상태에 따라 수신할 수 있는 메시지를 정의하는 클래스이다. 이 클래스를 통해 상태 변화에 따라 동작을 다르게 하고, FSM의 동적 처리를 가능하게 한다."
    },
    {
        "term": "유니티 엔진",
        "description": "유니티 엔진은 3D 및 2D 게임 개발을 위한 크로스 플랫폼 게임 엔진으로, C# 프로그래밍 언어를 사용하여 게임을 개발할 수 있도록 지원한다. 다양한 기능과 리소스를 제공하여 개발자들이 효율적으로 게임을 제작할 수 있게 한다."
    },
    {
        "term": "룰렛 시스템",
        "description": "룰렛 시스템은 주로 도박 및 게임에서 사용되는 랜덤 아이템 선택 메커니즘으로, 사용자에게 임의의 결과를 제공하는 기능을 수행한다. 설정된 룰렛의 조각이나 아이템에서 사용자에게 하나를 무작위로 선택하게 하는 구조로 설계된다."
    },
    {
        "term": "룰렛 피스 데이터 스크립트",
        "description": "룰렛 피스 데이터 스크립트는 룰렛의 각 조각에 필요한 정보를 정의하는 역할을 한다. 각 조각의 아이콘, 설명, 등장 확률을 포함하여 게임 로직을 통해 랜덤 선택 메커니즘을 위한 기반 데이터를 제공한다."
    },
    {
        "term": "가중치 기반 랜덤 선택",
        "description": "가중치 기반 랜덤 선택은 각 아이템이 선택될 확률을 조정하기 위해 가중치를 부여하는 방식이다. 사용자가 정의한 가중치에 따라 특정 아이템이 선택될 가능성이 높아지며, 이를 통해 게임의 다양성과 예측 불가능성을 높인다."
    },
    {
        "term": "애니메이션 커브",
        "description": "애니메이션 커브는 시간에 따라 변화하는 애니메이션의 길이, 속도, 감속 등을 설정하는 도구이다. 룰렛의 회전 속도와 시간 조정을 위한 중요한 요소로, 사용자에게 자연스럽고 흥미로운 사용자 경험을 제공한다."
    },
    {
        "term": "게임 뷰 해상도",
        "description": "게임 뷰 해상도는 개발자가 게임을 테스트할 때 화면에 표시되는 해상도를 설정하는 옵션이다. FHD(1920x1080)와 같은 해상도 설정은 게임의 성능과 시각적 품질을 확인하는 데 중요하다."
    },
    {
        "term": "2D 플랫포머(2D Platformer)",
        "description": "2D 플랫포머 게임은 2차원 평면에서 캐릭터가 점프하고 이동하며 장애물을 피해 나가는 형태의 게임 장르입니다. 이 게임은 주로 좌우 이동과 점프를 주요 플레이 요소로 하며, 레벨 디자인과 물리적 상호작용이 중요합니다."
    },
    {
        "term": "Unity 엔진( Unity Engine)",
        "description": "Unity는 다양한 플랫폼을 대상으로 게임을 개발할 수 있도록 돕는 크로스 플랫폼 게임 엔진입니다. 직관적인 UI와 강력한 커뮤니티 지원, 다양한 플러그인과 자원을 활용해 신속하게 게임을 프로토타입하고 제작할 수 있습니다."
    },
    {
        "term": "Raycast(레이캐스트)",
        "description": "Raycast는 물리적인 공간에서 가상의 레이(선)를 발사하여 충돌 여부를 감지하는 기술입니다. 유니티에서 이 기능은 주로 캐릭터가 바닥 등 특정 오브젝트와 충돌하는지를 판단하는 데 사용되며, 2D 및 3D 게임에서 자주 활용됩니다."
    },
    {
        "term": "움직임 스크립트(Movement Script)",
        "description": "플레이어 캐릭터의 이동을 제어하는 코드를 담은 스크립트입니다. 이 스크립트는 입력에 따라 캐릭터의 속도를 조정하고, 스프라이트 애니메이션과 상호작용을 관리하는 역할을 합니다."
    },
    {
        "term": "Rigidbody2D(리기드바디2D)",
        "description": "Unity에서 2D 물리 엔진을 사용할 때 물체의 물리적 행동을 정의하는 컴포넌트입니다. 즉, 가속이나 마찰, 중력을 적용받아 물체의 움직임을 물리적으로 표현합니다. 플레이어와 환경의 상호작용을 실현하는 핵심 요소입니다."
    },
    {
        "term": "점프 메커니즘(Jump Mechanism)",
        "description": "플레이어가 점프 행동을 실행하기 위한 알고리즘입니다. 점프의 강도와 횟수를 조절하여 게임의 사다리 요소를 다양화하며, 스페이스 키와 같은 입력 이벤트를 통해 점프 행동을 대체합니다."
    },
    {
        "term": "Multi-Jump(멀티 점프)",
        "description": "한 번의 점프 후 추가로 점프를 할 수 있는 기능으로, 파르리나 특수한 지형에서 플레이어에게 더 많은 기회를 제공합니다. 멀티 점프 기능은 게임플레이의 다양성을 부여하고 도전적인 요소를 생성합니다."
    },
    {
        "term": "Debugging(디버깅)",
        "description": "소프트웨어에서 오류 및 버그를 찾고 수정하는 과정입니다. Unity에서는 Gizmos와 같은 도구를 활용하여 개발자가 유닛 테스트를 수행하며, 레이캐스트와 같은 변수가 어떻게 작동하는지를 시각적으로 확인할 수 있습니다."
    },
    {
        "term": "Collider(콜라이더)",
        "description": "오브젝트가 물리적으로 다른 오브젝트와 충돌할 수 있도록 하는 물리적 경계를 정의하는 컴포넌트입니다. Unity에서는 Box Collider 2D를 사용하여 2D 공간에서 적절한 충돌 처리를 지원합니다."
    },
    {
        "term": "Input Handling(입력 처리)",
        "description": "게임 플레이어의 입력을 인식하고 처리하는 방법으로, 마우스 클릭, 키보드 입력 및 게임 패드와 같은 다양한 입력 장치를 관리하여 게임의 인터랙션을 구현합니다."
    },
    {
        "term": "격자 맵 (Grid Map)",
        "description": "게임 개발에서 '격자 맵'은 정해진 간격으로 나누어진 평면적인 공간을 지칭하며, 각 칸이 게임에서 이동 가능한 영역을 의미합니다. 이를 통해 플레이어는 특정 위치에 격자 단위로 정렬된 형태로 이동하게 되며, 주로 전략 게임이나 퍼즐 게임에서 사용됩니다."
    },
    {
        "term": "부드러운 이동 (Smooth Movement)",
        "description": "부드러운 이동은 게임 캐릭터나 오브젝트가 위치를 이동할 때, 급격한 변화 없이 점진적으로 진행되도록 하는 기법입니다. 일반적으로 Lerp(Linear Interpolation) 함수를 사용하여 이전 위치와 목표 위치 사이를 매끄럽게 전환하는 방식으로 구현됩니다."
    },
    {
        "term": "코루틴 (Coroutine)",
        "description": "코루틴은 Unity에서 비동기적으로 실행되는 함수로, 주로 시간이 걸리는 연산을 분할하여 수행할 때 사용됩니다. 이를 통해 게임의 성능을 저하시키지 않고, 특정 연산을 여러 프레임에 걸쳐 나누어 실행할 수 있습니다."
    },
    {
        "term": "Vector3.Lerp",
        "description": "Vector3.Lerp는 Unity에서 두 벡터 간의 선형 보간을 수행하는 함수입니다. 이 함수를 사용하면 지정된 두 벡터 사이를 시간에 따라 부드럽게 이동하게 할 수 있으며, 이동의 비율을 입력받아 현재 위치와 목표 위치 사이의 중간값을 계산합니다."
    },
    {
        "term": "Input.GetAxisRaw",
        "description": "Unity의 Input.GetAxisRaw는 사용자 입력을 수치로 반환하는 함수로, 주로 키보드나 게임패드의 입력을 처리하는 데 사용됩니다. 이 함수는 부드러운 입력 대신 강력하고 즉각적인 반응을 원할 때 유용합니다."
    },
    {
        "term": "Movement2D 스크립트",
        "description": "Movement2D 스크립트는 2D 게임에서 오브젝트의 이동을 제어하는 스크립트로, 방향 변수 및 이동 상태 변수를 포함하여 사용자의 입력에 따라 대각선 및 직선 이동을 구현할 수 있는 기반을 제공합니다."
    },
    {
        "term": "MoveTime",
        "description": "MoveTime은 오브젝트가 한 위치에서 다른 위치로 이동하는 데 소요되는 시간을 정의하는 변수입니다. 이 값을 통해 이동의 속도를 결정할 수 있습니다."
    },
    {
        "term": "난수 (Random Number)",
        "description": "난수는 특정한 규칙 없이 발생하는 숫자로, 컴퓨터 프로그래밍에서는 주로 임의의 값이나 이벤트 발생 지점에서 다양성을 제공하는 데 사용된다."
    },
    {
        "term": "겹치지 않는 난수 (Non-Overlapping Random Number)",
        "description": "겹치지 않는 난수는 변수의 값들이 서로 중복되지 않는 특정한 범위 내에서 무작위로 선택된 숫자들을 의미하는데, 게임 개발 및 알고리즘에서 자주 사용된다."
    },
    {
        "term": "유틸리티 클래스 (Utility Class)",
        "description": "유틸리티 클래스는 특정한 기능을 제공하는 메소드 집합으로, 일반적으로 상태를 가지지 않으며 메소드를 스태틱으로 정의하여 언제 어디서든 쉽게 사용할 수 있도록 설계된다."
    },
    {
        "term": "배열 (Array)",
        "description": "배열은 동일한 데이터 타입의 여러 값을 저장할 수 있는 자료구조로, 메모리 상에서 연속적으로 배치되어 접근 속도가 빠르다."
    },
    {
        "term": "반복문 (Loop)",
        "description": "반복문은 특정 조건을 만족할 때까지 특정 블록의 코드를 반복적으로 실행할 수 있게 해주는 프로그래밍 구조로, 효율적 코드 작성에 중요하다."
    },
    {
        "term": "디버그 로그 (Debug Log)",
        "description": "디버그 로그는 주요 변수의 상태 및 실행 흐름을 출력하여 개발자가 프로그램의 동작 과정을 이해하고 오류를 찾아 수정하는 데 도움을 주는 출력문이다."
    },
    {
        "term": "Primitive Object",
        "description": "프리미티브 오브젝트는 3D 컴퓨터 그래픽스에서 기본적인 형상을 나타내며, 일반적으로 삼각형, 사각형 등으로 구성된다. 이러한 오브젝트는 복잡한 메쉬를 생성하는 기본 단위로 사용된다."
    },
    {
        "term": "Mesh",
        "description": "메쉬는 3D 오브젝트의 표면을 구성하는 정점, 에지, 면을 집합적으로 나타낸다. 메쉬는 3D 모델의 기하학적 구조를 정의하고, 게임 및 애니메이션 제작에서 필수적인 요소로 작용한다."
    },
    {
        "term": "Vertex",
        "description": "정점(vertex)은 메쉬의 한 점으로, 3D 공간에서의 위치를 정의하는 데 사용된다. 각 정점은 위치 정보 외에도 색상, 텍스처 좌표 등의 속성을 가질 수 있다."
    },
    {
        "term": "Polygon",
        "description": "폴리곤은 최소 3개의 정점으로 구성된 평면적 도형으로, 메쉬를 형성하는 기본 단위이다. 가장 일반적인 폴리곤 형태는 삼각형과 사각형이다."
    },
    {
        "term": "UV Coordinates",
        "description": "UV 좌표는 2D 텍스처를 3D 모델의 표면에 매핑할 때 사용하는 시스템이다. 각 정점에 대한 UV 좌표를 설정함으로써 텍스처가 올바르게 적용되고 시각적으로 일관되게 나타난다."
    },
    {
        "term": "Triangle",
        "description": "삼각형은 3개의 정점으로 구성된 폴리곤으로, 3D 메쉬에서 가장 기본적인 형태이다. 모든 3D 공간에서 폴리곤을 삼각형으로 나누는 것이 일반적이며, 이는 렌더링 효율성을 높인다."
    },
    {
        "term": "Quad",
        "description": "사각형은 4개의 정점으로 구성된 폴리곤으로, 주로 복잡한 형상을 표현하는 데 사용된다. 그러나 게임 엔진에서는 주로 사각형을 두 개의 삼각형으로 나누어 처리한다."
    },
    {
        "term": "프리미티브 오브젝트",
        "description": "프리미티브 오브젝트는 3D 모델링에서 기본 형태로 자주 사용되는 도형입니다. 유니티에서는 기본적으로 제공되는 여러 종류의 프리미티브 오브젝트를 사용하여 게임 세계를 구성할 수 있으며, 사용자가 직접 메쉬를 생성하고 커스터마이징할 수 있습니다."
    },
    {
        "term": "MeshFilter",
        "description": "MeshFilter는 유니티에서 3D 메쉬를 렌더링하는 데 필요한 데이터를 보관하는 컴포넌트입니다. 이 컴포넌트를 사용하여 오브젝트에 메쉬를 부착하고, 메쉬를 시각적으로 표시할 수 있습니다."
    },
    {
        "term": "MeshRenderer",
        "description": "MeshRenderer는 씬에서 3D 오브젝트를 시각적으로 나타내기 위해 MeshFilter에 있는 메쉬 정보를 사용합니다. 이 컴포넌트는 렌더링 프로세스에서 메쉬가 어떻게 보여질지를 결정하는 역할을 합니다."
    },
    {
        "term": "정점(Vertex)",
        "description": "3D 모델의 기본 구성 요소 중 하나로, 각 정점은 3D 공간의 하나의 위치를 나타냅니다. 여러 정점이 모여서 폴리곤을 형성하고, 객체의 형태를 정의합니다."
    },
    {
        "term": "UV 좌표",
        "description": "UV 좌표는 3D 모델의 정점에 텍스처를 매핑하기 위해 사용하는 2D 좌표 시스템입니다. UV 맵을 사용하여 텍스처가 3D 오브젝트의 표면에 어떻게 배치될지를 결정합니다."
    },
    {
        "term": "Triangular Indices",
        "description": "폴리곤을 정의하는 데 사용되는 인덱스 배열입니다. 정점의 순서를 정의하여 삼각형을 형성하고, 메쉬의 구조를 구성합니다."
    },
    {
        "term": "GenerateMesh 메소드",
        "description": "프리미티브 오브젝트의 메쉬를 생성하는 사용자 정의 메소드로, 정점과 UV 좌표의 계산 및 설정을 수행합니다. 특정 요구 사항에 맞게 메쉬를 구성할 수 있도록 설계됩니다."
    },
    {
        "term": "메인 카메라",
        "description": "유니티의 씬에서 사용자에게 보여지는 뷰를 결정하는 카메라입니다. 객체의 배치와 조명, 각도에 따라 어떻게 보일지를 컨트롤하는 중요한 요소입니다."
    },
    {
        "term": "Polygon Generator",
        "description": "유니티에서 다각형 오브젝트를 생성하기 위한 스크립트로, 사용자 정의 입력을 통해 다양한 형태의 다각형을 자동으로 생성할 수 있는 도구."
    },
    {
        "term": "Filled Polygon",
        "description": "내부가 색으로 채워진 다각형으로, 지정된 점들을 기반으로 면을 형성하여 2D 혹은 3D 공간에서 시각적으로 볼 수 있는 형태를 만들어낸다."
    },
    {
        "term": "Hollow Polygon",
        "description": "내부가 비어있고, 주로 외곽선 형태로 구성된 다각형으로, 경계만 정의되며 내면은 비어 있어 레이아웃이나 공간 디자인에서 사용된다."
    },
    {
        "term": "UV Mapping",
        "description": "3D 모델의 표면에 2D 텍스처를 적절하게 배치하기 위한 과정으로, 각 정점에 해당하는 UV 좌표를 설정하여 텍스처가 균형적으로 분포되는 방법."
    },
    {
        "term": "Collision",
        "description": "물리적 상호작용을 형성하기 위해 사용되는 기술로, 게임 오브젝트 간의 충돌 감지를 위해 메시와 콜라이더를 연결하여 충돌이 발생할 때의 반응을 정의."
    },
    {
        "term": "Mesh Filter",
        "description": "유니티에서 오브젝트의 메쉬 정보를 관리하기 위한 컴포넌트로, 메쉬가 렌더링될 때 어떤 메쉬 데이터가 사용될지를 결정한다."
    },
    {
        "term": "Mesh Renderer",
        "description": "유니티에서 메쉬 필터에서 지정한 메쉬를 화면에 그리기 위해 사용하는 컴포넌트로, 메쉬의 외형을 시각적으로 표현하는 역할을 맡고 있다."
    },
    {
        "term": "Collider",
        "description": "유니티에서 오브젝트의 경계 영역을 정의하여 물리 충돌을 감지하는 컴포넌트."
    },
    {
        "term": "Polygon Scripting",
        "description": "유니티에서 프로그래밍을 통해 다각형을 생성 및 조작하기 위한 기술로, 코드와 입력 파라미터를 통해 동적인 형태의 다각형을 만들어낼 수 있다."
    },
    {
        "term": "LineRenderer",
        "description": "Unity 엔진의 컴포넌트 중 하나로, 선을 그리는 데 사용됩니다. 점의 개수를 조절하여 다양한 형태의 선을 생성할 수 있으며, 물리적 또는 비물리적 효과를 시각적으로 표현하는 데 유용합니다."
    },
    {
        "term": "Awake 메소드",
        "description": "Unity의 MonoBehaviour 클래스에서 제공하는 함수 중 하나로, 스크립트가 활성화될 때 호출됩니다. 주로 컴포넌트 초기화 및 설정을 위해 사용됩니다."
    },
    {
        "term": "Raycast",
        "description": "Unity에서 레이저와 유사한 형태로, 특정 방향으로 광선을 발사해 충돌체를 탐색하는 기능입니다. 물체와의 충돌 여부를 확인하여 LineRenderer의 시각적 효과를 결정하는 데 사용됩니다."
    },
    {
        "term": "VisualizerLine",
        "description": "선형 기반의 시각화를 위해 생성된 게임 오브젝트의 이름으로, 주로 LineRenderer 컴포넌트를 포함하여 마우스 방향으로 시각적 선을 나타내는 데 사용됩니다."
    },
    {
        "term": "컴포넌트 추가",
        "description": "Unity의 게임 오브젝트에 특정 기능을 부여하기 위해 LineRenderer와 같은 컴포넌트를 추가하는 과정입니다. 이 방식으로 게임 오브젝트는 물리적 특성, 시각적 효과 등을 갖게 됩니다."
    },
    {
        "term": "선의 색상 속성",
        "description": "LineRenderer의 속성 중 하나로, 그려지는 선의 색상을 설정할 수 있는 기능입니다. 이를 통해 개발자는 선의 시각적 요소를 구체적으로 조절할 수 있습니다."
    },
    {
        "term": "Sin Wave",
        "description": "수학에서의 사인 함수의 그래프를 나타내며, 주기적이고 연속적인 파형을 생성한다. LineRenderer를 사용하여 이 그래프를 Unity에서 시각적으로 구현할 수 있다."
    },
    {
        "term": "Position Count",
        "description": "LineRenderer에서 점의 개수를 설정하는 파라미터로, 선의 길이와 분포를 조정하는 데 중요한 역할을 한다."
    },
    {
        "term": "Mathf.Lerp",
        "description": "선형 보간을 제공하는 Unity의 수학적 메소드로, 두 값을 비율에 따라 선형적으로 보간하는 데 사용된다. 주로 위치 값을 설정하는 데 활용된다."
    },
    {
        "term": "Gradient Editor",
        "description": "Unity에서 색상의 그라데이션을 설정하는 도구로, 라인렌더러의 색상 속성을 조정하는 데 사용된다. 다양한 색상을 효과적으로 배치하여 시각적 효과를 향상시킬 수 있다."
    },
    {
        "term": "World Space",
        "description": "오브젝트가 위치한 게임 세계의 공간을 의미하며, 라인렌더러의 World Space Parameter를 활성화하면 월드 좌표계에서 렌더링이 올바르게 이루어진다."
    },
    {
        "term": "Angle Calculation",
        "description": "다각형을 생성할 때 각 점의 위치를 결정하기 위해 각도를 계산하는 과정으로, 삼각함수를 기반으로 x, y 좌표를 산출하는 데 사용된다."
    },
    {
        "term": "Awake Method",
        "description": "Unity의 MonoBehaviour 클래스에서 제공하는 초기화 메소드로, 씬이 로드될 때 호출되어 객체의 초기 상태를 설정하는 데 사용된다."
    },
    {
        "term": "Update Method",
        "description": "Unity의 MonoBehaviour 클래스의 메소드로, 매 프레임마다 호출되어 게임의 상태를 업데이트하는 역할을 한다."
    },
    {
        "term": "Morphology Conversion",
        "description": "형태 변환을 의미하며, 특정 형태에서 다른 형태로 변형하는 프로세스를 설명한다. 영상에서는 라인 렌더러를 사용하여 이러한 형태 변환 애니메이션을 구현하는 방법을 다룬다."
    },
    {
        "term": "Update 메소드",
        "description": "Unity에서 매 프레임 호출되는 함수로, 게임 오브젝트의 상태를 지속적으로 업데이트하는 데 사용된다. 사용자 입력 처리나 애니메이션 업데이트 등에 활용된다."
    },
    {
        "term": "신(Scene)",
        "description": "Unity 프로젝트 내에서 특정 환경이나 배경을 재현하는 단위로, 각각의 신은 고유한 오브젝트, 카메라, 라이팅을 가질 수 있다."
    },
    {
        "term": "LineRenderer 점(Point)",
        "description": "LineRenderer에서 생성하는 각 선의 구성 요소로, 선의 형태와 경로를 결정하는 위치 정보를 담고 있다. 점의 수와 배열은 최종 시각적 결과에 직접적인 영향을 미친다."
    },
    {
        "term": "Input.GetMouseButtonDown",
        "description": "Unity의 입력 시스템 함수로, 마우스 버튼 클릭 이벤트를 감지한다. 특정 버튼이 눌렸을 때 특정 동작을 실행하는 데 사용된다."
    },
    {
        "term": "리스트(List)",
        "description": "C#에서 제공하는 데이터 구조 중 하나로, 가변적인 크기를 보유하며 데이터를 순차적으로 저장할 수 있는 컬렉션이다. 형태 변환 과정에서 점 정보 등을 저장하는 데 유용하게 사용된다."
    },
    {
        "term": "AddFillerPoints",
        "description": "형태 변환 애니메이션을 더욱 부드럽고 자연스럽게 만들기 위해 기존 점 사이에 추가 점을 생성하는 메소드로, 특정 알고리즘을 통해 점을 배치하여 중간 형태를 구성한다."
    },
    {
        "term": "라인렌더러 (LineRenderer)",
        "description": "유니티에서 선을 그리는 데 사용되는 컴포넌트로, 2D 및 3D 오브젝트의 선이나 경로를 시각적으로 표현하기 위해 사용된다."
    },
    {
        "term": "충돌 (Collision)",
        "description": "게임 오브젝트 간의 물리적 상호작용을 처리하는 개념으로, 오브젝트가 서로 접촉할 때 발생하는 사건을 의미한다."
    },
    {
        "term": "EdgeCollider2D",
        "description": "2D 물리 시스템에서 선형 형태의 충돌을 처리하는데 필요한 콜라이더로, 주로 경로를 형성하는 선 오브젝트의 충돌을 관리한다."
    },
    {
        "term": "RequireComponentAttribute",
        "description": "유니티에서 특정 컴포넌트를 자동으로 추가하도록 하는 속성으로, 지정된 컴포넌트가 없는 경우 스크립트가 해당 컴포넌트를 자동으로 추가한다."
    },
    {
        "term": "Vector2",
        "description": "2D 공간에서의 점을 나타내는 데이터 타입으로, X와 Y 좌표를 포함하여 2D 벡터 연산에 사용된다."
    },
    {
        "term": "RigidBody2D",
        "description": "2D 물리 엔진에서 물체의 물리적 속성 및 동작을 제어하는 컴포넌트로, 중력이나 힘의 영향을 받도록 설정된다."
    },
    {
        "term": "폴리곤 콜라이더 2D",
        "description": "비정형 2D 오브젝트의 충돌 영역을 정의하는 콜라이더로, 다양한 모양의 경계를 만드는 데 사용된다."
    },
    {
        "term": "Object Spawner",
        "description": "게임 내에서 오브젝트를 생성(Create)할 수 있는 스크립트로, 특정 조건에 따라 다양한 오브젝트를 프로그래밍적으로 생성하는 데 사용된다."
    },
    {
        "term": "Infinite Parallax Background",
        "description": "2D 게임에서 사용하는 배경 스크롤링 기법으로, 플레이어나 카메라의 이동에 따라 배경 이미지가 느리게 또는 빠르게 움직이며 입체감을 부여하는 기술입니다. 일반적으로 배경은 원거리에 있는 객체일수록 느리게, 가까운 객체일수록 빠르게 움직이도록 설정됩니다."
    },
    {
        "term": "Transform.position",
        "description": "Unity에서 게임 오브젝트의 위치를 조정하는 데 사용되는 속성입니다. x, y, z 좌표를 변경함으로써 오브젝트의 위치를 변경할 수 있습니다."
    },
    {
        "term": "Layering",
        "description": "게임에서 다양한 배경 레이어를 수직적으로 쌓아 올림으로써 더 깊은 화면 비율을 만드는 기법입니다. 다양한 배경 이미지를 각기 다른 깊이와 속도로 스크롤하여 입체감을 부여합니다."
    },
    {
        "term": "Texture Offset",
        "description": "오브젝트의 텍스처가 어떤 방향으로 얼마나 빠르게 이동할지를 조정하는 매개변수입니다. 이 값을 조정하여 배경 이미지의 움직임을 자연스럽게 구현할 수 있습니다."
    },
    {
        "term": "Asset Store",
        "description": "Unity 개발자들이 사용할 수 있는 다양한 게임 자산을 구매하거나 다운로드할 수 있는 온라인 마켓플레이스입니다. 여기서 배경 이미지와 같은 다양한 에셋을 구입하여 프로젝트에 활용할 수 있습니다."
    },
    {
        "term": "Parent Object",
        "description": "Unity에서 몇 가지 오브젝트를 그룹화 해 관리할 수 있도록 하는 오브젝트로, 자식 오브젝트의 위치와 회전 등을 제어합니다. 이 방식을 통해 여러 배경 오브젝트를 효율적으로 관리할 수 있습니다."
    },
    {
        "term": "TutorialBase Class",
        "description": "튜토리얼의 기본 클래스이며, 추상 클래스로 정의되어 다른 튜토리얼 행동들이 이 클래스를 상속받아 구현됩니다. 일반적으로 엔터 등의 메소드를 포함하여 기본적인 동작을 규정합니다."
    },
    {
        "term": "TutorialController Class",
        "description": "튜토리얼 내에서 발생하는 행동들을 관리하는 클래스입니다. 현재 진행되는 튜토리얼 단계와 관련된 행동을 순차적으로 빠르게 처리하는 역할을 합니다."
    },
    {
        "term": "FadeEffect",
        "description": "화면의 페딩 효과를 다루는 클래스입니다. 화면이 서서히 사라지거나 나타나는 효과를 통해 사용자 경험을 향상시킵니다."
    },
    {
        "term": "UI Movement",
        "description": "사용자 인터페이스 요소의 위치를 조정하는 기능으로, 사용자의 주의를 지금 필요한 사항에 집중시키기 위한 기법입니다."
    },
    {
        "term": "Trigger",
        "description": "특정 조건이 만족될 때 행동을 수행하는 기능으로, 예를 들어 플레이어가 특정 위치에 도달하거나 아이템을 획득할 때 발생하는 이벤트의 처리를 담당합니다."
    },
    {
        "term": "Destroy Tag Objects",
        "description": "특정 태그를 가진 객체를 모두 비활성화하거나 삭제할 때 사용하는 메소드로, 목표 달성의 시각적 확인을 도와줍니다."
    },
    {
        "term": "Unity Package Management",
        "description": "유니티에서 패키지를 설치하고 관리하는 시스템으로, 다양한 외부 라이브러리와 기능을 쉽게 프로젝트에 통합할 수 있도록 돕습니다."
    },
    {
        "term": "Scripting in Unity",
        "description": "유니티 엔진 내에서 C# 프로그래밍을 통해 게임 로직, 인터페이스를 정의하고 제어하는 작업으로, 게임 개발의 핵심적인 부분을 차지합니다."
    },
    {
        "term": "모바일 재화 축약 표현",
        "description": "모바일 게임이나 애플리케이션에서 사용되는 긴 숫자 정보를 더 간결하게 표현하기 위해, 'K', 'M', 'G', 'T', 'P', 'E', 'Z'와 같은 기호를 사용하는 방식이며, 이는 사용자 인터페이스(UI)를 개선하고 소통을 명확하게 함."
    },
    {
        "term": "노테이트 넘버 스크립트",
        "description": "유니티에서 사용되는 스크립트로, 숫자를 특정 대수로 줄여 축약된 문자열 형태로 반환하는 기능을 제공. 주로 게임 재화와 같은 정보를 표시할 때 사용됨."
    },
    {
        "term": "축약 기호",
        "description": "숫자를 표현할 때 사용되는 기호로, 예를 들어 'K'는 킬로(1,000), 'M'은 메가(1,000,000), 'G'는 기가(1,000,000,000)와 같은 방식으로, 축약된 형태로 큰 숫자를 쉽게 이해할 수 있도록 돕는다."
    },
    {
        "term": "테스트 스크립트",
        "description": "유니티 프로젝트 내에서 특정 기능을 검증하기 위해 작성된 스크립트로, 예를 들어 유저가 입력한 재화를 정확하게 축약하여 출력하는지 시험하는 데 사용됨."
    },
    {
        "term": "축약 숫자",
        "description": "큰 숫자를 더 쉽게 읽을 수 있도록 음절 수를 줄여 표현하는 방법으로, 예를 들어 22,000을 '22K'로, 1,500,000을 '1.5M'으로 표현하여 사용자에게 빠르고 간결한 정보를 제공."
    },
    {
        "term": "Lerp()",
        "description": "Lerp()는 선형 보간(Linear Interpolation)으로, 두 지점 사이의 중간 값을 계산하는 함수입니다. 이를 통해 오브젝트의 위치, 색상, 그리고 기타 속성을 부드럽게 변화시킬 수 있습니다."
    },
    {
        "term": "선형 보간",
        "description": "선형 보간은 임의의 두 값 사이의 비율에 따라 중간 값을 찾아내는 기법입니다. 예를 들어, 시작 값이 0, 종료 값이 100일 때, t 값이 0.5라면 결과는 50이 됩니다. 이는 주로 애니메이션과 그래픽스에서 많이 사용됩니다."
    },
    {
        "term": "Vector3",
        "description": "Vector3는 3차원 공간에서의 위치를 표현하는 구조체로, x, y, z 좌표를 포함합니다. Unity에서는 물체의 위치, 회전, 스케일 등의 속성을 관리하는 데 광범위하게 사용됩니다."
    },
    {
        "term": "Coroutine",
        "description": "Coroutine은 Unity에서 시간 기반의 작업을 처리하기 위해 사용하는 기법으로, 특정 코드를 일정 시간 지연 후 실행하고 싶을 때 유용합니다. 이 방법을 사용하면 동시에 여러 작업을 수행할 수 있습니다."
    },
    {
        "term": "Time.deltaTime",
        "description": "Time.deltaTime은 마지막 프레임과 현재 프레임 간의 시간 간격을 나타내는 값으로, 이것을 사용하여 프레임 속도에 관계없이 부드러운 애니메이션이 가능하게 합니다."
    },
    {
        "term": "감속 이동",
        "description": "감속 이동은 오브젝트가 목표 위치에 가까워질수록 이동 속도를 줄이는 기법으로, 보다 자연스러운 동작을 제공하는 데 사용됩니다. 일반적으로 게임에서 캐릭터나 물체의 이동 시 주로 활용됩니다."
    },
    {
        "term": "목표 위치",
        "description": "목표 위치는 오브젝트가 이동해야 하는 최종 위치를 의미합니다. 이 위치는 주로 게임의 플레이어, NPC, 또는 애니메이션 효과를 적용할 때 중요한 기준이 됩니다."
    },
    {
        "term": "프레임",
        "description": "컴퓨터 그래픽스에서 프레임은 화면에 표시되는 정적 이미지의 단위로, 초당 표시되는 프레임 개수(FPS)에 따라 애니메이션의 부드러움이 결정됩니다."
    },
    {
        "term": "랜덤 스포너",
        "description": "유니티에서 다양한 오브젝트를 임의의 위치에 생성하는 컴포넌트입니다. 이 스포너는 게임 내에서 자주 발생하는 오브젝트 생성을 효율적으로 관리하게 해주며, 개발자가 오브젝트 생성의 비율을 쉽게 조절할 수 있도록 도와줍니다."
    },
    {
        "term": "Instantiate",
        "description": "유니티에서 프리팹 또는 게임 오브젝트를 복제하여 생성하는 메소드입니다. 이 메소드를 통해 게임 씬에 오브젝트를 동적으로 추가할 수 있으며, 게임의 진행 상황에 따라 다양한 오브젝트를 생성할 수 있는 기능을 제공합니다."
    },
    {
        "term": "프리팹(Prefab)",
        "description": "유니티에서 미리 설정된 오브젝트의 템플릿입니다. 프리팹을 이용하면 동일한 구성의 오브젝트를 여러 번 쉽게 생성할 수 있으며, 프리팹을 수정하면 장면 내 모든 인스턴스가 자동으로 업데이트됩니다."
    },
    {
        "term": "확률(Probability)",
        "description": "특정 사건이 발생할 가능성을 수치적으로 표현하는 개념입니다. 게임 개발에서 확률을 설정하여 다양한 오브젝트의 생성 빈도를 조절함으로써, 플레이어에게 다양한 경험을 제공할 수 있습니다."
    },
    {
        "term": "스포너 컴포넌트",
        "description": "오브젝트 생성과 관련된 여러 기능을 가지고 있는 유니티의 특정 스크립트나 구성 요소로, 다양한 오브젝트를 임의로 생성하는 논리를 포함합니다. 이 컴포넌트는 여러 프리팹을 조합하여 사용자가 설정한 조건에 맞게 오브젝트를 생성합니다."
    },
    {
        "term": "생성 확률 설정",
        "description": "게임 내에서 각 오브젝트가 생성될 확률을 조절하는 방법입니다. 이를 통해 특정 오브젝트가 더 자주 등장하거나 드물게 등장하도록 설정할 수 있으며, 이를 사용하여 게임의 난이도나 플레이어 경험에 직접적인 영향을 줄 수 있습니다."
    },
    {
        "term": "Initialize Attributes",
        "description": "Unity에서 제공하는 특수한 어트리뷰트로, 플레이 모드 진입 시 특정 메소드를 자동으로 호출하는 데 사용된다. 이러한 어트리뷰트는 게임 오브젝트와 관련 없이 정적 메소드를 호출할 수 있어 유용하다."
    },
    {
        "term": "Save On Playmode",
        "description": "Unity 에디터에서 현재 씬을 자동으로 저장하는 기능으로, 사용자가 플레이 모드를 시작하기 전에 씬의 변경 사항을 저장할 수 있도록 하는 스크립트를 작성하여 구현한다."
    },
    {
        "term": "팝업 창 처리",
        "description": "현재 씬의 변경 사항이 있는 경우 사용자에게 저장 여부를 묻는 팝업 창을 출력하여 사용자 경험을 향상시키는 기법이다. 사용자는 질문에 대해 '저장' 또는 '저장하지 않음'을 선택할 수 있다."
    },
    {
        "term": "Unity 에디터",
        "description": "게임 개발에 특화된 소프트웨어 환경으로, 사용자 인터페이스와 다양한 개발 도구가 제공된다. Unity 에디터는 프로젝트를 시각적으로 관리하고 스크립트를 통해 기능을 구현할 수 있는 플랫폼이다."
    },
    {
        "term": "플레이 모드",
        "description": "Unity 에디터에서 게임의 실행을 시뮬레이션하는 모드로, 게임의 환경과 상호작용을 테스트할 수 있는 기능이다. 사용자가 설정한 게임 동작과 반응을 실시간으로 확인할 수 있다."
    },
    {
        "term": "자동 저장 기능",
        "description": "사용자가 씬을 수정한 후 플레이 모드에 진입할 때 자동으로 해당 씬을 저장하는 기능으로, 개발 과정에서 불필요한 데이터 손실을 방지하고 효율적인 작업 흐름을 제공한다."
    },
    {
        "term": "스크립트 작성",
        "description": "Unity에서는 C# 스크립트를 통해 다양한 기능을 구현할 수 있으며, 자동 저장과 같은 특정 기능을 작동시키기 위해 스크립트를 작성하는 과정이 필요하다."
    },
    {
        "term": "씬(Scene)",
        "description": "씬은 Unity에서 게임 세계의 특정 부분을 나타내는 단위입니다. 각 씬은 게임 오브젝트, 조명, 카메라, 텍스처 등의 요소를 포함할 수 있으며, 여러 씬을 조합하여 전체 게임 환경을 구성합니다."
    },
    {
        "term": "0번 씬(Zero Scene)",
        "description": "0번 씬 또는 초기 씬은 Unity 프로젝트에서 가장 먼저 로드되는 씬을 가리킵니다. 주로 초기화 작업이나 게임 시작 시 필요한 요소들이 정의됩니다."
    },
    {
        "term": "Edit Play Scene 스크립트",
        "description": "이 스크립트는 Unity 개발 과정에서 자동으로 특정 씬을 실행하도록 설정하는 데 사용됩니다. 플레이 버튼을 클릭할 때 항상 지정된 씬이 실행되도록 합니다."
    },
    {
        "term": "DontDestroyOnLoad",
        "description": "이 메서드는 특정 게임 오브젝트가 씬 전환 시 파괴되지 않도록 보장합니다. 주로 음악, UI 설정, 게임 상태 등의 정보를 유지해야 할 때 사용됩니다."
    },
    {
        "term": "Build Settings",
        "description": "Unity의 Build Settings는 프로젝트를 빌드하기 위한 최종 설정을 관리하는 곳으로, 어떤 씬들이 최종 게임에 포함될지를 결정합니다."
    },
    {
        "term": "에디터에서 시작 씬 설정",
        "description": "Unity 에디터 내에서 프로젝트가 시작될 때 불러올 기본 씬을 설정하는 기능으로, 개발자가 원하는 작업 환경이나 초기화 과정을 손쉽게 관리할 수 있게 합니다."
    },
    {
        "term": "씬 관리(Scene Management)",
        "description": "Unity에서 씬 관리는 여러 씬 간의 전환 및 동기화를 포함한 프로세스입니다. 씬 로딩, 언로딩, 및 씬 사이의 상태 유지 관리가 중요합니다."
    },
    {
        "term": "커스텀 에디터",
        "description": "Unity의 에디터 기능을 확장하거나 수정하기 위해 사용자가 정의한 특정 편집 인터페이스로, 이러한 커스텀 에디터를 통해 사용자 맞춤형 작업 흐름 및 툴을 제작할 수 있다."
    },
    {
        "term": "에디터 폴더",
        "description": "Unity 프로젝트 내에서 커스텀 에디터와 관련된 스크립트를 저장하는 특별한 폴더로, 런타임에서 사용되지 않고 오직 에디터에서만 작동하는 기능들에 필요한 API를 호출할 수 있는 공간이다."
    },
    {
        "term": "에디터 디폴트 리소스 폴더",
        "description": "커스텀 에디터에서 사용할 수 있는 기본 리소스를 저장하는 폴더로, 이 위치에 저장된 정보는 에디터 GUI 유틸리티 메소드를 통해 접근하여 사용될 수 있다."
    },
    {
        "term": "에디터 윈도우",
        "description": "Unity의 사용자 인터페이스 내에서 자신만의 기능을 구현할 수 있는 창으로, 여러 형태로 출력될 수 있으며, 특정 메소드를 사용하여 사용자 액션에 따라 갱신될 수 있는 UI 요소를 생성하는데 사용된다."
    },
    {
        "term": "Show Utility 메소드",
        "description": "에디터 윈도우를 출력하기 위한 메소드 중 하나로, 일반적인 도구 창을 여는 데 사용된다."
    },
    {
        "term": "Show Popup 메소드",
        "description": "사용자에게 임시적으로 정보를 전달하거나 선택을 유도하기 위해 사용되는 팝업 창을 생성하는 메소드이다."
    },
    {
        "term": "OnEnable 메소드",
        "description": "Unity 컴포넌트의 생명주기 메소드 중 하나로, 해당 에디터 윈도우가 활성화될 때 호출되며, 윈도우가 중복으로 출력되지 않도록 관리한다."
    },
    {
        "term": "OnGUI 메소드",
        "description": "Unity의 GUI 이벤트 처리 메소드로, 매 프레임마다 UI를 업데이트하고 그리기에 필요한 작업을 수행한다, 사용자 인터페이스의 상태를 반영하는 데 중요한 역할을 한다."
    },
    {
        "term": "Custom Editor",
        "description": "Unity 엔진에서 개발자가 특정 객체나 기능을 사용할 때, 사용자 정의된 UI를 제공하여 개발 효율성을 높이는 에디터 확장 기능."
    },
    {
        "term": "GUI",
        "description": "Graphical User Interface로, 프로그램 사용자와의 상호작용을 위한 시각 요소를 관리하는 클래스를 의미하며, 일반적인 UI 표시를 위한 구성 요소로 사용됨."
    },
    {
        "term": "GUILayout",
        "description": "Unity에서 자동으로 UI 요소의 위치와 크기를 관리하는 레이아웃 도구로, 복잡한 위치 계산 없이도 효율적으로 UI를 구성할 수 있게 도움."
    },
    {
        "term": "EditorGUI",
        "description": "Unity 에디터 내에서 UI 요소를 그리기 위한 클래스이며, 에디터 창에 UI 컴포넌트를 추가할 수 있도록 지원."
    },
    {
        "term": "EditorGUILayout",
        "description": "EditorGUI의 확장으로, 에디터 UI 구성의 효율성을 높여주는 함수와 레이아웃 요소들을 제공."
    },
    {
        "term": "GUIContent",
        "description": "UI 요소에 대해 텍스트, 이미지, 툴팁 등의 추가 정보를 설정할 수 있도록 돕는 클래스, 사용자 경험을 개선하는 데 중요한 역할."
    },
    {
        "term": "GUIStyle",
        "description": "Unity UI 요소의 시각적 스타일을 정의하는 클래스, 버튼, 라벨 등의 디자인을 커스터마이징할 수 있는 기능을 제공."
    },
    {
        "term": "GUILayoutOption",
        "description": "UI 요소의 크기와 배치를 조정하는 옵션을 제공하는 클래스, 최대/최소 크기 설정 등을 통해 UI의 유연성을 증가시킴."
    },
    {
        "term": "Label",
        "description": "사용자에게 정보를 표시하기 위한 UI 요소로, 단순한 텍스트 정보를 제공하는 데에 사용됨."
    },
    {
        "term": "TextField",
        "description": "사용자가 텍스트를 입력할 수 있는 인터페이스 요소, 데이터 입력을 수집하는 데 필요."
    },
    {
        "term": "Button",
        "description": "특정 동작을 수행하도록 설정된 UI 요소로, 사용자가 클릭하여 행동을 유도할 수 있음."
    },
    {
        "term": "UI 색상",
        "description": "UI 요소의 시각적 요소로, 사용자의 인식을 돕고 테마나 분위기를 설정하는 데 중요한 역할."
    },
    {
        "term": "Input Field",
        "description": "Input Field는 사용자가 문자열 데이터를 입력할 수 있는 UI 요소입니다. 기본적으로 텍스트 입력란을 제공하며, 입력된 데이터는 특정 변수에 저장될 수 있습니다. Unity의 SerializedProperty와 연결하여 인스펙터에서 편리하게 사용할 수 있는 구조를 가지고 있습니다."
    },
    {
        "term": "Color Field",
        "description": "Color Field는 색상을 선택하도록 돕는 UI 요소입니다. 사용자는 RGB 값이나 색상 선택기를 통해 색상을 정의하고 선택할 수 있으며, 기본 색상과 HDR 색상 모두를 지원합니다. 이러한 필드는 그래픽 작업에서 색상을 조정해야 하는 상황에서 유용하게 활용됩니다."
    },
    {
        "term": "Object Field",
        "description": "Object Field는 Unity의 게임 오브젝트 및 MonoBehaviour 컴포넌트를 드래그 앤 드롭으로 등록하는 데 사용됩니다. 이 필드는 유연한 오브젝트 선택 옵션을 제공하고, 편리하게 에디터 내에서 오브젝트의 참조를 다룰 수 있게 합니다."
    },
    {
        "term": "Dropdown Field",
        "description": "Dropdown Field는 선택 가능한 목록에서 사용자가 옵션을 선택할 수 있도록 인터페이스를 제공합니다. 클릭 시 메뉴가 펼쳐지며, 태그나 레이어, 사용자 정의 옵션 등을 손쉽게 선택할 수 있어 대화형 UI 설계에서 많이 사용됩니다."
    },
    {
        "term": "SerializedProperty",
        "description": "SerializedProperty는 Unity에서 스크립트의 변수와 그 값을 에디터에서 감독할 수 있도록 해주는 데이터 구조입니다. 이는 사용자 정의 에디터 제작 시 변수의 시리얼화와 역시리얼화를 자동으로 처리하여 보다 안전한 변수 관리를 가능하게 합니다."
    },
    {
        "term": "Editor GUI",
        "description": "Editor GUI는 Unity 에디터에서 사용자 지정 그래픽 사용자 인터페이스를 설계할 수 있는 도구입니다. 이를 통해 개발자는 자신이 만든 게임 오브젝트나 컴포넌트의 특성을 쉽게 조작할 수 있는 기능을 제공할 수 있습니다."
    },
    {
        "term": "GameObject",
        "description": "GameObject는 Unity 엔진에서 모든 객체의 기본 요소입니다. 게임의 모든 동작을 구성하는 다수의 컴포넌트를 포함할 수 있으며, 게임 세계 내에서 유일한 존재로 인식됩니다."
    },
    {
        "term": "MonoBehaviour",
        "description": "MonoBehaviour는 Unity에서 스크립트를 구현하는 기본 클래스입니다. 이를 상속함으로써 개발자는 오브젝트의 행동을 프로그래밍할 수 있으며, Unity의 다양한 생명주기 메소드에 대한 호출을 관리할 수 있습니다."
    },
    {
        "term": "Toggle",
        "description": "Toggle은 Unity의 UI 요소로, 체크박스로 사용자가 특정 옵션의 활성화 여부를 선택할 수 있게 해줍니다. Toggle 메소드는 기본적인 토글 기능을 제공하며, 사용자가 선택한 값에 따라 프로그램의 동작이 변경됩니다."
    },
    {
        "term": "Button Style Toggle",
        "description": "버튼 형태의 토글은 시각적으로 버튼으로 보이지만 기능적으로는 Toggle과 동일하게 동작하는 UI 요소입니다. 사용자가 버튼을 클릭할 때 상태가 변경되며, 이를 통해 보다 직관적인 사용자 경험을 제공합니다."
    },
    {
        "term": "Toggle Group",
        "description": "토글 그룹은 여러 개의 Toggle을 하나로 묶어서 관리하는 UI 구성 요소입니다. 이 그룹 내에서는 사용자가 한 개의 옵션만 선택할 수 있게 하여, 다수의 옵션 중에서 하나만 활성화 되도록 만드는 데 유용합니다."
    },
    {
        "term": "GUI.skin",
        "description": "GUI.skin은 Unity의 UI 요소 스타일을 관리하기 위한 특정 속성입니다. 이를 통해 UI 요소의 외관을 변경할 수 있으며, 전문가 사용자 정의 에디터에서 일관된 시각적 요소를 유지하는 데 중요합니다."
    },
    {
        "term": "Inspector Window",
        "description": "유니티의 Inspector Window는 선택한 게임 오브젝트의 속성과 컴포넌트를 보여주고 조작할 수 있는 공간입니다. 사용자 정의 에디터는 이 Inspector 기능을 강화하여 특정 컴포넌트를 더 쉽게 관리할 수 있게 합니다."
    },
    {
        "term": "Unity Versions",
        "description": "Unity의 여러 버전은 기능과 성능이 개선되며, 각 버전마다 새로운 기능이나 버그 수정이 포함됩니다. 본 영상에서는 Unity 2023.1.16f1 버전을 사용하고 있습니다."
    },
    {
        "term": "HelpBox",
        "description": "헬프박스는 사용자에게 정보를 전달하기 위한 UI 요소로 사용되며, 메시지를 출력하는 기능을 가지고 있다. 메시지의 종류에 따라 인포, 워닝, 에러 등의 세 가지 타입으로 구분되어 보여질 수 있습니다."
    },
    {
        "term": "Knob",
        "description": "납은 사용자로 하여금 값을 조정할 수 있는 원형 게이지를 제공하는 UI 요소이다. 사용자는 설정된 최소 및 최대 값 사이에서 값을 조절할 수 있고, 외관 및 크기도 설정 가능합니다."
    },
    {
        "term": "IndentLevel",
        "description": "UI 요소의 들여쓰기를 제어하는 속성으로, editor.gui.indentLevel을 통해 설정할 수 있다. 값을 증가시키면 UI 구성 요소가 안쪽으로 들여쓰기가 되어 보다 조직적인 레이아웃을 구성할 수 있습니다."
    },
    {
        "term": "ProgressBar",
        "description": "프로그레스바는 현재 진행 상태를 시각적으로 표현하는 UI 요소로, 0.0에서 1.0 사이의 값을 통해 상대적인 진행도를 나타낸다. 바 중앙에 텍스트를 출력할 수도 있어 데이터 전달의 효율성을 높여줍니다."
    },
    {
        "term": "Begin/End Methods",
        "description": "Unity의 UI 요소를 그룹화하고 정렬하기 위해 사용하는 메소드로, Begin 메소드로 시작한 후 End 메소드를 호출하여 그룹의 범위를 끝내는 패턴. 이 과정을 통해 UI 요소의 수직적 또는 수평적 정렬을 수행할 수 있다."
    },
    {
        "term": "Horizontal",
        "description": "UI 요소들을 가로로 정렬하기 위해 사용하는 방법. Begin Horizontal 메소드를 통해 요소들을 수평으로 배열할 수 있으며, 반환되는 Rect를 통해 위치와 크기 정보에 접근할 수 있다."
    },
    {
        "term": "Vertical",
        "description": "UI 요소들을 세로로 정렬하는 기능으로, Begin Vertical 메소드를 사용하여 구성 요소들을 수직으로 배열할 수 있다. GUI 레이아웃 및 에디터 GUI 레이아웃에서 활용된다."
    },
    {
        "term": "ScrollView",
        "description": "길어지는 UI 요소들을 스크롤 가능하게 표시하기 위해 사용하는 메소드로, Begin ScrollView를 호출하여 스크롤 동작 및 위치 정보를 설정한다."
    },
    {
        "term": "DisabledGroup",
        "description": "UI 상호작용을 비활성화하기 위한 메소드. Begin DisabledGroup에서 매개변수를 설정하여 특정 UI 요소들의 사용 불가 여부를 결정할 수 있다."
    },
    {
        "term": "ChangeCheck",
        "description": "UI와의 상호작용 발생을 검사하여, 사용자가 UI와 상호작용했는지 확인하는 메소드. 상호작용이 발생하면 End Change Check가 true를 반환한다."
    },
    {
        "term": "Foldout",
        "description": "사용자가 클릭하여 열고 닫을 수 있는 UI 구성 요소로, 세모 아이콘과 텍스트로 표시되어 UI의 복잡도를 줄이고 필요한 정보만 표시할 수 있도록 돕는다."
    },
    {
        "term": "Foldout Header Group",
        "description": "Foldout에 추가 설정 옵션을 제공하는 메소드로, 기본 Foldout보다 확장된 기능을 제공하여 더 많은 설정을 간편하게 접근할 수 있게 한다."
    },
    {
        "term": "Editor GUI Layout",
        "description": "Unity의 에디터에 UI를 구성하기 위한 클래스의 집합으로, 일반 GUI 레이아웃 기능을 에디터 전용으로 최적화된 형태로 제공한다."
    },
    {
        "term": "Rect",
        "description": "2D 공간에서의 사각형 영역을 나타내는 데이터 구조체로, 위치 및 크기 정보를 포함하여 UI 요소의 배치를 제어하는 데 필수적이다."
    },
    {
        "term": "씬 자동 저장",
        "description": "Unity에서 특정 주기로 씬을 자동으로 저장하는 기능으로, 사용자가 지정한 설정에 따라 작동한다. 이는 작업 중 데이터 손실을 방지하고, 개발자가 씬을 매번 수동으로 저장할 필요성을 줄인다."
    },
    {
        "term": "Unity Editor Window",
        "description": "Unity의 사용자 인터페이스에서 사용자가 직접 지정한 설정을 조정할 수 있는 커스텀 창 기능을 의미한다. 이 기능은 다양한 설정을 한 곳에서 관리할 수 있게 해준다."
    },
    {
        "term": "저장 주기 설정",
        "description": "자동 저장 기능에서 사용자가 선택할 수 있는 시간 간격으로, 이 간격에 따라 씬이 특정 시간마다 자동으로 저장된다. 주기의 설정은 사용자의 필요에 따라 다르게 설정될 수 있다."
    },
    {
        "term": "Editor Scripting",
        "description": "Unity에서 커스텀 에디터 툴 및 기능을 생성하는 기술로, 스크립트를 통해 Unity Editor의 동작을 확장하고 특정 기능을 사용자 정의할 수 있게 된다."
    },
    {
        "term": "리페인트 메소드",
        "description": "Unity에서 UI 요소가 갱신될 때 호출되는 메소드로, 사용자 인터페이스의 상태를 다시 그리기 위해 사용된다. 이 메소드를 활용해 업데이트되는 시간 정보와 같은 동기적 UI 피드를 제공할 수 있다."
    },
    {
        "term": "유니티 노트 윈도우",
        "description": "Unity 내에서 씬의 정보 및 설정을 관리하는 사용자 인터페이스로, 프로젝트를 더 효율적으로 관리할 수 있는 방법을 제공한다."
    },
    {
        "term": "스크립트 생성",
        "description": "Unity에서 특정 기능을 수행하기 위해 사용하는 코드 모음으로, 자동 저장 기능 구현을 위해 필요하다. 이러한 스크립트는 기능별로 모듈화되어 관리된다."
    },
    {
        "term": "AddComponentMenu",
        "description": "유니티에서 특정 컴포넌트를 원하는 카테고리로 분류하여 쉽게 추가할 수 있도록 하는 어트리뷰트입니다. 클래스에 이 어트리뷰트를 붙이면, 컴포넌트 이름이 사용자 정의 이름으로 표시됩니다."
    },
    {
        "term": "ColorUsage",
        "description": "유니티 인스펙터에서 색상 변수를 설정할 때 알파 값 및 HDR 사용 여부를 설정할 수 있도록 도와주는 어트리뷰트입니다. VAR 타입에 이 어트리뷰트를 사용하여 색상 선택 팝업의 옵션을 조정할 수 있습니다."
    },
    {
        "term": "ContextMenu",
        "description": "컴포넌트의 컨텍스트 메뉴에 특정 메소드를 추가하는 용도로 사용되는 어트리뷰트입니다. 이 어트리뷰트를 사용하면, 메소드를 마우스 오른쪽 클릭으로 간편하게 호출할 수 있어 개발의 편의성을 높입니다."
    },
    {
        "term": "ContextMenuItem",
        "description": "변수에 대해 사용자 지정 컨텍스트 메뉴를 추가하는 어트리뷰트로, 매개변수로 메뉴 이름과 호출할 메소드를 지정하여 사용합니다. 이를 통해 변수와 관련된 추가 작업을 쉽게 수행할 수 있습니다."
    },
    {
        "term": "DisallowMultipleComponent",
        "description": "하나의 게임 오브젝트에 동일한 컴포넌트를 여러 번 추가할 수 없도록 제한하는 어트리뷰트입니다. 이는 컴포넌트간의 충돌이나 불필요한 데이터 중복을 방지하는 데 유용합니다."
    },
    {
        "term": "ExecuteInEditMode",
        "description": "게임이 실행되지 않는 상태에서도 MonoBehaviour 메소드가 호출될 수 있도록 하는 어트리뷰트입니다. 이를 통해 에디터에서 씬을 구성할 때도 특정 기능을 활성화할 수 있습니다."
    },
    {
        "term": "FormerlySerializedAs",
        "description": "변수의 이름이 변경될 때 기존 데이터의 호환성을 유지하기 위해 사용하는 어트리뷰트입니다. 이 어트리뷰트를 통해 변환된 변수명으로도 과거 데이터를 정상적으로 불러와 사용할 수 있게 됩니다."
    },
    {
        "term": "Attributes",
        "description": "Attributes in Unity are special markers that add metadata to classes, properties, and methods. They enable developers to customize behaviors in the Unity Inspector, providing a clearer interface and aiding with data validation."
    },
    {
        "term": "Range",
        "description": "The Range attribute is used to constrain numerical values within a specified range. When applied, it allows developers to set minimum and maximum allowable values for a variable, enhancing user experience by preventing invalid inputs."
    },
    {
        "term": "RequireComponent",
        "description": "This attribute declares that a specific component is required for the script to function properly. When the script is attached, Unity automatically adds the specified component if it is not already present, ensuring that dependencies are met."
    },
    {
        "term": "SerializeField",
        "description": "The SerializeField attribute allows private fields to be visible and editable in the Unity Inspector. This enables developers to keep fields encapsulated while still exposing them for configuration without making them public."
    },
    {
        "term": "HideInInspector",
        "description": "When applied to a public variable, the HideInInspector attribute prevents it from being shown in the Unity Inspector. This is useful for hiding certain variables that should not be modified directly from the Inspector without removing their public accessibility."
    },
    {
        "term": "Space",
        "description": "The Space attribute adds vertical spacing between fields in the Inspector. This enhances readability by separating groups of related variables visually, which is particularly useful for organizing complex scripts."
    },
    {
        "term": "TextArea",
        "description": "The TextArea attribute is used to create multi-line text fields in the Inspector, enhancing the input interface for string variables. It automatically wraps text, allowing users to enter longer texts more conveniently."
    },
    {
        "term": "Tooltip",
        "description": "This attribute provides additional information about a variable when the user hovers over it in the Inspector. Tooltips can be used to explain the purpose of a variable or provide hints about valid inputs, thereby improving usability."
    },
    {
        "term": "Inspector View",
        "description": "The Inspector View in Unity is a panel where developers can view and edit the properties of selected GameObjects and components. It is a crucial part of Unity's interface that allows for intuitive scene editing and component management."
    },
    {
        "term": "Unity Scripting",
        "description": "Unity scripting involves writing code in C# to control the behavior of GameObjects, define interactions, and implement game mechanics. Attributes are an integral part of Unity scripting, enhancing developer efficiency and scene organization."
    },
    {
        "term": "폭발 오브젝트",
        "description": "폭발 오브젝트는 게임이나 시뮬레이션에서 파괴 효과를 가진 발사체나 물체를 의미하며, 이러한 오브젝트는 종종 플레이어 또는 NPC가 공격할 때 발생하는 시각적 효과를 제공합니다."
    },
    {
        "term": "프로젝타일",
        "description": "프로젝타일은 고정된 포물선을 따라 비행하거나 명시된 위치로 전투의 목적을 가지고 발사되는 물체입니다. 게임에서 이는 총알, 화살 또는 폭탄 등이 될 수 있으며, 물리적인 충돌과 상호작용을 포함합니다."
    },
    {
        "term": "폭발 클래스",
        "description": "폭발 클래스를 사용하여 폭발 오브젝트의 기능과 속성을 정의합니다. 이 클래스는 충돌 시 발생할 수 있는 이벤트 처리 및 폭발 여부를 제어합니다."
    },
    {
        "term": "오브젝트 스포너",
        "description": "오브젝트 스포너는 지정된 시간 간격이나 조건에 따라 오브젝트를 생성하는 컴포넌트입니다. 일반적으로 여러 개의 게임 오브젝트를 효율적으로 관리하고 생성하는 데 사용됩니다."
    },
    {
        "term": "파티클 시스템",
        "description": "파티클 시스템은 자연현상(예: 연기, 불꽃, 폭발)과 같은 복잡한 시각적 효과를 구현하는데 도움이 되는 시스템입니다. 이 시스템을 통해 오브젝트와 주변 환경에 더 실제감 있는 효과를 더할 수 있습니다."
    },
    {
        "term": "파티클 오토 디스트로이어",
        "description": "파티클 오토 디스트로이어는 생성된 파티클이 지속된 후 자동으로 삭제하는 기능을 제공하는 스크립트 또는 컴포넌트입니다. 이는 메모리 관리에 유리하며, 게임의 성능을 향상시킵니다."
    },
    {
        "term": "코드 메소드",
        "description": "코드 메소드는 특정 작업이나 계산을 수행하기 위해 호출되는 프로시저 또는 함수입니다. 예를 들어, 타겟의 체력을 감소시키거나 충돌 이벤트를 처리하는 메소드를 통해 게임 내의 논리를 제어합니다."
    },
    {
        "term": "게임 프로그래밍",
        "description": "게임 프로그래밍은 게임 제작 과정에서 필요한 모든 소프트웨어 개발 기술을 포함합니다. 이는 일반적으로 디자인, 아트, 그리고 오디오 요소를 포함한 개발팀과 협력하여 최종 제품을 완성하는 데 중요한 역할을 합니다."
    },
    {
        "term": "목표 에워싸기 (Surround Target)",
        "description": "게임 개발에서 적들이 플레이어 또는 특정 목표를 중심으로 에워싸는 행동을 설계하는 기법. 이 기법은 적들의 위치를 조정하여 물리적인 경로와 위치 기반의 AI를 통해 목표를 포위하도록 만듭니다."
    },
    {
        "term": "내비메시 (NavMesh)",
        "description": "내비메시란 AI 경로finding을 위해 게임 세계의 특정 지형을 모델링한 경로망. Unity에서 제공하며, NPC가 장애물을 피하고 목표 지점까지 안전하게 이동할 수 있도록 돕습니다."
    },
    {
        "term": "내비메시 에이전트 (NavMesh Agent)",
        "description": "Unity에서 캐릭터나 객체가 내비메시를 기반으로 경로를 탐색하고 이동하도록 만들어주는 컴포넌트. 이 컴포넌트는 AI 제어를 위한 기본적인 동작을 제공하여 캐릭터가 지정된 목표를 향해 원활하게 이동할 수 있도록 합니다."
    },
    {
        "term": "캡슐 (Capsule)",
        "description": "Unity의 기본형태 중 하나로, 주로 생물체나 캐릭터를 나타내는 데 사용됩니다. 캡슐 형태는 물리 엔진에서의 충돌 감지 및 면적 계산에 유리하여 주로 플레이어 캐릭터 및 적 오브젝트에 사용됩니다."
    },
    {
        "term": "카메라 설정 (Camera Setup)",
        "description": "게임 내에서의 시점 및 시야를 정의하는 설정. 올바른 카메라 설정은 플레이어에게 게임의 세계를 효과적으로 전달하고 게임의 몰입도를 높이는 데 필수적입니다."
    },
    {
        "term": "에너지 스크립트 (Enemy Script)",
        "description": "적 캐릭터의 행동 및 동작을 정의하기 위한 코드. 이 스크립트는 적이 플레이어에게 접근하고, 공격하거나 방어하는 등의 설정을 포함하여 AI 기반의 적 행동을 제어할 수 있습니다."
    },
    {
        "term": "Look At Mouse Cursor",
        "description": "Unity에서 마우스 커서 방향으로 오브젝트를 회전시키기 위해 사용하는 기능으로, 플레이어 캐릭터가 마우스 커서를 바라보도록 설정하는 중요한 기법이다. 이를 통해 플레이어가 보다 직관적으로 게임에 참여할 수 있다."
    },
    {
        "term": "Transform 컴포넌트",
        "description": "Unity의 모든 GameObject에 포함된 Transform 컴포넌트는 오브젝트의 위치, 회전, 스케일을 관리하는 데 사용된다. 마우스 방향으로 회전 시 Transform의 rotate 메소드를 사용하여 회전 변환을 적용할 수 있다."
    },
    {
        "term": "Raycasting",
        "description": "Raycasting은 가상의 광선을 발사하여 오브젝트와의 충돌을 감지하고, 특정 지점을 파악하는 기법이다. 마우스 클릭 위치를 이용해 이동할 위치를 계산하거나 충돌 상태를 체크하는 데 주로 사용된다."
    },
    {
        "term": "Prefab",
        "description": "Unity에서 자주 사용하는 특정 GameObject의 템플릿으로, 여러 번 재사용할 수 있도록 만들어진 오브젝트이다. 프로젝트 내에서 프로젝타일과 같은 오브젝트의 복제를 효율적으로 관리할 수 있도록 돕는다."
    },
    {
        "term": "Camera 설정",
        "description": "유니티에서 카메라의 위치와 회전을 조정하여 게임의 시점을 설정하는 과정으로, 플레이어가 어떻게 게임 세계를 경험할지를 결정하는 중요한 요소이다."
    },
    {
        "term": "Input Handling",
        "description": "게임에서 사용자의 입력을 받아 처리하는 기능으로, 마우스 클릭이나 키보드 입력 등을 감지하여 플레이어의 행동에 반영하는 과정이다."
    },
    {
        "term": "Hierarchy 뷰",
        "description": "Unity의 편집 화면에서 GameObject를 계층적으로 볼 수 있는 창으로, 게임 내의 객체들 간의 관계 및 구조를 시각적으로 구성하고 관리할 수 있게 해준다."
    },
    {
        "term": "Vector3.Reflect",
        "description": "유니티의 Vector3.Reflect 메소드는 주어진 입사 벡터와 표면의 법선 벡터를 사용하여 반사 벡터를 계산하는데 사용됩니다. 이 메소드는 물리적 시뮬레이션에서 충돌과 반사 처리를 보다 효율적으로 만드는 데 중요한 역할을 합니다."
    },
    {
        "term": "입사 벡터",
        "description": "입사 벡터는 어떤 표면에 충돌하기 전의 속도 벡터로, 반사 계산에서 주어진 벡터입니다. 반사 후의 움직임을 정하는 중요한 요소로 작용합니다."
    },
    {
        "term": "법선 벡터(Normal Vector)",
        "description": "법선 벡터는 표면의 수직 방향을 나타내는 벡터로, 반사 벡터 계산에서 필수적입니다. 일반적으로 표면의 기하학적 특성에 따라 정의됩니다."
    },
    {
        "term": "OnCollision 메소드",
        "description": "유니티에서 충돌이 발생했을 때 호출되는 메소드로, OnCollisionEnter, OnCollisionStay, OnCollisionExit와 같은 다양한 이벤트에 따라 충돌 정보를 처리할 수 있습니다."
    },
    {
        "term": "Physics.Raycast",
        "description": "Raycasting은 특정 방향으로 가상의 광선을 쏘아 물체에 대한 충돌 정보를 얻는 방법입니다. 이를 통해 반사 벡터 계산과 같은 물리적 상호작용을 처리할 수 있습니다."
    },
    {
        "term": "충돌 처리(Collision Handling)",
        "description": "게임에서 물체 간의 충돌을 처리하는 과정으로, 반사, 파괴, 회전 등의 다양한 반응을 정의하여 실제와 같은 물리적 상호작용을 구현합니다."
    },
    {
        "term": "충돌점(Contact Point)",
        "description": "두 물체가 충돌할 때의 접촉 지점을 나타내는 개념으로, 해당 지점에서의 충돌 정보를 바탕으로 물체의 반사나 반응을 결정할 수 있습니다."
    },
    {
        "term": "Universal Render Pipeline (URP)",
        "description": "유니버설 렌더 파이프라인은 Unity의 렌더링 아키텍처로, 특히 성능을 최적화하고 다양한 플랫폼에서 고품질 비주얼을 제공하기 위해 설계되었습니다. 2D 및 3D 프로젝트 모두에서 적용할 수 있습니다."
    },
    {
        "term": "Lighting Settings",
        "description": "라이팅 설정은 게임 또는 애플리케이션 내에서 빛의 배치, 강도, 색상 등을 조절하여 환경을 구성하는 요소입니다. 적절한 라이팅 설정은 게임의 분위기와 시각적 품질에 큰 영향을 미칩니다."
    },
    {
        "term": "Directional Light",
        "description": "디렉셔널 라이트는 장면 내의 모든 오브젝트에 동일한 방향에서 빛을 비추는 라이팅 요소입니다. 주로 태양광 효과를 시뮬레이션하는 데 사용되며, 그림자의 크기와 형태를 조정할 수 있습니다."
    },
    {
        "term": "Global Volume",
        "description": "글로벌 볼륨은 게임 스페이스 내에서 포괄적인 시각적 효과와 조명을 제어하는 데 사용되는 Unity의 구성 요소입니다. 이 기술은 특정 영역에서 환경 효과나 포스트 프로세싱 효과를 적용할 수 있도록 지원합니다."
    },
    {
        "term": "Ambient Light",
        "description": "앰비언트 라이트는 장면 전체에 균일하게 퍼지는 자연광을 모사하는 요소로, 일반적으로 그림자 없이 부드러운 조명을 위해 사용됩니다. 어두운 환경에서 레벨의 질감을 높이고 깊이감을 추가하는 데 도움이 됩니다."
    },
    {
        "term": "Spotlight",
        "description": "스포트라이트는 특정 방향으로 빛을 집중하는 조명 종류로, 주로 특정 객체나 영역에 빛의 강도를 강조하기 위해 사용됩니다. 게임에서의 스포트라이트는 분위기를 조성하고 중요한 요소를 강조하는 데 유용합니다."
    },
    {
        "term": "Camera Background",
        "description": "카메라의 배경 설정은 비디오 게임이나 애플리케이션에서 카메라가 볼 수 있는 전체 영역의 배경 색상을 설정하는 옵션입니다. 화면의 초기 노출에 큰 영향을 미치는 중요한 요소입니다."
    },
    {
        "term": "Black Color Setting",
        "description": "어둠을 표현하기 위해 색상을 검은색으로 설정하는 것은 시각적으로 깔끔한 환경을 구현하는 데 핵심적인 기법입니다. 이는 공간에서의 깊이감과 긴장감을 부여할 수 있습니다."
    },
    {
        "term": "Find Closest Target",
        "description": "Find Closest Target은 주어진 위치에서 가장 가까운 목표 오브젝트를 찾는 알고리즘입니다. 이 알고리즘은 거리 계산을 통해 특정 기준(예: 플레이어 캐릭터)과의 거리가 가장 짧은 오브젝트를 식별합니다."
    },
    {
        "term": "Capsule",
        "description": "Capsule은 Unity에서 자주 사용되는 3D 오브젝트 형태 중 하나로, 주로 캐릭터 컨트롤러의 충돌 영역으로 사용됩니다. 이 형상은 물리 엔진과 쉽게 상호작용할 수 있도록 설계되어 있습니다."
    },
    {
        "term": "Circle",
        "description": "Circle은 2D 도형 중 하나로, 원 형태를 가진 오브젝트입니다. 게임에서 목표물, 트리거 또는 시각적 효과로 활용되며, Unity에서 SpriteRenderer를 통해 쉽게 표시할 수 있습니다."
    },
    {
        "term": "Color Change",
        "description": "색상 변화는 오브젝트의 외관을 변경하는 기법으로, 사용자에게 특정 피드백을 주거나 상태 변화를 나타낼 때 사용됩니다. Unity에서는 Material 또는 Renderer를 통해 오브젝트의 색상을 변경할 수 있습니다."
    },
    {
        "term": "Hierarchy View",
        "description": "Hierarchy View는 Unity 에디터에서 현재 씬에 존재하는 모든 오브젝트를 계층적으로 표시하는 패널입니다. 이 뷰를 통해 오브젝트의 구조를 쉽게 파악하고, 수정, 삭제할 수 있습니다."
    },
    {
        "term": "직선 발사체 (Straight Projectile)",
        "description": "직선 발사체는 목표를 향해 일정한 속도로 직선으로 이동하는 발사체로, 간단하게 구현할 수 있으며 기본적인 게임 메커니즘에서 자주 사용됩니다. 이동 속도와 방향을 설정하여, 시작 시점에서 목표 지점으로 직접 이동하도록 코딩합니다."
    },
    {
        "term": "유도 발사체 (Homing Projectile)",
        "description": "유도 발사체는 실시간으로 목표의 위치를 추적하여 그 방향으로 이동하는 발사체입니다. 이 타입은 목표가 움직일 때도 발사체가 이를 따라가도록 설정할 수 있어, 적 캐릭터와의 상호작용에서 유용하게 사용됩니다."
    },
    {
        "term": "곡선 발사체 (Bezier Curve Projectile)",
        "description": "곡선 발사체는 Bezier 곡선을 사용하여 발사체의 경로를 설정하는 방식입니다. 이 발사체는 시작점과 목표점 사이에 여러 개의 커브 포인트를 지정하여 곡선을 그리며 이동하도록 구현됩니다. 곡선의 세분화가 가능하여 경로의 조정이 이루어집니다."
    },
    {
        "term": "2차 Bezier Curve",
        "description": "2차 Bezier Curve는 두 개의 제어점을 통해 정의되는 곡선입니다. 이 곡선은 두 개의 점과 그 사이의 제어점으로 이루어져, 자연스럽고 부드러운 경로를 생성하는 데 사용됩니다."
    },
    {
        "term": "3차 Bezier Curve (Cubic Bezier Curve)",
        "description": "3차 Bezier Curve는 세 개의 제어점을 사용하여 곡선을 정의합니다. 이 곡선은 더 복잡한 형태의 경로를 만들어 낼 수 있으며, 각 포인트 간의 연결로 인해 더욱 유기적인 이동을 구현할 수 있습니다. 게임에서 정교한 행동을 구현하는 데 유리합니다."
    },
    {
        "term": "직선 발사체 (Projectile Straight)",
        "description": "직선 발사체는 특정 방향으로 일정한 속도로 직진하는 발사체입니다. 이 방식은 간단한 탄환이나 미사일 성능을 구현할 때 유용하며, Rigidbody 2D 컴포넌트를 통해 물리적 힘을 적용하여 이동합니다."
    },
    {
        "term": "유도 발사체 (Projectile Homing)",
        "description": "유도 발사체는 타겟을 향해 이동하도록 설정된 발사체입니다. 목표를 추적하는 알고리즘에 의해 방향을 조정하며, 일반적으로 게임에서 적이나 플레이어를 향해 자동으로 발사되도록 설계됩니다."
    },
    {
        "term": "곡선 발사체 (Projectile QuadraticHoming)",
        "description": "2차 곡선 발사체는 물리적 수학을 사용하여 곡선 경로로 이동하는 발사체입니다. 이 방법은 프로젝타일이 목표를 향해 일정한 곡률을 유지하며 비행할 수 있도록 합니다."
    },
    {
        "term": "3차 곡선 발사체 (Projectile CubicHoming)",
        "description": "3차 곡선 발사체는 더욱 복잡한 경로를 따라 이동하며, 곡선의 형태가 더 다양해지는 발사체입니다. 이러한 발사체는 더욱 정교한 경로 조정과 목표 추적을 필요로 하며, 이를 위해 다항식 경로를 적용합니다."
    },
    {
        "term": "Rigidbody 2D",
        "description": "유니티에서 2D 물리를 구현할 때 사용하는 컴포넌트로, 발사체의 물리적 특성을 정의합니다. 이를 통해 중력, 마찰, 충돌 등의 요소를 쉽게 적용할 수 있습니다."
    },
    {
        "term": "스킬 에미션 (Skill Emission)",
        "description": "게임 개발에서 특정 시간 간격으로 발사체를 발사하는 메커니즘을 구현하는 스크립트입니다. 이 기능은 쿨타임을 설정하고 한 번에 여러 개의 발사체를 발사하는 등의 기능을 포함합니다."
    },
    {
        "term": "경로 추적 (Path Following)",
        "description": "유도 발사체가 특정 경로를 따라 목표를 따라가는 알고리즘입니다. 이 방법은 물체의 위치를 모니터링하고 필요한 경우 방향을 조정하여 목표를 지속적으로 추적하게 합니다."
    },
    {
        "term": "Cubic Bezier Curve",
        "description": "3차 베지어 곡선은 컴퓨터 그래픽스에서 부드러운 곡선을 만들기 위해 사용되는 수학적 모델입니다. 복잡한 곡선 경로를 정의할 때 유용하며, 발사체의 경로를 설정하는 데에도 활용됩니다."
    },
    {
        "term": "Localization",
        "description": "Localization은 소프트웨어나 게임에서 다국어 지원을 위한 시스템으로, 사용자가 선택한 언어에 맞춰 인터페이스의 텍스트, 그래픽, 사운드 등을 변환하는 과정을 포함합니다. Unity에서는 Localization 패키지를 사용하여 다중 언어를 손쉽게 관리하고 적용할 수 있습니다."
    },
    {
        "term": "Text UI Localization",
        "description": "Text UI Localization은 유저 인터페이스(UI) 요소 내 텍스트를 해당 언어로 변환하는 프로세스입니다. Unity에서는 Localize String Event 컴포넌트를 사용하여 특정 텍스트 항목을 정의된 언어에 따라 자동으로 교체하는 기능을 제공합니다."
    },
    {
        "term": "Generate Font Atlas",
        "description": "Font Atlas는 글꼴을 사전 정의된 크기의 텍스처로 변환하여 게임의 성능을 높이는 기술입니다. Unity에서 폰트 아틀라스를 생성하면 다량의 텍스트를 효율적으로 화면에 출력할 수 있습니다."
    },
    {
        "term": "Language Parameter Settings",
        "description": "언어별 파라미터 설정은 사용자가 선택한 언어에 따라 UI의 다양한 속성(예: 폰트 크기 또는 스타일)을 조정하는 기능으로, Unity에서는 해당 언어로 변경 시 설정할 수 있는 방법을 제공합니다."
    },
    {
        "term": "Localization Test Script",
        "description": "이 스크립트는 언어 변경을 위한 사용자 입력(키클릭 등)을 처리하는 코드로, Unity에서 Localization Object와 연결하여 사용자가 원하는 언어로 전환할 수 있도록 돕습니다."
    },
    {
        "term": "Image UI Localization",
        "description": "Image UI Localization은 UI에서 사용하는 이미지를 특정 언어와 연계하여 전환하는 기능으로, Localize Sprite Event 컴포넌트를 사용하여 이미지 리소스를 관리합니다. 각 언어에 따라 적절한 이미지를 불러올 수 있는 방법을 제공합니다."
    },
    {
        "term": "CSV Import/Export",
        "description": "CSV 파일을 사용한 데이터 관리 방법으로, 게임 내 다양한 언어를 지원하는 텍스트 데이터를 외부 파일에서 불러오거나 내보낼 수 있습니다. 이렇게 하면 다량의 데이터로 작업할 때 효율성을 높일 수 있습니다."
    },
    {
        "term": "Item Data Management",
        "description": "아이템 데이터 관리란 게임 내 아이템 정보를 구조화하여 설정하고 출력하는 과정입니다. Unity 내에서 각 언어에 맞춰 아이템의 정보를 표시하는 스크립트를 통해, 사용자가 다양한 언어로 게임을 즐길 수 있도록 합니다."
    },
    {
        "term": "아이템 수집 효과 (Item Collect Effect)",
        "description": "게임에서 플레이어가 아이템을 획득했을 때 UI 상에서 시각적으로 표현하는 효과로, 이펙트가 아이템의 위치에서 UI로 이동하여 최종적으로 아이템 카운트가 증가하는 등의 과정을 포함하는 시각적 요소입니다."
    },
    {
        "term": "Unity 엔진 (Unity Engine)",
        "description": "비디오 게임 개발을 위한 다목적 엔진으로, 2D 및 3D 게임 제작에 매력적인 도구입니다. Unity는 드래그 앤 드롭 방식으로 쉽게 접근할 수 있으며, C#을 사용하여 스크립팅을 지원합니다."
    },
    {
        "term": "아이템 UI (Item UI)",
        "description": "게임 내에서 아이템의 시각적 표현을 관리하는 사용자 인터페이스 요소로, 아이템의 아이콘 및 카운트를 표시하여 플레이어가 현재 보유한 아이템 정보를 제공합니다."
    },
    {
        "term": "ItemCollector 스크립트",
        "description": "아이템 획득 이펙트를 관리하는 스크립트로, 아이템을 수집할 때 이펙트를 발생시키고 UI의 변화에 연동하여 아이템의 상태를 제어합니다."
    },
    {
        "term": "ItemCollectEffect 스크립트",
        "description": "아이템 이펙트의 이동을 제어하는 스크립트로, 아이템 획득 효과의 애니메이션 및 UI로의 이동 경로를 설정하여 시각적인 피드백을 제공합니다."
    },
    {
        "term": "UI 요소 등록 (UI Element Registration)",
        "description": "Unity에서 UI를 구성하기 위해 요소들을 등록하는 과정으로, 각 UI 컴포넌트를 스크립트 내 특정 변수에 참조하여 제어할 수 있도록 설정하는 과정입니다."
    },
    {
        "term": "게임 오브젝트 (Game Object)",
        "description": "Unity 엔진에서 사용되는 기본적인 요소로, 모든 타입의 개체를 나타내며, 이들 오브젝트에 컴포넌트를 추가하여 특정 기능이나 동작을 부여합니다."
    },
    {
        "term": "Anchors와 Pivot",
        "description": "UI 요소의 위치와 회전을 정의하는 속성으로, Anchors는 UI 오브젝트의 기준점을 설정하고, Pivot은 UI 오브젝트가 회전하거나 축척을 변화시킬 때의 중심점을 정의합니다."
    },
    {
        "term": "Memory Pooling",
        "description": "게임 오브젝트의 메모리 관리를 최적화하기 위한 기술로, 오브젝트를 재사용하여 메모리 할당과 해제를 줄이는 기법입니다. 이 기법을 사용하면 게임의 성능을 향상시킬 수 있습니다."
    },
    {
        "term": "Fade Effect",
        "description": "게임 내 요소의 투명도를 조절하는 시각적 효과로, 화면의 요소를 점진적으로 나타내거나 사라지게 하는 방식으로 주로 전환 효과나 인터페이스 변경 시 사용됩니다."
    },
    {
        "term": "Navmesh 2D",
        "description": "Navmesh 2D는 Unity 엔진에서 2D 환경을 위한 내비게이션 기능으로, 주로 적 캐릭터나 NPC의 경로 탐색에 사용됩니다. 이를 통해 오브젝트가 장애물을 피하며 효율적으로 목표 지점으로 이동할 수 있도록 돕습니다."
    },
    {
        "term": "AI Navigation",
        "description": "AI 내비게이션은 인공지능이 환경 내에서 경로를 탐색하고 자율적으로 이동할 수 있도록 하는 기술입니다. Unity에서는 이러한 기능을 복잡한 경로 계산을 통해 쉽게 구현할 수 있는 시스템으로 제공하고 있습니다."
    },
    {
        "term": "Enemy Spawner",
        "description": "Enemy Spawner는 특정 위치에 적 오브젝트를 생성하는 기능을 가진 스크립트입니다. 이 스크립트는 게임 내에서 플레이어와의 상호작용을 증대시키고, 게임의 난이도를 조정하는 데 활용됩니다."
    },
    {
        "term": "Navigation Surface",
        "description": "Navigation Surface는 Unity에서 경로 탐색을 위한 영역을 정의하는 컴포넌트입니다. 3D 프로젝트에서 사용되던 기능을 2D 환경에서도 적용할 수 있도록 변형되어 사용됩니다."
    },
    {
        "term": "Navigation Mesh Agent",
        "description": "Navigation Mesh Agent는 경로 탐색을 담당하는 AI 오브젝트에 부착되는 컴포넌트입니다. 이 에이전트는 내비게이션 메시를 기반으로 자동으로 움직이며, 다양한 속성으로 제어가 가능합니다."
    },
    {
        "term": "Baking",
        "description": "Baking은 내비게이션 메시를 생성하는 과정으로, 경로 데이터가 메모리에 저장되어 경로 탐색 시 신속히 사용할 수 있게 합니다. 이 과정을 통해 Unity는 환경의 물리적 구조를 이해하고 효과적인 경로 계산을 수행할 수 있습니다."
    },
    {
        "term": "Behavior Tree",
        "description": "행동 트리는 AI 캐릭터의 행동을 제어하고 상태를 관리하기 위해 사용되는 구조로, 비선형의 복잡한 AI 결정 과정을 모듈화하여 쉽게 구현할 수 있게 해준다. 유니티에서는 노드 기반으로 관리할 수 있으며, 다양한 AI 행동을 설정할 수 있는 기능을 제공한다."
    },
    {
        "term": "Patrol Behavior",
        "description": "순찰 행동은 적 AI가 특정 지점을 주기적으로 돌아다니도록 설정하는 행위로, Action 노드를 통해 구현된다. 이 행동을 설정할 때 경로를 정의하고, 적이 이를 순환하도록 프로그래밍할 수 있다."
    },
    {
        "term": "Action Node",
        "description": "행동 노드는 Behavior Tree에서 실제 행동을 정의하는 블록이다. AI에게 특정 작업을 수행하도록 지시하며, 순찰과 같은 다양한 행동을 설정할 수 있다."
    },
    {
        "term": "Sequence Node",
        "description": "시퀀스 노드는 여러 행동이나 조건을 순차적으로 실행하도록 설정하는 노드로, AI 행동의 흐름을 명확하게 구성할 수 있다. 예를 들어, 일정 시간 대기 후 순찰 행동으로 이어지는 구조를 설정할 때 사용된다."
    },
    {
        "term": "Blackboard",
        "description": "블랙보드는 Behavior Tree에서 사용하는 변수 목록으로, AI의 상태나 정보를 저장하는 역할을 한다. 개발자는 필요에 따라 변수를 추가하고 이를 인스펙터 뷰에서 관리할 수 있다."
    },
    {
        "term": "Unity Package Manager",
        "description": "유니티 패키지 매니저는 필요한 기능을 추가할 수 있도록 다양한 패키지를 설치하고 관리할 수 있는 툴이다. Behavior 패키지를 설치하여 AI 행동 노드 및 기능을 활용할 수 있다."
    },
    {
        "term": "EnemyType00",
        "description": "Behavior 그래프에서 설정할 적 AI의 종류를 명시하는 이름으로, 이를 통해 특정 AI 유형에 적합한 행동을 설정할 수 있으며, 다양한 적 AI를 정의하고 구현할 수 있는 기초가 된다."
    },
    {
        "term": "Idle 상태",
        "description": "Idle 상태는 적 AI가 대기 중일 때의 상태를 의미한다. 이 상태에서는 일반적으로 AI가 수행할 수 있는 행동이 제한된다. Idle 상태에서 플레이어를 탐지하면 추적(Chase) 상태로 전환될 수 있다."
    },
    {
        "term": "Patrol 상태",
        "description": "Patrol 상태는 적 AI가 정해진 경로를 따라 순찰하는 행동을 뜻한다. 이 상태에서는 주변 환경을 살피며 특정 지점 사이를 이동하는 것을 포함한다. 기능적으로 AI가 보안을 유지하거나 자원을 탐색하는 경우에 효과적이다."
    },
    {
        "term": "Wander 상태",
        "description": "Wander 상태는 적 AI가 특정 목적 없이 자유롭게 탐색하는 행동이다. 이 상태에서는 사전 정의된 경로가 없이 주위를 돌아다니며, 자연스럽고 비선형적인 움직임을 나타낼 수 있다."
    },
    {
        "term": "Switch 노드",
        "description": "Switch 노드는 Behavior Tree에서 여러 상태 중 하나를 선택하여 실행하도록 하는 결정적 노드이다. 현재 상태(CurrentState)에 따라 적 AI의 행동을 유연하게 전환하도록 설정할 수 있다."
    },
    {
        "term": "TryInOrder 노드",
        "description": "TryInOrder 노드는 Behavior Tree에서 여러 조건을 순차적으로 체크하여 실행하는 노드이다. 첫 번째 성공적인 조건이 발견되면, 그 행동을 실행하게 되고 다음 조건으로 진행하지 않는다."
    },
    {
        "term": "Action 노드",
        "description": "Action 노드는 AI가 실행해야 하는 특정 행동을 지정하는 노드로, 예를 들어 적이 특정 방향으로 이동하는 것을 지시할 수 있다. AI의 행동을 구체적으로 수행하기 위해 필수적인 요소이다."
    },
    {
        "term": "AI 추적 (Chase)",
        "description": "AI 추적은 적 캐릭터가 플레이어를 향해 이동하는 동작을 의미합니다. 거리 계산을 통해 플레이어와의 거리와 상태를 평가하여 이동 상태를 결정하는 로직이 포함됩니다."
    },
    {
        "term": "거리 계산",
        "description": "거리 계산은 두 객체 사이의 거리를 측정하여 AI의 행동을 결정하는 데 활용됩니다. 이 과정에서 CurrentDistance, AttackDistance, ChaseDistance 등 다양한 변수를 사용하여 행동 전환이 이루어집니다."
    },
    {
        "term": "상태 전환 (State Transition)",
        "description": "상태 전환은 AI가 현재 상태에서 다른 상태로 변화하는 과정을 말합니다. 플레이어와의 거리 정보에 따라 Idle, Chase, Attack 등으로 상태가 전환됩니다."
    },
    {
        "term": "플로우 변수 (Flow Variables)",
        "description": "플로우 변수는 AI의 동작을 제어하는 데 필수적인 값들을 저장하는 변수입니다. 이 영상에서는 CurrentDistance, AttackDistance, ChaseDistance, FallOutDistance와 같은 변수를 생성하여 사용합니다."
    },
    {
        "term": "Enemy Prefab",
        "description": "Enemy Prefab은 적 캐릭터의 속성과 행동을 정의한 Unity의 오브젝트입니다. 다양한 컴포넌트를 추가하여 다른 타입의 적들을 설정할 수 있으며, 이는 게임의 다양성과 난이도를 높이는 데 기여합니다."
    },
    {
        "term": "발사체 (Projectile)",
        "description": "발사체는 적이 공격을 수행하기 위해 사용되는 오브젝트로, 이 영상에서는 Circle Collider 2D와 Rigidbody 2D를 통해 물리적 특성을 설정하고 Sprite Renderer로 시각화를 합니다."
    },
    {
        "term": "무기 클래스 (Weapon Class)",
        "description": "무기 클래스는 각각의 무기에 대한 속성을 정의하며, WeaponBase라는 기본 클래스를 통해 상속받아 다양한 무기에 대한 변화를 줄 수 있는 구조입니다."
    },
    {
        "term": "NavMesh",
        "description": "NavMesh는 AI가 이동할 수 있는 환경의 메쉬를 생성하는 것으로, 주어진 3D 물체들의 경계와 물리적 상호작용을 기반으로 구성된다. 주로, 장애물 회피 및 최적 경로 계산을 위해 사용된다."
    },
    {
        "term": "NavMesh Surface",
        "description": "게임 엔진 내부에서 AI가 경로를 탐색할 수 있도록 하는 메쉬의 표면을 정의하는 컴포넌트이다. 이를 통해 특정 영역에 대한 NavMesh를 생성하고 저장할 수 있다."
    },
    {
        "term": "NavMesh Agent",
        "description": "AI 캐릭터 또는 오브젝트가 경로를 따라 이동하도록 설정하는 컴포넌트로, 각종 속성(반지름, 높이, 속도 등)을 통해 에이전트의 이동 특성을 조정할 수 있다."
    },
    {
        "term": "SetDestination",
        "description": "NavMesh Agent가 이동할 목표 위치를 설정하기 위한 함수다. 이 함수를 사용하여 에이전트가 특정 목표로 이동하도록 지시할 수 있다."
    },
    {
        "term": "NavMesh Obstacle",
        "description": "게임 환경 내부의 장애물을 정의하는 컴포넌트로, 움직이는 장애물과 정적 장애물을 구분할 수 있다. 이 컴포넌트를 통해 장애물이 에이전트의 경로에 영향을 미치게 할 수 있다."
    },
    {
        "term": "Carve",
        "description": "NavMesh Obstacle의 속성 중 하나로, 장애물이 있는 공간에서 NavMesh를 자동으로 조정하여 경로 최적화를 개선하는 기능을 제공한다."
    },
    {
        "term": "NavMesh Modifier",
        "description": "NavMesh의 특정 속성과 범위를 세밀하게 조절하기 위해 사용되는 컴포넌트로, 영역을 추가로 수정하거나 제외할 수 있다."
    },
    {
        "term": "NavMesh Modifier Volume",
        "description": "NavMesh Modifier의 구체적인 적용 범위를 정하는 컴포넌트로, 이 범위 내에서 NavMesh의 속성을 변경하거나 영향을 줄 수 있다."
    },
    {
        "term": "유니티 시네머신",
        "description": "유니티의 시네머신( Cinemachine) 패키지는 고급 카메라 기능을 제공하여 게임 개발자들이 보다 자연스럽고 몰입감 있는 카메라 연출을 할 수 있도록 돕는 도구이다."
    },
    {
        "term": "가상 카메라(Virtual Camera)",
        "description": "가상 카메라는 시네머신 내에서 다양한 카메라 설정을 통해 개별 카메라 피드를 설정할 수 있는 기능으로, 여러 종류가 제공된다."
    },
    {
        "term": "블렌드 리스트 카메라",
        "description": "블렌드 리스트 카메라는 여러 개의 가상 카메라를 설정하고, 시간에 따라 카메라 간의 전환을 자연스럽게 만들어주는 기능이다."
    },
    {
        "term": "스테이트 드라이브 카메라",
        "description": "스테이트 드라이브 카메라는 플레이어의 애니메이션 상태에 따라 카메라 전환을 제어하는 기능으로, 연출의 다양성을 더한다."
    },
    {
        "term": "클리어샷 카메라",
        "description": "클리어샷 카메라는 장애물을 감지하고 자동으로 전환하여 플레이어의 시선을 최적화하는 카메라 설정을 지원하는 기능이다."
    },
    {
        "term": "돌리 카메라",
        "description": "돌리 카메라는 카메라가 특정 경로를 따라 움직이도록 설정할 수 있는 기능으로, 트랙을 만들어 이동 경로를 정의할 수 있다."
    },
    {
        "term": "타겟 그룹 카메라",
        "description": "타겟 그룹 카메라는 여러 오브젝트를 동시에 추적하여 촬영할 수 있는 기능으로, 주목할 만한 전투 장면이나 다수의 목표를 캡처하는 데 유용하다."
    },
    {
        "term": "믹싱 카메라",
        "description": "믹싱 카메라는 여러 카메라의 피드를 혼합하여 하나의 결과물을 생성하는 기능으로, 각 카메라의 비율을 조정하여 원하는 효과를 연출할 수 있다."
    },
    {
        "term": "2D 카메라",
        "description": "2D 카메라는 2D 게임의 특성에 맞추어 설계된 가상 카메라로, 정의된 세팅을 통해 2D 환경에서도 효율적으로 활용될 수 있다."
    },
    {
        "term": "시네머신 브레인",
        "description": "시네머신 브레인은 가상 카메라와 메인 카메라 간의 전환과 효과를 관리하는 핵심 컴포넌트로, 다양한 카메라 연출을 용이하게 한다."
    },
    {
        "term": "아바타 마스크",
        "description": "아바타 마스크는 유니티에서 캐릭터의 특정 부위에 애니메이션을 적용하기 위해 사용하는 도구입니다. 이를 통해 애니메이션의 혼합과 조절이 가능하여 캐릭터의 동작을 더욱 유동적이고 자연스럽게 표현할 수 있습니다."
    },
    {
        "term": "혼합 애니메이션",
        "description": "혼합 애니메이션은 여러 애니메이션을 결합하여 한 캐릭터의 다양한 동작을 표현하는 기법입니다. 이 방법을 통해 한 캐릭터가 서로 다른 동작을 동시에 수행하는 것처럼 보이게 할 수 있습니다."
    },
    {
        "term": "레이어",
        "description": "애니메이션 레이어는 유니티에서 여러 애니메이션을 동시에 사용할 수 있도록 구성하는 방법입니다. 각 레이어는 별도의 애니메이션을 적용할 수 있으며, 아바타 마스크와 함께 사용하여 특정 부위에만 애니메이션을 적용하는 데 유용합니다."
    },
    {
        "term": "Weight 값",
        "description": "Weight 값은 애니메이션 레이어에서 애니메이션의 강도를 조절하는 매개변수입니다. 값을 조정함으로써 적용되는 애니메이션의 비율을 정할 수 있어, 섬세한 애니메이션 조합이 가능합니다."
    },
    {
        "term": "자연스러운 전환",
        "description": "자연스러운 전환은 두 개 이상의 애니메이션 사이의 이동을 부드럽게 만드는 기법입니다. 애니메이션 간의 혼합 비율과 전환 시간을 잘 설정하여 현실감 있는 움직임을 창출할 수 있습니다."
    },
    {
        "term": "휴머노이드",
        "description": "유니티에서 휴머노이드는 인간 캐릭터에 적합한 모델을 가리키며, 애니메이션 마스크를 만들 때 설정할 수 있는 옵션입니다. 휴머노이드 방식은 캐릭터의 뼈대와 애니메이션을 보다 간편하게 처리할 수 있게 해줍니다."
    },
    {
        "term": "상태이상 애니메이션",
        "description": "상태이상 애니메이션은 캐릭터의 다양한 상태를 시각적으로 표현하기 위해 사용되는 애니메이션으로, 체력, 부상, 피로도 등의 변수에 따라 변화하는 동작을 포함합니다."
    },
    {
        "term": "Mixamo",
        "description": "Mixamo는 3D 캐릭터와 애니메이션을 제공하는 온라인 플랫폼으로, 사용자들이 손쉽게 애니메이션을 다운로드하고 캐릭터에 적용할 수 있도록 지원합니다."
    },
    {
        "term": "Blend Tree",
        "description": "Blend Tree는 Unity의 애니메이션 시스템에서 애니메이션 조합을 관리하는 방식으로, 서로 다른 애니메이션을 원활하게 통합하여 자연스러운 동작 전환을 제공합니다."
    },
    {
        "term": "리깅(Rigging)",
        "description": "리깅은 3D 모델에 뼈대를 추가하여 애니메이션을 할 수 있도록 만드는 과정으로, 일반적으로 휴머노이드 캐릭터에 적용됩니다."
    },
    {
        "term": "애니메이터 컨트롤러",
        "description": "애니메이터 컨트롤러는 Unity 내에서 애니메이션의 상태 전환 및 블렌딩을 관리하는 컴포넌트로, 캐릭터의 동작을 제어할 수 있는 핵심 요소입니다."
    },
    {
        "term": "체력 UI",
        "description": "체력 UI는 게임에서 캐릭터의 현재 체력 상태를 시각적으로 표현하는 인터페이스로, 플레이어가 캐릭터의 상태를 파악하는 데 도움을 줍니다."
    },
    {
        "term": "상태 변화 스크립트",
        "description": "상태 변화 스크립트는 캐릭터의 체력 감소와 같은 조건에 따라 애니메이션 상태를 변경하는 논리를 구현하는 코드로, 게임의 현실성을 높이는 데 기여합니다."
    },
    {
        "term": "피격 애니메이션",
        "description": "피격 애니메이션은 캐릭터가 공격을 받았을 때 재생되는 애니메이션으로, 게임 내에서의 반응성과 몰입감을 높이는 중요한 요소입니다."
    },
    {
        "term": "현실감 있는 게임",
        "description": "현실감 있는 게임은 캐릭터의 행동과 환경 간의 상호작용이 실제와 유사하게 이루어지는 게임으로, 플레이어에게 아웃 오브 게임 경험을 제공합니다."
    },
    {
        "term": "자연스러운 애니메이션 전환",
        "description": "자연스러운 애니메이션 전환은 서로 다른 애니메이션 간의 전환이 매끄럽게 이루어지도록 하여 플레이어에게 일관된 경험을 제공하는 기법입니다."
    },
    {
        "term": "유니티 애니메이션",
        "description": "유니티 엔진에서 3D 모델 및 캐릭터의 움직임을 제어하는 기능으로, 애니메이션 클립을 생성하고 이를 활용하여 다양한 동작을 시뮬레이션할 수 있게 해준다."
    },
    {
        "term": "휴머노이드 캐릭터",
        "description": "사람의 형태를 가진 3D 캐릭터를 지칭하며, 일반적으로 유니티 애니메이션 시스템에서 휴머노이드 리깅 및 애니메이션을 지원하기 위해 필요하다."
    },
    {
        "term": "애니메이션 클립",
        "description": "특정 애니메이션 동작을 정의하는 파일로, 유니티에서는 다양한 애니메이션 클립을 활용하여 복잡한 애니메이션 내역을 구성할 수 있다."
    },
    {
        "term": "애니메이션 타입",
        "description": "유니티에서 애니메이션을 설정할 때 사용하는 타입으로, 주로 '휴머노이드', 'Generic' 등으로 구분되며 캐릭터의 리깅 방식에 따라 달라진다."
    },
    {
        "term": "키 입력 감지",
        "description": "사용자의 키보드 입력을 감지하고, 이에 따른 행동이나 애니메이션 등의 반응을 트리거하는 시스템으로, 게임의 플레이어 상호작용을 정의하는 데 중요하다."
    },
    {
        "term": "애니메이션 전환",
        "description": "하나의 애니메이션에서 다른 애니메이션으로 부드럽게 전환하는 작업으로, '파라미터', '트리거', '루프 타임' 같은 요소들을 조정하여 자연스러운 변화를 이끌어낸다."
    },
    {
        "term": "스켈레탈 애니메이션",
        "description": "3D 모델의 뼈대(스켈레톤)를 기반으로 진행되는 애니메이션 기법으로, 모델의 각 부분을 조정하여 자연스러운 움직임을 구현할 수 있다."
    },
    {
        "term": "아바타",
        "description": "유니티에서 애니메이션과 캐릭터를 연결하는 역할을 하며, 애니메이션을 캐릭터의 뼈대에 맞추어 재생하도록 돕는 요소이다."
    },
    {
        "term": "파라미터",
        "description": "애니메이션의 상태를 제어하기 위한 변수로, 트리거, 불 값, 인트형, 플롯형 등의 다양한 형식을 지원한다. 파라미터를 통해 애니메이션 전환 조건을 결정하거나, 스크립트를 통해 애니메이션을 제어할 수 있다."
    },
    {
        "term": "해제 엑시타임 (Exit Time)",
        "description": "애니메이션 전환 시 현재 애니메이션이 끝날 때까지 대기한 후 다음 애니메이션으로 전환하는지 여부를 결정하는 설정이다. 이 값을 조정하여 전환을 부드럽게 할 수 있다."
    },
    {
        "term": "전환 속도 (Transition Duration)",
        "description": "애니메이션 전환에 소요되는 시간을 조절하는 설정으로, 값을 늘리거나 줄여 전환의 속도를 조절할 수 있다. 긴 값을 설정하면 서서히 전환되고, 짧은 값을 설정하면 빠르게 전환된다."
    },
    {
        "term": "조건 (Conditions)",
        "description": "애니메이션을 전환하기 위한 규칙을 정의하면서, 조건이 만족될 때에만 애니메이션 전환이 이루어지도록 설정할 수 있는 기능이다. 여러 조건을 조합하여 복잡한 전환을 구현할 수 있다."
    },
    {
        "term": "트리거 (Trigger)",
        "description": "특정 조건이 만족될 때 애니메이션 전환을 즉각적으로 발생시키는 파라미터 유형으로, 이벤트 기반 애니메이션 전환에 자주 사용된다."
    },
    {
        "term": "그루핑 (Grouping)",
        "description": "애니메이션 전환 시 여러 개의 조건을 하나의 그룹으로 묶어 관리할 수 있는 기능이다. 이를 통해 복잡한 애니메이션 전환 조건을 보다 간편하게 설정할 수 있다."
    },
    {
        "term": "클릭 이동 (Click Move)",
        "description": "유닛을 특정 위치로 이동시키기 위한 명령 방식으로, 사용자가 클릭한 지점으로 캐릭터나 유닛이 자동으로 이동하는 기능이다. 이 방식은 전략 게임이나 RPG에서 자주 사용된다."
    },
    {
        "term": "내비게이션 시스템 (Navigation System)",
        "description": "유니티에서 제공하는 기능으로, 게임 오브젝트가 환경을 인식하고 경로를 계산하여 이동하게 할 수 있는 시스템이다. 이를 통해 개발자는 복잡한 환경 속에서 유닛의 이동을 효율적으로 제어할 수 있다."
    },
    {
        "term": "내비 메시 (NavMesh)",
        "description": "내비게이션 메시의 약자로, 게임 씬 내에서 유닛이 이동할 수 있는 영역을 정의한 데이터 구조이다. NavMesh는 경로 탐색 알고리즘이 사용할 수 있는 기반을 제공하여 이동 경로를 효율적으로 생성할 수 있게 한다."
    },
    {
        "term": "베이킹 (Baking)",
        "description": "NavMesh의 생성을 위해 씬 내의 장애물 및 이동 가능한 경로를 분석하여 최적의 경로 데이터를 생성하는 과정이다. 유니티 내비게이션 창에서 '베이크' 탭을 클릭하여 수행할 수 있다."
    },
    {
        "term": "에이전트 (Agent)",
        "description": "내비 메시 에이전트는객체가 NavMesh 위에서 이동할 수 있도록 지원하는 구성 요소이다. 주요 속성으로는 속도, 회전, 경로 조정 등이 있으며 이에 따라 캐릭터의 행동을 조절할 수 있다."
    },
    {
        "term": "애니메이션 (Animation)",
        "description": "게임 내 캐릭터의 움직임을 생동감 있게 표현하기 위해 사용되는 기술이다. 플레이어의 클릭 이동 명령에 따라 애니메이션 상태를 전환하고 연동하여 보다 현실감 있는 액션을 구현할 수 있다."
    },
    {
        "term": "시네머신 (Cinemachine)",
        "description": "유니티의 카메라 시스템으로, 다양한 카메라 관점을 설정하고 조절할 수 있는 도구이다. 주로 각 씬에서의 카메라 움직임과 시점을 최적화하기 위해 사용된다."
    },
    {
        "term": "에셋스토어 (Asset Store)",
        "description": "유니티에서 제공하는 온라인 마켓플레이스로, 다양한 3D 모델, 스크립트, 환경 설정 등을 판매하고 구매할 수 있는 플랫폼이다. 개발자는 필요에 따라 자원을 구매하고 프로젝트에 활용할 수 있다."
    },
    {
        "term": "Navigation System",
        "description": "유니티에서 AI 캐릭터의 이동 경로를 계산하고 관리하는 시스템으로, 이를 통해 개발자는 복잡한 환경 속에서 효과적으로 목표 지점까지 이동하는 기능을 구현할 수 있다."
    },
    {
        "term": "Static Check",
        "description": "오브젝트가 내비메시 계산에 포함되는지를 결정하는 속성으로, 체크되어 있는 객체는 내비게이션 경로 계산에 사용되고, 체크가 해제된 객체는 제외된다."
    },
    {
        "term": "Dynamic Bake",
        "description": "런타임 중에 NavMesh를 동적으로 업데이트하는 기술로, 특정 추가 패키지를 통해 가능하다. 이를 통해 장애물의 추가 및 제거와 같은 변화를 실시간으로 처리할 수 있다."
    },
    {
        "term": "Off-Mesh Link",
        "description": "특정 지점 사이를 연결하여 캐릭터가 점프하거나 다른 방식으로 이동할 수 있도록 돕는 컴포넌트로, 장애물이 있는 지형을 넘어설 수 있는 방법을 제공한다."
    },
    {
        "term": "Navigation Area",
        "description": "내비게이션 시스템 내에서 장애물이나 지형의 특성을 반영하여 경로 계산의 코스트를 설정하는 레이어의 일종으로, 각 구역의 이동 난이도를 조정할 수 있다."
    },
    {
        "term": "Cost",
        "description": "특정 지형이나 장애물의 이동에 필요한 비용을 나타내며, 높은 코스트는 더 어렵고 느리게 이동하게 함으로써 AI의 경로 선택에 영향을 미친다."
    },
    {
        "term": "고급 네비메쉬(Advanced NavMesh)",
        "description": "고급 네비메쉬는 Unity의 내비게이션 시스템의 확장 기능으로, 런타임 중에 부분적으로 네비메쉬를 베이크할 수 있는 기능을 제공하며, 다양한 에이전트 별로 개별 네비메쉬를 생성할 수 있도록 지원한다."
    },
    {
        "term": "Unity 에디터(Unity Editor)",
        "description": "Unity 에디터는 게임 개발을 위해 필요한 모든 기능을 제공하는 통합 개발 환경(IDE)으로, 다양한 컴포넌트 추가, 스크립트 작성 및 게임 환경 구성 작업을 수행할 수 있다."
    },
    {
        "term": "베이크(Baking)",
        "description": "베이크는 네비메쉬 데이터를 사전에 계산하여 저장하는 과정으로, 런타임 시 이동 경로를 효율적으로 계산할 수 있도록 도와준다. 이를 통해 게임 성능을 향상시킬 수 있다."
    },
    {
        "term": "NavMeshSurface",
        "description": "NavMeshSurface는 네비게이션 메시를 생성하는 Unity의 컴포넌트로, 지정된 구역 내에서 오브젝트의 배치 및 장애물 유무에 따라 네비메쉬를 계산하고 생성하는 역할을 한다."
    },
    {
        "term": "Unity 2022",
        "description": "Unity 2022는 Unity 게임 엔진의 최신 버전 중 하나로, 고급 네비메쉬와 같은 새로운 기능을 정식 패키지로 지원하여 개발자들이 더욱 쉽게 사용할 수 있도록 개선되었다."
    },
    {
        "term": "에이전트(Agent)",
        "description": "에이전트는 게임 세계 내에서 이동하는 객체를 의미하며, 네비게이션 시스템을 통해 자동으로 경로를 찾고 목표 지점으로 이동할 수 있도록 만들어진 AI 캐릭터를 포함한다."
    },
    {
        "term": "GitHub",
        "description": "GitHub는 소스 코드 관리 및 버전 관리를 위한 플랫폼으로, Unity의 고급 네비메쉬와 같은 오픈 소스를 다운로드하거나, 다양한 프로젝트를 호스팅하는 데 사용된다."
    },
    {
        "term": "압축 해제(Unzipping)",
        "description": "압축 해제는 파일이나 폴더가 압축된 형식에서 원래의 형태로 복원하는 작업으로, 네비메쉬 관련 파일들을 사용하기 위해 필요한 초기 단계이다."
    },
    {
        "term": "클리어(Clear)",
        "description": "클리어는 기존에 베이크된 네비메쉬 데이터를 삭제하는 방법으로, 새로운 환경 변경에 맞춰 새로운 베이크 작업을 수행할 수 있도록 한다."
    },
    {
        "term": "애니메이션 리타게팅",
        "description": "애니메이션 리타게팅은 기존 애니메이션 데이터와 새 모델의 본 구조를 매칭하여, 애니메이션을 쉽게 재사용할 수 있게 해주는 기술입니다. 이 기술을 통해 다양한 캐릭터에 동일한 애니메이션을 적용함으로써 시간과 노력을 절약할 수 있습니다."
    },
    {
        "term": "스키닝(Skinning)",
        "description": "스키닝은 리깅 과정에서 설정된 본과 3D 모델 메쉬 간의 관계를 정의하는 단계로, 본의 움직임에 따라 메쉬가 어떻게 변형될지를 설명합니다. 일반적으로 두 가지 방법으로 이루어지며, 뼈 격자 스키닝과 완전 스키닝이 있습니다."
    },
    {
        "term": "Humanoid",
        "description": "유니티에서 애니메이션 리타게팅을 적용하려면 애니메이션의 타입이 'Humanoid'로 설정되어야 합니다. 이는 유니티가 사람 형태의 애니메이션 및 본 구조를 인식하고, 다른 Humanoid 캐릭터 간에 애니메이션 재사용을 가능하게 합니다."
    },
    {
        "term": "키 프레임(Key Frame)",
        "description": "키 프레임은 애니메이션에서 특정 시간대에 설정된 캐릭터의 몸체 위치와 회전을 정의하는 프레임입니다. 애니메이션은 이 키 프레임 간의 변화를 기반으로 보간하여 자연스러운 움직임을 생성합니다."
    },
    {
        "term": "애니메이션 컨트롤러(Animation Controller)",
        "description": "유니티에서 애니메이션을 관리하고 전환하는 객체로, 캐릭터의 상태에 따라 어떤 애니메이션이 재생될지를 정의합니다. 이를 통해 복잡한 애니메이션 트리를 구성할 수 있습니다."
    },
    {
        "term": "3D 모델링",
        "description": "3D 모델링은 3D 컴퓨터 그래픽스를 사용해 물체의 형체를 생성하는 과정입니다. 이러한 모델은 게임, 영화, 애니메이션 등 다양한 분야에서 사용되며, 리깅 및 애니메이션을 통해 움직임을 추가할 수 있습니다."
    },
    {
        "term": "샘플 레이트 (Sample Rate)",
        "description": "샘플 레이트는 애니메이션 클립이 초당 몇 개의 프레임으로 재생될지를 결정하는 값으로, 이는 애니메이션의 전체 속도와 부드러움을 직결적으로 영향을 미친다. 일반적으로 샘플 레이트는 게임의 목표 프레임에 맞춰 30 또는 60 프레임으로 설정된다."
    },
    {
        "term": "프레임 (Frame)",
        "description": "프레임은 애니메이션이나 비디오에서 각각의 독립적인 정지된 이미지를 의미한다. 애니메이션은 이러한 프레임을 빠르게 연속적으로 보여줌으로써 움직임을 만들어낸다."
    },
    {
        "term": "유니티 2018과 2019 버전 차이",
        "description": "유니티 2018 버전에서는 애니메이션 샘플 레이트를 직접 입력하는 방법으로 설정할 수 있지만, 2019 버전에서는 샘플 레이트를 조정하는 UI가 변경되었다. 새로운 방식에서는 Show Sample Rate와 Set Sample Rate 기능을 통해 사용자가 값을 선택할 수 있도록 구성되어 있다."
    },
    {
        "term": "애니메이션 뷰 (Animation View)",
        "description": "애니메이션 뷰는 유니티에서 애니메이션 클립을 생성하고 편집하는 데 사용되는 인터페이스이다. 사용자는 이 뷰에서 애니메이션의 다양한 속성들을 조절하고 주요 키프레임을 추가하여 애니메이션을 구성할 수 있다."
    },
    {
        "term": "키프레임 (Keyframe)",
        "description": "키프레임은 애니메이션에서 특정 시간에 적용할 속성이 저장된 프레임이다. 애니메이션의 주요 포인트를 정의하며, 이들 사이의 변화를 통해 애니메이션이 만들어진다."
    },
    {
        "term": "Transform (변형)",
        "description": "유니티에서 Transform은 물체의 위치, 회전 및 크기를 정의하는 컴포넌트로, 게임 오브젝트의 물리적 속성을 조정하는 데 필수적이다."
    },
    {
        "term": "부드러운 애니메이션 (Smooth Animation)",
        "description": "부드러운 애니메이션은 샘플 레이트가 적절하게 설정되어 있어, 움직임이 자연스럽고 끊김 없이 진행되는 애니메이션을 의미한다. 불충분한 샘플 레이트는 애니메이션의 품질을 저하할 수 있다."
    },
    {
        "term": "프로젝트 MOD",
        "description": "넥슨이 개발한 메타버스 플랫폼으로, 사용자들이 자신만의 게임 및 콘텐츠를 제작하고 공유할 수 있는 공간. 이 플랫폼은 아바타 커스터마이징, 맵 제작 등 다양한 기능을 제공하며, 유용한 도구로는 유니티 엔진이 사용됨."
    },
    {
        "term": "메타버스",
        "description": "가상의 세계와 실제 세계가 연결된 디지털 환경을 일컫으며, 사회적 상호작용, 경제 활동, 콘텐츠 제작 등이 가능한 멀티유저 공간을 포함. 메타버스는 다양한 산업 분야에 응용될 수 있는 가능성이 있어 최근 큰 주목을 받고 있음."
    },
    {
        "term": "공모전",
        "description": "창작자와 개발자가 특정 주제나 목표에 따라 자신의 콘텐츠를 제출하고 경쟁하는 이벤트. 프로젝트 MOD의 공모전은 다양한 창작물을 모집하여 수상자를 선정하고 창작 생태계를 활성화하는 목적을 가짐."
    },
    {
        "term": "유니티 (Unity)",
        "description": "게임 및 시뮬레이션을 제작하기 위한 크로스 플랫폼 엔진으로, 많은 개발자들에 의해 사용됨. 직관적인 인터페이스와 강력한 그래픽 처리 기능 덕분에, 사용자들이 쉽게 콘텐츠를 개발할 수 있도록 지원."
    },
    {
        "term": "코딩 및 모딩",
        "description": "사용자가 프로그래밍 언어를 사용하여 새로운 기능이나 콘텐츠를 추가하거나 기존 콘텐츠를 수정하는 과정. 프로젝트 MOD는 이러한 기능을 지원하여 사용자가 자유롭게 창작할 수 있도록 함."
    },
    {
        "term": "강좌 콘텐츠",
        "description": "사용자가 콘텐츠 제작 기술을 배우기 위한 교육 자료로, 프로젝트 MOD에서는 다양한 주제의 강좌가 제공되어 사용자들이 쉽게 새로운 기술을 습득할 수 있도록 함."
    },
    {
        "term": "실시간 디버깅",
        "description": "코드를 실행하면서 오류를 찾아 수정하는 과정으로, 개발자가 작업 중 발생하는 문제를 즉시 해결할 수 있도록 돕는 기능. 프로젝트 MOD는 이를 통해 효율적인 콘텐츠 개발을 지원."
    },
    {
        "term": "내부 리그",
        "description": "프로젝트 MOD 사용자들 간의 경쟁을 촉진하기 위한 이벤트로, 창작자들은 자신의 기술과 상상력을 발휘하여 다른 참가자들과 경쟁하며 동기부여를 받을 수 있음."
    },
    {
        "term": "사용자 친화적 인터페이스",
        "description": "메타버스 플랫폼이 제공하는 인터페이스로, 사용자가 쉽게 접근하고 활용할 수 있도록 설계되어 있으며, 직관적인 내비게이션과 기능 배치로 사용 편의성을 높임."
    },
    {
        "term": "Strategy Pattern",
        "description": "전략 패턴은 알고리즘을 정의하고 이를 캡슐화하여 각각의 알고리즘을 교환 가능하게 만드는 디자인 패턴입니다. 이 패턴은 런타임에 알고리즘을 선택할 수 있는 유연성을 제공하며, 코드의 재사용성을 높이고 관리의 용이성을 증가시킵니다."
    },
    {
        "term": "베이스 클래스",
        "description": "베이스 클래스는 여러 서브 클래스가 상속받아 공통의 속성과 기능을 제공하는 클래스를 의미합니다. 이를 통해 코드의 중복성을 줄이고 기능의 확장을 용이하게 합니다."
    },
    {
        "term": "서브 클래스",
        "description": "서브 클래스는 하나의 베이스 클래스를 상속받아 그 속성과 메서드를 확장하거나 수정하는 클래스입니다. 서브 클래스를 통해 특정 기능을 개선하거나 새로운 기능을 추가할 수 있습니다."
    },
    {
        "term": "리팩토링",
        "description": "리팩토링은 기존의 소스 코드를 수정하여 코드의 구조나 가독성을 높이는 과정으로, 기능을 변화시키지 않으면서 코드를 개선합니다. 전략 패턴과 같은 디자인 패턴을 적용하여 코드의 확장성을 높이며 유지보수를 간편하게 만듭니다."
    },
    {
        "term": "어빌리티 시스템",
        "description": "어빌리티 시스템은 게임 내에서 캐릭터가 사용할 수 있는 다양한 능력을 구현하기 위한 구조입니다. 각 능력은 객체 지향적으로 설계되어, 기능의 추가 및 제거가 용이하며, 이를 통해 게임의 다양성을 증가시키는 데 기여합니다."
    },
    {
        "term": "렌더러 피처",
        "description": "렌더러 피처는 게임의 렌더링 파이프라인에서 특정한 기능을 추가하거나 수정하는 모듈입니다. 이러한 피처를 활용하면 그래픽 표현을 보다 다양하고 풍부하게 만들 수 있으며, 전략 패턴의 구조적 접근으로 이러한 기능의 통합이 가능해집니다."
    },
    {
        "term": "네이버 지식iN",
        "description": "네이버 지식iN은 사용자들이 다양한 질문과 답변을 공유하는 커뮤니티 플랫폼으로, 사용자들은 이곳에서 정보를 검색하고 제공할 수 있습니다. 특히, 유니티와 같은 개발 관련 질문이 많이 올라오며, 여기서 '신' 등급은 고유의 성취를 나타냅니다."
    },
    {
        "term": "신 등급",
        "description": "네이버 지식iN의 등급 시스템 중 하나로, 사용자가 특정 질문에 대해 일정 수의 답변을 제공하여 획득할 수 있는 등급입니다. '신' 등급은 중간 단계로, 많은 사용자들이 이 등급을 목표로 하여 활동을 이어갑니다."
    },
    {
        "term": "골드메탈",
        "description": "네이버 지식iN에서 특정 성취를 나타내는 레벨 중 하나로, 해당 사용자가 많은 질문에 정답을 제공했음을 의미합니다. 이 메달은 사용자의 상호 작용과 기여도를 나타내는 중요한 지표입니다."
    },
    {
        "term": "유니티 허브 카페",
        "description": "네이버 카페의 하나로, 유니티 관련 질문과 답변, 정보 공유가 활발하게 이루어지는 커뮤니티 공간입니다. 전문가와 초보자 모두가 정보 교류를 통해 유니티에 대한 깊이 있는 이해를 돕는 역할을 합니다."
    },
    {
        "term": "사용자 참여",
        "description": "온라인 커뮤니티에서 사용자가 단순히 소비하는 것을 넘어 질문을 하고 답변을 제공하는 활동을 말합니다. 이러한 참여는 커뮤니티의 활성화와 지식 공유에 중요한 역할을 합니다."
    },
    {
        "term": "실습 기반 학습",
        "description": "이론적인 지식 뿐만 아니라 실제 코딩과 같은 실습을 통해 배운 지식을 강화하는 학습 방법입니다. 유니티의 경우, 예제 질문에 대한 실습을 통해 직접 코드를 작성하고 그 결과를 사용 하여 답변을 제공하는 것이 포함됩니다."
    },
    {
        "term": "Factory 패턴",
        "description": "객체 생성을 위한 디자인 패턴으로, 구체적인 클래스에 의존하지 않고 다양한 형태의 객체를 생성할 수 있는 구조를 제공합니다. 이를 통해 객체 생성이 간소화되고, 유지보수성이 향상됩니다."
    },
    {
        "term": "아이템 매니저",
        "description": "게임 내 다양한 아이템을 관리하는 필수 요소로, 팩토리 패턴을 통해 객체 생성을 간소화하고 복잡도를 낮추어 유지보수를 쉽게 합니다."
    },
    {
        "term": "팩토리 메서드",
        "description": "구체적인 클래스의 인스턴스를 직접 생성하지 않고 객체를 생성하는 인터페이스를 정의하여 객체 생성의 추상화를 수행하는 패턴입니다."
    },
    {
        "term": "추상 팩토리",
        "description": "관련된 객체들을 생성하기 위한 인터페이스를 제공하는 패턴으로, 여러 종류의 객체를 생성하고 관리할 수 있도록 돕습니다. 팩토리 메서드와 함께 자주 사용됩니다."
    },
    {
        "term": "키-값 딕셔너리",
        "description": "게임에서 다양한 종류의 아이템을 효율적으로 관리하고 검색할 수 있는 데이터 구조로, 객체에 대한 유연하고 다양한 접근 방식을 제공합니다."
    },
    {
        "term": "객체 생성의 추상화",
        "description": "팩토리 패턴을 통해 객체 생성을 구체적인 구현과 분리하여 관리하는 기술로, 코드의 재사용성과 확장성을 높이는 데 기여합니다."
    },
    {
        "term": "Flyweight 패턴",
        "description": "Flyweight 패턴은 메모리 효율성을 높이기 위해 대량의 인스턴스를 관리하는 디자인 패턴이다. 이는 동일한 데이터의 중복을 피하고, 공통된 데이터를 공유함으로써 메모리 사용량을 최소화하는 데 중점을 둔다."
    },
    {
        "term": "메모리 최적화",
        "description": "메모리 최적화는 애플리케이션의 성능을 높이기 위해 메모리 사용량을 줄이는 기법으로, Flyweight 패턴은 객체 복제로 인한 불필요한 메모리 사용을 방지하여 최적화를 도와준다."
    },
    {
        "term": "객체 복제",
        "description": "객체 복제는 동일한 데이터 구조를 가진 객체를 여러 번 생성하는 것을 의미하며, 이는 메모리 낭비를 초래할 수 있다. Flyweight 패턴은 이러한 복제를 줄이는 해결책을 제공한다."
    },
    {
        "term": "리소스 공유",
        "description": "리소스 공유는 여러 객체가 동일한 자원이나 데이터를 동시에 사용할 수 있도록 함으로써 메모리 사용량을 줄이고 성능을 최적화하는 기술이다. Flyweight 패턴의 핵심 개념 중 하나이다."
    },
    {
        "term": "중복数据",
        "description": "중복 데이터는 여러 객체가 중복으로 소유하는 데이터로, Flyweight 패턴을 통해 이러한 데이터를 최소화하고 공통된 데이터 참조를 통해 메모리 사용을 최적화한다."
    },
    {
        "term": "비행기 객체 예시",
        "description": "Flyweight 패턴의 이해를 돕기 위해 비행기 객체를 예로 들 수 있다. 여러 비행기가 비슷한 속성을 가질 때, 공통적으로 필요한 데이터는 공유하고, 인스턴스별로 다른 필드는 별도로 유지하는 식으로 패턴이 구현된다."
    },
    {
        "term": "성능 향상",
        "description": "Flyweight 패턴을 통해 메모리 사용량이 줄어들면, 결과적으로 애플리케이션의 성능이 향상된다. 게임과 같이 많은 객체를 생성하고 사용하는 환경에서 특히 효과적이다."
    },
    {
        "term": "DirtyFlag 패턴",
        "description": "DirtyFlag 패턴은 메모리 최적화를 위한 디자인 패턴으로, 기능의 활성화 여부를 효율적으로 관리하여 메모리 사용을 최적화하는 방법론이다. 주로 게임과 같은 복잡한 시스템에서 사용되며, 리소스의 로드와 언로드 시점을 조절하여 성능을 향상시킨다."
    },
    {
        "term": "하이어라키 시스템",
        "description": "하이어라키 시스템에서는 부모 객체가 이동할 때 자식 객체의 위치를 계산하는 과정에서 DirtyFlag를 사용하여 계산 비용을 줄인다. 이를 통해 모든 자식 객체를 개별적으로 계산하지 않고, 부모 객체의 위치 변화에 맞춰 자식 객체의 위치를 최소한으로 업데이트한다."
    },
    {
        "term": "청크 단위 관리",
        "description": "월드를 청크 단위로 나누어 각 청크를 독립적으로 로드 및 언로드함으로써 메모리 사용의 효율성을 극대화한다. 플레이어가 특정 청크에 들어가면 그 청크에 필요한 리소스만 로드하고, 이전 청크는 해제한다."
    },
    {
        "term": "UI 시스템 최적화",
        "description": "UI 시스템에서도 DirtyFlag 패턴을 활용하여 레이아웃 변경과 그래픽 업데이들에 대해 성능을 최적화한다. 예를 들어, UI의 변경 사항을 즉시 반영하기보다는 DirtyFlag를 통해 일괄 처리하여 성능을 향상시킬 수 있다."
    },
    {
        "term": "비용 최소화",
        "description": "DirtyFlag 패턴은 시스템의 활성화와 비활성화 상태를 효과적으로 관리하여 계산 비용을 줄이는 데 기여한다. 이는 특히 여러 자식 객체가 동시에 수정될 수 있는 상황에서 중요한 효율성을 제공한다."
    },
    {
        "term": "Batching",
        "description": "배칭(Batching)은 다수의 렌더링 작업을 하나로 묶어 GPU에 전송하는 기법으로, 드로우 콜 수를 줄여 성능을 최적화하는 데 중요한 역할을 한다. 이를 통해 CPU와 GPU 간의 통신을 최소화하여 게임의 프레임 속도를 향상시킬 수 있다."
    },
    {
        "term": "Draw Call",
        "description": "드로우 콜(Draw Call)은 CPU가 GPU에 그래픽 데이터를 그리도록 요청하는 명령을 의미한다. 드로우 콜의 수가 많아질수록 성능이 저하되므로, 배칭을 통해 이를 줄이는 것이 중요하다."
    },
    {
        "term": "Static Batching",
        "description": "정적 배칭(Static Batching)은 이동하지 않는 정적 오브젝트를 하나의 배치로 묶어 렌더링하는 방법으로, 메모리 소모가 상대적으로 크지만 드로우 콜 수를 줄여 성능을 개선할 수 있다."
    },
    {
        "term": "Dynamic Batching",
        "description": "동적 배칭(Dynamic Batching)은 움직이는 오브젝트를 하나의 배치로 묶어 처리하는 기법으로, 동일한 매트리얼을 사용하는 경우 CPU가 버텍스 정보를 모아 재활용해 성능을 높인다. 그러나, 여러 조건을 충족해야 하며, 모든 경우에 적용 가능한 것은 아니다."
    },
    {
        "term": "SRP Batcher",
        "description": "SRP 배칭(SRP Batching)은 Scriptable Render Pipeline(SRP)에서 적용되는 배칭 기술로, URP 및 HDRP와 함께 사용돼야 하며, 동일한 쉐이더를 사용하는 오브젝트의 패스 콜 수를 줄여 최적화한다."
    },
    {
        "term": "GPU Instancing",
        "description": "GPU 인스턴싱(GPU Instancing)은 동일한 오브젝트의 데이터만 전송하여 여러 인스턴스를 효율적으로 렌더링하는 방법이다. 이는 드로우 인스턴스 콜을 통해 가능하며, 메모리 사용량과 성능 개선에 크게 기여한다."
    },
    {
        "term": "SetPass Call",
        "description": "셋패스 콜(SetPass Call)은 GPU에서 렌더링에 필요한 셰이더 및 상태를 설정하는 호출을 의미한다. 이 호출도 최적화의 중요한 요소로, 배칭 기법을 사용하면 이를 줄일 수 있어 성능 향상에 기여한다."
    },
    {
        "term": "Material",
        "description": "재질(Material)은 3D 오브젝트에 적용되는 표면 특성을 정의하는 자원으로, 배칭 최적화에서 재질 수의 관리는 매우 중요하다. 여러 재질을 사용할 경우 드로우 콜이 늘어나므로, 가능한 한 재질 수를 줄이는 것이 좋다."
    },
    {
        "term": "Performance Optimization",
        "description": "성능 최적화(Performance Optimization)는 게임이나 애플리케이션의 실행 속도를 향상시키기 위해 다양한 기법과 전략을 적용하는 과정이다. 배칭은 이 과정에서 필수적인 것으로, 전반적인 사용자 경험에 긍정적인 영향을 미친다."
    },
    {
        "term": "청약통장",
        "description": "청약통장은 주택청약을 위한 저축 통장으로, 정부의 주택 분양 제도에 참여하기 위해 필요한 기본적인 금융 상품입니다. 청약통장에 납입한 금액은 청약 시 가점에 반영되며, 이를 통해 내 집 마련의 기회를 높일 수 있습니다."
    },
    {
        "term": "주택청약종합저축",
        "description": "주택청약종합저축은 2014년 도입된 청약 통장으로, 기존의 청약 예금 및 부금의 납입 이력을 포괄하여 승계할 수 있습니다. 이 통장은 다양한 주택 공급 방식에서 청약에 참여할 수 있도록 허용하며, 특히 공공분양에서 경쟁력을 높이는 데 중요한 역할을 합니다."
    },
    {
        "term": "납입 한도 상향",
        "description": "청약통장의 월 납입 한도가 41년만에 10만 원에서 25만 원으로 상향되었습니다. 이는 청약 통장을 이용한 주택 청약을 활성화하기 위한 정책으로, 영속적인 주택 자산 형성을 촉진하고 개인의 저축 능력에 따라 선택적으로 활용할 수 있게 합니다."
    },
    {
        "term": "가점제",
        "description": "가점제는 청약 신청자의 납입 횟수, 무주택 기간, 자녀 수 등 다양한 요소를 종합하여 점수를 부여하는 방식입니다. 이 점수를 기반으로 당첨자를 결정하기 때문에, 최소한의 납입 횟수를 충족하고 납입 기간을 늘리는 것이 중요합니다."
    },
    {
        "term": "공공분양",
        "description": "공공분양은 정부가 주도하는 주택 공급 방식으로, 상대적으로 저렴한 가격으로 주택을 공급하는 목적으로 운영됩니다. 이때 청약통장을 가진 신청자는 다양한 특별 공급 혜택을 통해 상대적으로 유리한 조건으로 청약할 수 있는 기회를 가집니다."
    },
    {
        "term": "미성년자 청약 납입 인정 기간",
        "description": "2024년부터 미성년자의 청약 통장 납입이 인정되는 기간이 최대 5년으로 확대됩니다. 이는 미성년자 청약자에게 더 많은 혜택을 제공하며, 자녀에게 조기에 청약 통장을 만들어 주는 것이 유리할 수 있음을 시사합니다."
    },
    {
        "term": "부담 없는 저축",
        "description": "청약통장에 월 25만 원을 납입하는 것이 부담스러운 상황에서는, 자신의 재정 상황을 고려하여 유연하게 납입액을 조절하는 전략이 필요합니다. 예를 들어, 초기에는 적은 금액을 납입하며 여유 자금을 다른 투자에 활용하는 방법도 있습니다."
    },
    {
        "term": "Command 패턴",
        "description": "Command 패턴은 요청을 객체로 캡슐화하여 사용자가 객체를 통해 명령을 실행하고, 이 명령을 큐 또는 스택에 저장하는 프로그래밍 디자인 패턴이다. 이를 통해 기존 코드에 수정 없이 새로운 명령이나 기능을 쉽게 추가할 수 있다."
    },
    {
        "term": "캡슐화",
        "description": "캡슐화는 객체 지향 프로그래밍에서 데이터를 보호하고, 그 데이터에 대한 접근 방식을 제어하기 위해 사용하는 개념이다. Command 패턴은 각 명령을 객체로 캡슐화하여 시스템의 복잡성을 줄인다."
    },
    {
        "term": "Undo/Redo 기능",
        "description": "Undo/Redo 기능은 사용자가 이전의 작업을 취소(Undo)하거나 다시 수행(Redo)할 수 있게 해주는 기능으로, Command 패턴을 통해 각 명령의 상태를 관리하고 복구하는 데 활용된다."
    },
    {
        "term": "Flexibility (유연성)",
        "description": "Command 패턴은 여러 개의 커맨드 클래스를 정의함으로써 유연성을 제공한다. 이는 프로그램에서 다양한 행동을 각각의 명령으로 다뤄 다양한 상황에 맞게 조정할 수 있도록 한다."
    },
    {
        "term": "execute 메소드",
        "description": "Command 패턴의 커맨드 객체는 각기 다른 명령을 수행하기 위해 'execute'라는 메소드를 정의한다. 이 메소드는 명령이 실행될 때 호출되는 기본 메소드로, 커맨드에 따라 다양한 행동을 구현할 수 있다."
    },
    {
        "term": "결합도와 응집도",
        "description": "결합도는 모듈 간의 의존성을 나타내며, 응집도는 모듈 내부의 요소가 얼마나 밀접하게 연관되어 있는지를 나타낸다. Command 패턴은 낮은 결합도와 높은 응집도를 통해 시스템의 유지보수성을 향상시킨다."
    },
    {
        "term": "프로젝트 구조",
        "description": "Command 패턴을 적용할 때는 프로젝트의 구조를 명확하게 이해하는 것이 중요하다. 각 Command 클래스와 관련된 모듈의 관계를 잘 정리하면 향후 시스템 확장 시 유용하다."
    }
]